(assume nt50.0 (not (not (forall ((?v0 A_llist$) (?v1 Nat_a_llist_fun$) (?v2 Nat$)) (= (fun_app$h ?v1 ?v2) (fun_app$h (fun_app$o (case_nat$ ?v0) ?v1) (suc$ ?v2)))))))
(assume nt50.1 (not (= (fun_app$h (uvn$ (ltl$ xs$)) n$) (fun_app$h (fun_app$o (case_nat$ (lCons$ (lhd$ xs$) (ltl$ xs$))) (uvn$ (ltl$ xs$))) (suc$ n$)))))
(anchor :step t50)
(assume t50.a0 (forall ((?v0 A_llist$) (?v1 Nat_a_llist_fun$) (?v2 Nat$)) (= (fun_app$h ?v1 ?v2) (fun_app$h (fun_app$o (case_nat$ ?v0) ?v1) (suc$ ?v2)))))
(step st50.t0 (cl (or (not (forall ((?v0 A_llist$) (?v1 Nat_a_llist_fun$) (?v2 Nat$)) (= (fun_app$h ?v1 ?v2) (fun_app$h (fun_app$o (case_nat$ ?v0) ?v1) (suc$ ?v2))))) (= (fun_app$h (uvn$ (ltl$ xs$)) n$) (fun_app$h (fun_app$o (case_nat$ (lCons$ (lhd$ xs$) (ltl$ xs$))) (uvn$ (ltl$ xs$))) (suc$ n$))))) :rule forall_inst :args ((lCons$ (lhd$ xs$) (ltl$ xs$)) (uvn$ (ltl$ xs$)) n$))
(step t50.t5 (cl (= (fun_app$h (uvn$ (ltl$ xs$)) n$) (fun_app$h (fun_app$o (case_nat$ (lCons$ (lhd$ xs$) (ltl$ xs$))) (uvn$ (ltl$ xs$))) (suc$ n$)))) :rule trust)
(step t50 (cl (not (forall ((?v0 A_llist$) (?v1 Nat_a_llist_fun$) (?v2 Nat$)) (= (fun_app$h ?v1 ?v2) (fun_app$h (fun_app$o (case_nat$ ?v0) ?v1) (suc$ ?v2))))) (= (fun_app$h (uvn$ (ltl$ xs$)) n$) (fun_app$h (fun_app$o (case_nat$ (lCons$ (lhd$ xs$) (ltl$ xs$))) (uvn$ (ltl$ xs$))) (suc$ n$)))) :rule subproof :discharge (t50.a0))
(step t.end (cl) :rule resolution :premises (nt50.0 nt50.1 t50))
