(assume nt39.0 (not (= (forall ((?v0 Enat$) (?v1 A_llist$)) (= (not (fun_app$h lnull$ (fun_app$c (ltake$ ?v0) ?v1))) (and (not (= zero$ ?v0)) (not (fun_app$h lnull$ ?v1))))) (forall ((?v0 Enat$) (?v1 A_llist$)) (= (not (fun_app$h lnull$ (fun_app$c (ltake$ ?v0) ?v1))) (and (not (= (fun_app$n (enat_unfold$b lnull$ uud$) lNil$) ?v0)) (not (fun_app$h lnull$ ?v1))))))))
(anchor :step t39 :args ((?v0 Enat$) (?v1 A_llist$) (:= (?v0 Enat$) ?v0) (:= (?v1 A_llist$) ?v1)))
(step t39.t0 (cl (= (not (fun_app$h lnull$ (fun_app$c (ltake$ ?v0) ?v1))) (not (fun_app$h lnull$ (fun_app$c (ltake$ ?v0) ?v1))))) :rule trust)
(step t39.t9 (cl (= (and (not (= zero$ ?v0)) (not (fun_app$h lnull$ ?v1))) (and (not (= (fun_app$n (enat_unfold$b lnull$ uud$) lNil$) ?v0)) (not (fun_app$h lnull$ ?v1))))) :rule trust)
(step st39.t10 (cl (= (= (not (fun_app$h lnull$ (fun_app$c (ltake$ ?v0) ?v1))) (and (not (= zero$ ?v0)) (not (fun_app$h lnull$ ?v1)))) (= (not (fun_app$h lnull$ (fun_app$c (ltake$ ?v0) ?v1))) (and (not (= (fun_app$n (enat_unfold$b lnull$ uud$) lNil$) ?v0)) (not (fun_app$h lnull$ ?v1)))))) :rule cong :premises (t39.t0 t39.t9))
(step t39.t10 (cl (= (= (not (fun_app$h lnull$ (fun_app$c (ltake$ ?v0) ?v1))) (and (not (= zero$ ?v0)) (not (fun_app$h lnull$ ?v1)))) (= (not (fun_app$h lnull$ (fun_app$c (ltake$ ?v0) ?v1))) (and (not (= (fun_app$n (enat_unfold$b lnull$ uud$) lNil$) ?v0)) (not (fun_app$h lnull$ ?v1)))))) :rule trust)
(step t39 (cl (= (forall ((?v0 Enat$) (?v1 A_llist$)) (= (not (fun_app$h lnull$ (fun_app$c (ltake$ ?v0) ?v1))) (and (not (= zero$ ?v0)) (not (fun_app$h lnull$ ?v1))))) (forall ((?v0 Enat$) (?v1 A_llist$)) (= (not (fun_app$h lnull$ (fun_app$c (ltake$ ?v0) ?v1))) (and (not (= (fun_app$n (enat_unfold$b lnull$ uud$) lNil$) ?v0)) (not (fun_app$h lnull$ ?v1))))))) :rule bind)
(step t.end (cl) :rule resolution :premises (nt39.0 t39))
