(assume nt42.0 (not (= (forall ((?v0 Nat$) (?v1 A_a_fun$) (?v2 A$)) (= (fun_app$ (ldropn$ ?v0) (iterates$ ?v1 ?v2)) (iterates$ ?v1 (fun_app$a (fun_app$b (fun_app$c compow$ ?v0) ?v1) ?v2)))) (forall ((?v0 Nat$) (?v1 A_a_fun$) (?v2 A$)) (= (fun_app$ (ldropn$ ?v0) (iterates$ ?v1 ?v2)) (iterates$ ?v1 (fun_app$a (fun_app$b (fun_app$c funpow$ ?v0) ?v1) ?v2)))))))
(anchor :step t42 :args ((?v0 Nat$) (?v1 A_a_fun$) (?v2 A$) (:= (?v0 Nat$) ?v0) (:= (?v1 A_a_fun$) ?v1) (:= (?v2 A$) ?v2)))
(step t42.t2 (cl (= compow$ funpow$)) :rule trust)
(step t42.t3 (cl (= ?v0 ?v0)) :rule trust)
(step st42.t4 (cl (= (fun_app$c compow$ ?v0) (fun_app$c funpow$ ?v0))) :rule cong :premises (t42.t2 t42.t3))
(step t42.t9 (cl (= (= (fun_app$ (ldropn$ ?v0) (iterates$ ?v1 ?v2)) (iterates$ ?v1 (fun_app$a (fun_app$b (fun_app$c compow$ ?v0) ?v1) ?v2))) (= (fun_app$ (ldropn$ ?v0) (iterates$ ?v1 ?v2)) (iterates$ ?v1 (fun_app$a (fun_app$b (fun_app$c funpow$ ?v0) ?v1) ?v2))))) :rule trust)
(step t42 (cl (= (forall ((?v0 Nat$) (?v1 A_a_fun$) (?v2 A$)) (= (fun_app$ (ldropn$ ?v0) (iterates$ ?v1 ?v2)) (iterates$ ?v1 (fun_app$a (fun_app$b (fun_app$c compow$ ?v0) ?v1) ?v2)))) (forall ((?v0 Nat$) (?v1 A_a_fun$) (?v2 A$)) (= (fun_app$ (ldropn$ ?v0) (iterates$ ?v1 ?v2)) (iterates$ ?v1 (fun_app$a (fun_app$b (fun_app$c funpow$ ?v0) ?v1) ?v2)))))) :rule bind)
(step t.end (cl) :rule resolution :premises (nt42.0 t42))
