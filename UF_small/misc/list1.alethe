unsat
(define-fun @quantifiers_skolemize_1 () Elem (choice ((?x1 Elem)) (not (forall ((?y1 List) (?x2 Elem) (?y2 List)) (or (not (= (cons ?x1 ?y1) (cons ?x2 ?y2))) (and (= ?x1 ?x2) (= ?y1 ?y2)))))))
(define-fun @quantifiers_skolemize_2 () List (choice ((?y1 List)) (not (forall ((?x2 Elem) (?y2 List)) (or (not (= (cons @quantifiers_skolemize_1 ?y1) (cons ?x2 ?y2))) (and (= @quantifiers_skolemize_1 ?x2) (= ?y1 ?y2)))))))
(define-fun @quantifiers_skolemize_3 () Elem (choice ((?x2 Elem)) (not (forall ((?y2 List)) (or (not (= (cons @quantifiers_skolemize_1 @quantifiers_skolemize_2) (cons ?x2 ?y2))) (and (= @quantifiers_skolemize_1 ?x2) (= @quantifiers_skolemize_2 ?y2)))))))
(define-fun @quantifiers_skolemize_4 () List (choice ((?y2 List)) (not (or (not (= (cons @quantifiers_skolemize_1 @quantifiers_skolemize_2) (cons @quantifiers_skolemize_3 ?y2))) (and (= @quantifiers_skolemize_1 @quantifiers_skolemize_3) (= @quantifiers_skolemize_2 ?y2))))))
(assume a0 (forall ((?x Elem) (?y List)) (= (car (cons ?x ?y)) ?x)))
(assume a1 (forall ((?x Elem) (?y List)) (= (cdr (cons ?x ?y)) ?y)))
(assume a2 (! (not (forall ((?x1 Elem) (?y1 List) (?x2 Elem) (?y2 List)) (=> (= (cons ?x1 ?y1) (cons ?x2 ?y2)) (and (= ?x1 ?x2) (= ?y1 ?y2))))) :named @p_1))
(step t0 (cl (! (and (! (= @quantifiers_skolemize_1 @quantifiers_skolemize_3) :named @p_3) (! (= @quantifiers_skolemize_2 @quantifiers_skolemize_4) :named @p_2)) :named @p_4) (not @p_3) (not @p_2)) :rule and_neg)
(step t1 (cl (or (! (not (forall ((?x Elem) (?y List)) (= ?y (cdr (cons ?x ?y))))) :named @p_37) (! (= @quantifiers_skolemize_2 (! (cdr (! (cons @quantifiers_skolemize_1 @quantifiers_skolemize_2) :named @p_7)) :named @p_38)) :named @p_39))) :rule forall_inst :args (@quantifiers_skolemize_1 @quantifiers_skolemize_2))
(step t2 (cl @p_37 @p_39) :rule or :premises (t1))
(step t3 (cl (not (! (= (forall ((?x Elem) (?y List)) (= (cdr (cons ?x ?y)) ?y)) (forall ((?x Elem) (?y List)) (= ?y (cdr (cons ?x ?y))))) :named @p_34)) (not (forall ((?x Elem) (?y List)) (= (cdr (cons ?x ?y)) ?y))) (forall ((?x Elem) (?y List)) (= ?y (cdr (cons ?x ?y))))) :rule equiv_pos2)
(anchor :step t4 :args ((?x Elem) (?y List) (:= (?x Elem) ?x) (:= (?y List) ?y)))
(step t4.t0 (cl (! (= (= (! (cdr (! (cons ?x ?y) :named @p_21)) :named @p_35) ?y) (= ?y @p_35)) :named @p_36)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_36 2 6))
(step t4 (cl @p_34) :rule bind)
(step t5 (cl (forall ((?x Elem) (?y List)) (= ?y (cdr (cons ?x ?y))))) :rule resolution :premises (t3 t4 a1))
(step t6 (cl @p_39) :rule resolution :premises (t2 t5))
(step t7 (cl (not (! (= (! (or (! (or (! (not (! (= @p_7 (! (cons @quantifiers_skolemize_3 @quantifiers_skolemize_4) :named @p_6)) :named @p_8)) :named @p_9) @p_4) :named @p_10) (! (not @p_9) :named @p_27)) :named @p_28) (! (or @p_10 @p_8) :named @p_26)) :named @p_29)) (not @p_28) @p_26) :rule equiv_pos2)
(step t8 (cl (= @p_10 @p_10)) :rule refl)
(step t9 (cl (! (= @p_27 @p_8) :named @p_30)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_30 1 5))
(step t10 (cl @p_29) :rule cong :premises (t8 t9))
(step t11 (cl @p_10 @p_27) :rule or_neg :args (0))
(step t12 (cl @p_28 (! (not @p_10) :named @p_11)) :rule or_neg :args (0))
(step t13 (cl @p_28 (not @p_27)) :rule or_neg :args (1))
(step t14 (cl @p_28 @p_28) :rule resolution :premises (t11 t12 t13))
(step t15 (cl @p_28) :rule contraction :premises (t14))
(step t16 (cl @p_26) :rule resolution :premises (t7 t10 t15))
(step t17 (cl @p_10 @p_8) :rule or :premises (t16))
(step t18 (cl @p_8 @p_10) :rule reordering :premises (t17))
(step t19 (cl (not (! (= (! (not (forall ((?x1 Elem) (?y1 List) (?x2 Elem) (?y2 List)) (or (not (= (cons ?x1 ?y1) (cons ?x2 ?y2))) (and (= ?x1 ?x2) (= ?y1 ?y2))))) :named @p_12) @p_11) :named @p_15)) (not @p_12) @p_11) :rule equiv_pos2)
(anchor :step t20 :args ((:= (?x1 Elem) @quantifiers_skolemize_1) (:= (?y1 List) @quantifiers_skolemize_2) (:= (?x2 Elem) @quantifiers_skolemize_3) (:= (?y2 List) @quantifiers_skolemize_4)))
(step t20.t0 (cl (= (or (not (= (cons ?x1 ?y1) (cons ?x2 ?y2))) (and (= ?x1 ?x2) (= ?y1 ?y2))) @p_10)) :rule refl)
(step t20 (cl (= (forall ((?x1 Elem) (?y1 List) (?x2 Elem) (?y2 List)) (or (not (= (cons ?x1 ?y1) (cons ?x2 ?y2))) (and (= ?x1 ?x2) (= ?y1 ?y2)))) @p_10)) :rule sko_forall)
(step t21 (cl @p_15) :rule cong :premises (t20))
(step t22 (cl (not (! (= @p_1 @p_12) :named @p_13)) (not @p_1) @p_12) :rule equiv_pos2)
(step t23 (cl (! (= (forall ((?x1 Elem) (?y1 List) (?x2 Elem) (?y2 List)) (=> (= (cons ?x1 ?y1) (cons ?x2 ?y2)) (and (= ?x1 ?x2) (= ?y1 ?y2)))) (forall ((?x1 Elem) (?y1 List) (?x2 Elem) (?y2 List)) (or (not (= (cons ?x1 ?y1) (cons ?x2 ?y2))) (and (= ?x1 ?x2) (= ?y1 ?y2))))) :named @p_14)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_14 13 6))
(step t24 (cl @p_13) :rule cong :premises (t23))
(step t25 (cl @p_12) :rule resolution :premises (t22 t24 a2))
(step t26 (cl @p_11) :rule resolution :premises (t19 t21 t25))
(step t27 (cl @p_8) :rule resolution :premises (t18 t26))
(step t28 (cl (= @p_38 (! (cdr @p_6) :named @p_32))) :rule cong :premises (t27))
(step t29 (cl (or @p_37 (! (= @quantifiers_skolemize_4 @p_32) :named @p_33))) :rule forall_inst :args (@quantifiers_skolemize_3 @quantifiers_skolemize_4))
(step t30 (cl @p_37 @p_33) :rule or :premises (t29))
(step t31 (cl @p_33) :rule resolution :premises (t30 t5))
(step t32 (cl (= @p_32 @quantifiers_skolemize_4)) :rule symm :premises (t31))
(step t33 (cl @p_2) :rule trans :premises (t6 t28 t32))
(step t34 (cl (or (! (not (forall ((?x Elem) (?y List)) (= ?x (car (cons ?x ?y))))) :named @p_24) (! (= @quantifiers_skolemize_1 (! (car @p_7) :named @p_25)) :named @p_31))) :rule forall_inst :args (@quantifiers_skolemize_1 @quantifiers_skolemize_2))
(step t35 (cl @p_24 @p_31) :rule or :premises (t34))
(step t36 (cl (not (! (= (forall ((?x Elem) (?y List)) (= (car (cons ?x ?y)) ?x)) (forall ((?x Elem) (?y List)) (= ?x (car (cons ?x ?y))))) :named @p_18)) (not (forall ((?x Elem) (?y List)) (= (car (cons ?x ?y)) ?x))) (forall ((?x Elem) (?y List)) (= ?x (car (cons ?x ?y))))) :rule equiv_pos2)
(anchor :step t37 :args ((?x Elem) (?y List) (:= (?x Elem) ?x) (:= (?y List) ?y)))
(step t37.t0 (cl (! (= (= (! (car @p_21) :named @p_22) ?x) (= ?x @p_22)) :named @p_23)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_23 2 6))
(step t37 (cl @p_18) :rule bind)
(step t38 (cl (forall ((?x Elem) (?y List)) (= ?x (car (cons ?x ?y))))) :rule resolution :premises (t36 t37 a0))
(step t39 (cl @p_31) :rule resolution :premises (t35 t38))
(step t40 (cl (= @p_25 (! (car @p_6) :named @p_16))) :rule cong :premises (t27))
(step t41 (cl (or @p_24 (! (= @quantifiers_skolemize_3 @p_16) :named @p_17))) :rule forall_inst :args (@quantifiers_skolemize_3 @quantifiers_skolemize_4))
(step t42 (cl @p_24 @p_17) :rule or :premises (t41))
(step t43 (cl @p_17) :rule resolution :premises (t42 t38))
(step t44 (cl (= @p_16 @quantifiers_skolemize_3)) :rule symm :premises (t43))
(step t45 (cl @p_3) :rule trans :premises (t39 t40 t44))
(step t46 (cl @p_10 (! (not @p_4) :named @p_5)) :rule or_neg :args (1))
(step t47 (cl @p_5) :rule resolution :premises (t46 t26))
(step t48 (cl) :rule resolution :premises (t0 t33 t45 t47))
