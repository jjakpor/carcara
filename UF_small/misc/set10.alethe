unsat
(define-fun @quantifiers_skolemize_3 () Elem (choice ((?x Elem)) (not (or (not (member ?x (union a b))) (member ?x c)))))
(assume a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2))))
(assume a1 (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))))
(assume a2 (forall ((?s1 Set) (?s2 Set)) (=> (forall ((?x Elem)) (=> (member ?x ?s1) (member ?x ?s2))) (subset ?s1 ?s2))))
(assume a3 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (= ?s1 ?s2))))
(assume a4 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (and (subset ?s1 ?s2) (subset ?s2 ?s1)))))
(assume a5 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (union ?s1 ?s2)) (or (member ?x ?s1) (member ?x ?s2)))))
(assume a6 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (intersection ?s1 ?s2)) (and (member ?x ?s1) (member ?x ?s2)))))
(assume a7 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2))))))
(assume a8 (! (subset a c) :named @p_1))
(assume a9 (! (subset b c) :named @p_2))
(assume a10 (! (not (! (subset (! (union a b) :named @p_3) c) :named @p_4)) :named @p_5))
(step t0 (cl (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2))) (! (or (! (not (! (member @quantifiers_skolemize_3 a) :named @p_9)) :named @p_10) (! (not @p_1) :named @p_8) (! (member @quantifiers_skolemize_3 c) :named @p_7)) :named @p_11)) :named @p_46) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :rule implies_neg1)
(anchor :step t1)
(assume t1.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2))))
(step t1.t0 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :named @p_42) @p_11)) :rule forall_inst :args (@quantifiers_skolemize_3 a c))
(step t1.t1 (cl @p_42 @p_11) :rule or :premises (t1.t0))
(step t1.t2 (cl (not (! (= (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :named @p_6)) (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2)))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :rule equiv_pos2)
(step t1.t3 (cl @p_6) :rule hole :args ("TRUST_THEORY_REWRITE" @p_6 13 6))
(step t1.t4 (cl (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :rule resolution :premises (t1.t2 t1.t3 a0))
(step t1.t5 (cl @p_11) :rule resolution :premises (t1.t1 t1.t4))
(step t1 (cl @p_42 @p_11) :rule subproof :discharge (t1.a0))
(step t2 (cl @p_46 @p_11) :rule resolution :premises (t0 t1))
(step t3 (cl @p_46 (! (not @p_11) :named @p_12)) :rule implies_neg2)
(step t4 (cl @p_46 @p_46) :rule resolution :premises (t2 t3))
(step t5 (cl @p_46) :rule contraction :premises (t4))
(step t6 (cl @p_42 @p_11) :rule implies :premises (t5))
(step t7 (cl @p_12 @p_10 @p_8 @p_7) :rule or_pos)
(step t8 (cl @p_8 @p_7 @p_10 @p_12) :rule reordering :premises (t7))
(step t9 (cl (! (or (! (not (! (member @quantifiers_skolemize_3 @p_3) :named @p_15)) :named @p_18) @p_7) :named @p_19) (! (not @p_7) :named @p_43)) :rule or_neg :args (1))
(step t10 (cl (not (! (= (! (not (forall ((?x Elem)) (or (not (member ?x (union a b))) (member ?x c)))) :named @p_21) (! (not @p_19) :named @p_20)) :named @p_32)) (not @p_21) @p_20) :rule equiv_pos2)
(anchor :step t11 :args ((:= (?x Elem) @quantifiers_skolemize_3)))
(step t11.t0 (cl (= (or (not (member ?x @p_3)) (member ?x c)) @p_19)) :rule refl)
(step t11 (cl (= (forall ((?x Elem)) (or (not (member ?x (union a b))) (member ?x c))) @p_19)) :rule sko_forall)
(step t12 (cl @p_32) :rule cong :premises (t11))
(step t13 (cl (! (not (! (or @p_4 @p_21) :named @p_22)) :named @p_31) @p_4 @p_21) :rule or_pos)
(step t14 (cl @p_4 @p_21 @p_31) :rule reordering :premises (t13))
(step t15 (cl (or (! (not (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_30) @p_22)) :rule forall_inst :args (@p_3 c))
(step t16 (cl @p_30 @p_22) :rule or :premises (t15))
(step t17 (cl (not (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_23)) (not (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule equiv_pos2)
(anchor :step t18 :args ((?s1 Set) (?s2 Set) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t18.t0 (cl (= (! (not (subset ?s1 ?s2)) :named @p_26) @p_26)) :rule refl)
(step t18.t1 (cl (! (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) (! (not (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2)))))) :named @p_27)) :named @p_29)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_29 13 6))
(step t18.t2 (cl (! (= (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2))))) (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_28)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_28 13 6))
(step t18.t3 (cl (= @p_27 (! (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_25))) :rule cong :premises (t18.t2))
(step t18.t4 (cl (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) @p_25)) :rule trans :premises (t18.t1 t18.t3))
(step t18.t5 (cl (= (=> @p_26 (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))) (=> @p_26 @p_25))) :rule cong :premises (t18.t0 t18.t4))
(step t18 (cl (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))))) :rule bind)
(step t19 (cl (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_24)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_24 13 6))
(step t20 (cl @p_23) :rule trans :premises (t18 t19))
(step t21 (cl (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule resolution :premises (t17 t20 a1))
(step t22 (cl @p_22) :rule resolution :premises (t16 t21))
(step t23 (cl @p_21) :rule resolution :premises (t14 a10 t22))
(step t24 (cl @p_20) :rule resolution :premises (t10 t12 t23))
(step t25 (cl @p_43) :rule resolution :premises (t9 t24))
(step t26 (cl (! (not (! (or @p_9 (! (member @quantifiers_skolemize_3 b) :named @p_13)) :named @p_14)) :named @p_45) @p_9 @p_13) :rule or_pos)
(step t27 (cl @p_9 @p_13 @p_45) :rule reordering :premises (t26))
(step t28 (cl (! (not (! (or (! (not @p_13) :named @p_39) (! (not @p_2) :named @p_40) @p_7) :named @p_41)) :named @p_44) @p_39 @p_40 @p_7) :rule or_pos)
(step t29 (cl @p_40 @p_7 @p_39 @p_44) :rule reordering :premises (t28))
(step t30 (cl (or @p_42 @p_41)) :rule forall_inst :args (@quantifiers_skolemize_3 b c))
(step t31 (cl @p_42 @p_41) :rule or :premises (t30))
(step t32 (cl (not @p_6) (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2)))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :rule equiv_pos2)
(step t33 (cl @p_6) :rule hole :args ("TRUST_THEORY_REWRITE" @p_6 13 6))
(step t34 (cl (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :rule resolution :premises (t32 t33 a0))
(step t35 (cl @p_41) :rule resolution :premises (t31 t34))
(step t36 (cl @p_39) :rule resolution :premises (t29 a9 t25 t35))
(step t37 (cl (! (not (! (= @p_15 @p_14) :named @p_16)) :named @p_38) @p_18 @p_14) :rule equiv_pos2)
(step t38 (cl @p_18 @p_14 @p_38) :rule reordering :premises (t37))
(step t39 (cl (not (! (= (! (or @p_19 (! (not @p_18) :named @p_34)) :named @p_35) (! (or @p_19 @p_15) :named @p_33)) :named @p_36)) (not @p_35) @p_33) :rule equiv_pos2)
(step t40 (cl (= @p_19 @p_19)) :rule refl)
(step t41 (cl (! (= @p_34 @p_15) :named @p_37)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_37 1 5))
(step t42 (cl @p_36) :rule cong :premises (t40 t41))
(step t43 (cl @p_19 @p_34) :rule or_neg :args (0))
(step t44 (cl @p_35 @p_20) :rule or_neg :args (0))
(step t45 (cl @p_35 (not @p_34)) :rule or_neg :args (1))
(step t46 (cl @p_35 @p_35) :rule resolution :premises (t43 t44 t45))
(step t47 (cl @p_35) :rule contraction :premises (t46))
(step t48 (cl @p_33) :rule resolution :premises (t39 t42 t47))
(step t49 (cl @p_19 @p_15) :rule or :premises (t48))
(step t50 (cl @p_15 @p_19) :rule reordering :premises (t49))
(step t51 (cl @p_15) :rule resolution :premises (t50 t24))
(step t52 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (union ?s1 ?s2)) (or (member ?x ?s1) (member ?x ?s2))))) :named @p_17) @p_16)) :rule forall_inst :args (@quantifiers_skolemize_3 a b))
(step t53 (cl @p_17 @p_16) :rule or :premises (t52))
(step t54 (cl @p_16) :rule resolution :premises (t53 a5))
(step t55 (cl @p_14) :rule resolution :premises (t38 t51 t54))
(step t56 (cl @p_9) :rule resolution :premises (t27 t36 t55))
(step t57 (cl @p_12) :rule resolution :premises (t8 a8 t25 t56))
(step t58 (cl) :rule resolution :premises (t6 t57 t34))
