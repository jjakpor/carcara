unsat
(define-fun @quantifiers_skolemize_3 () Elem (choice ((?x Elem)) (not (or (not (member ?x (difference b a))) (member ?x (difference b d))))))
(assume a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2))))
(assume a1 (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))))
(assume a2 (forall ((?s1 Set) (?s2 Set)) (=> (forall ((?x Elem)) (=> (member ?x ?s1) (member ?x ?s2))) (subset ?s1 ?s2))))
(assume a3 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (= ?s1 ?s2))))
(assume a4 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (and (subset ?s1 ?s2) (subset ?s2 ?s1)))))
(assume a5 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (union ?s1 ?s2)) (or (member ?x ?s1) (member ?x ?s2)))))
(assume a6 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (intersection ?s1 ?s2)) (and (member ?x ?s1) (member ?x ?s2)))))
(assume a7 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2))))))
(assume a8 (! (subset d a) :named @p_1))
(assume a9 (! (not (! (subset (! (difference b a) :named @p_3) (! (difference b d) :named @p_2)) :named @p_4)) :named @p_5))
(step t0 (cl (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2))) (! (or (! (not (! (member @quantifiers_skolemize_3 d) :named @p_9)) :named @p_10) (! (not @p_1) :named @p_8) (! (member @quantifiers_skolemize_3 a) :named @p_7)) :named @p_11)) :named @p_70) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :rule implies_neg1)
(anchor :step t1)
(assume t1.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2))))
(step t1.t0 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :named @p_69) @p_11)) :rule forall_inst :args (@quantifiers_skolemize_3 d a))
(step t1.t1 (cl @p_69 @p_11) :rule or :premises (t1.t0))
(step t1.t2 (cl (not (! (= (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :named @p_6)) (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2)))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :rule equiv_pos2)
(step t1.t3 (cl @p_6) :rule hole :args ("TRUST_THEORY_REWRITE" @p_6 13 6))
(step t1.t4 (cl (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :rule resolution :premises (t1.t2 t1.t3 a0))
(step t1.t5 (cl @p_11) :rule resolution :premises (t1.t1 t1.t4))
(step t1 (cl @p_69 @p_11) :rule subproof :discharge (t1.a0))
(step t2 (cl @p_70 @p_11) :rule resolution :premises (t0 t1))
(step t3 (cl @p_70 (! (not @p_11) :named @p_12)) :rule implies_neg2)
(step t4 (cl @p_70 @p_70) :rule resolution :premises (t2 t3))
(step t5 (cl @p_70) :rule contraction :premises (t4))
(step t6 (cl @p_69 @p_11) :rule implies :premises (t5))
(step t7 (cl @p_12 @p_10 @p_8 @p_7) :rule or_pos)
(step t8 (cl @p_8 @p_7 @p_10 @p_12) :rule reordering :premises (t7))
(step t9 (cl (! (not (! (and (! (member @quantifiers_skolemize_3 b) :named @p_13) (! (not @p_7) :named @p_14)) :named @p_15)) :named @p_52) @p_14) :rule and_pos :args (1))
(step t10 (cl @p_14 @p_52) :rule reordering :premises (t9))
(step t11 (cl (! (not (! (= (! (member @quantifiers_skolemize_3 @p_3) :named @p_16) @p_15) :named @p_17)) :named @p_51) (! (not @p_16) :named @p_31) @p_15) :rule equiv_pos2)
(step t12 (cl @p_31 @p_15 @p_51) :rule reordering :premises (t11))
(step t13 (cl (not (! (= (! (or (! (or @p_31 (! (member @quantifiers_skolemize_3 @p_2) :named @p_30)) :named @p_32) (! (not @p_31) :named @p_47)) :named @p_48) (! (or @p_32 @p_16) :named @p_46)) :named @p_49)) (not @p_48) @p_46) :rule equiv_pos2)
(step t14 (cl (= @p_32 @p_32)) :rule refl)
(step t15 (cl (! (= @p_47 @p_16) :named @p_50)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_50 1 5))
(step t16 (cl @p_49) :rule cong :premises (t14 t15))
(step t17 (cl @p_32 @p_47) :rule or_neg :args (0))
(step t18 (cl @p_48 (! (not @p_32) :named @p_33)) :rule or_neg :args (0))
(step t19 (cl @p_48 (not @p_47)) :rule or_neg :args (1))
(step t20 (cl @p_48 @p_48) :rule resolution :premises (t17 t18 t19))
(step t21 (cl @p_48) :rule contraction :premises (t20))
(step t22 (cl @p_46) :rule resolution :premises (t13 t16 t21))
(step t23 (cl @p_32 @p_16) :rule or :premises (t22))
(step t24 (cl @p_16 @p_32) :rule reordering :premises (t23))
(step t25 (cl (not (! (= (! (not (forall ((?x Elem)) (or (not (member ?x (difference b a))) (member ?x (difference b d))))) :named @p_34) @p_33) :named @p_45)) (not @p_34) @p_33) :rule equiv_pos2)
(anchor :step t26 :args ((:= (?x Elem) @quantifiers_skolemize_3)))
(step t26.t0 (cl (= (or (not (member ?x @p_3)) (member ?x @p_2)) @p_32)) :rule refl)
(step t26 (cl (= (forall ((?x Elem)) (or (not (member ?x (difference b a))) (member ?x (difference b d)))) @p_32)) :rule sko_forall)
(step t27 (cl @p_45) :rule cong :premises (t26))
(step t28 (cl (! (not (! (or @p_4 @p_34) :named @p_35)) :named @p_44) @p_4 @p_34) :rule or_pos)
(step t29 (cl @p_4 @p_34 @p_44) :rule reordering :premises (t28))
(step t30 (cl (or (! (not (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_43) @p_35)) :rule forall_inst :args (@p_3 @p_2))
(step t31 (cl @p_43 @p_35) :rule or :premises (t30))
(step t32 (cl (not (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_36)) (not (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule equiv_pos2)
(anchor :step t33 :args ((?s1 Set) (?s2 Set) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t33.t0 (cl (= (! (not (subset ?s1 ?s2)) :named @p_39) @p_39)) :rule refl)
(step t33.t1 (cl (! (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) (! (not (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2)))))) :named @p_40)) :named @p_42)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_42 13 6))
(step t33.t2 (cl (! (= (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2))))) (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_41)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_41 13 6))
(step t33.t3 (cl (= @p_40 (! (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_38))) :rule cong :premises (t33.t2))
(step t33.t4 (cl (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) @p_38)) :rule trans :premises (t33.t1 t33.t3))
(step t33.t5 (cl (= (=> @p_39 (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))) (=> @p_39 @p_38))) :rule cong :premises (t33.t0 t33.t4))
(step t33 (cl (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))))) :rule bind)
(step t34 (cl (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_37)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_37 13 6))
(step t35 (cl @p_36) :rule trans :premises (t33 t34))
(step t36 (cl (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule resolution :premises (t32 t35 a1))
(step t37 (cl @p_35) :rule resolution :premises (t31 t36))
(step t38 (cl @p_34) :rule resolution :premises (t29 a9 t37))
(step t39 (cl @p_33) :rule resolution :premises (t25 t27 t38))
(step t40 (cl @p_16) :rule resolution :premises (t24 t39))
(step t41 (cl (not (! (= (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (! (= @p_15 @p_16) :named @p_26)) :named @p_27) (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) @p_17) :named @p_25)) :named @p_28)) (not @p_27) @p_25) :rule equiv_pos2)
(step t42 (cl (= (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))) :rule refl)
(step t43 (cl (! (= @p_26 @p_17) :named @p_29)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_29 1 5))
(step t44 (cl @p_28) :rule cong :premises (t42 t43))
(step t45 (cl @p_27 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule implies_neg1)
(anchor :step t46)
(assume t46.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))
(step t46.t0 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :named @p_24) @p_26)) :rule forall_inst :args (@quantifiers_skolemize_3 b a))
(step t46.t1 (cl @p_24 @p_26) :rule or :premises (t46.t0))
(step t46.t2 (cl (not (! (= (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2))))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :named @p_18)) (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule equiv_pos2)
(anchor :step t46.t3 :args ((?x Elem) (?s1 Set) (?s2 Set) (:= (?x Elem) ?x) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t46.t3.t0 (cl (! (= (= (! (member ?x (difference ?s1 ?s2)) :named @p_21) (! (and (member ?x ?s1) (not (member ?x ?s2))) :named @p_22)) (= @p_22 @p_21)) :named @p_23)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_23 1 5))
(step t46.t3 (cl @p_18) :rule bind)
(step t46.t4 (cl (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule resolution :premises (t46.t2 t46.t3 a7))
(step t46.t5 (cl @p_26) :rule resolution :premises (t46.t1 t46.t4))
(step t46 (cl @p_24 @p_26) :rule subproof :discharge (t46.a0))
(step t47 (cl @p_27 @p_26) :rule resolution :premises (t45 t46))
(step t48 (cl @p_27 (not @p_26)) :rule implies_neg2)
(step t49 (cl @p_27 @p_27) :rule resolution :premises (t47 t48))
(step t50 (cl @p_27) :rule contraction :premises (t49))
(step t51 (cl @p_25) :rule resolution :premises (t41 t44 t50))
(step t52 (cl @p_24 @p_17) :rule implies :premises (t51))
(step t53 (cl (not @p_18) (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule equiv_pos2)
(anchor :step t54 :args ((?x Elem) (?s1 Set) (?s2 Set) (:= (?x Elem) ?x) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t54.t0 (cl @p_23) :rule hole :args ("TRUST_THEORY_REWRITE" @p_23 1 5))
(step t54 (cl @p_18) :rule bind)
(step t55 (cl (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule resolution :premises (t53 t54 a7))
(step t56 (cl @p_17) :rule resolution :premises (t52 t55))
(step t57 (cl @p_15) :rule resolution :premises (t12 t40 t56))
(step t58 (cl @p_14) :rule resolution :premises (t10 t57))
(step t59 (cl (not (! (= (! (or (! (and @p_13 @p_10) :named @p_53) (! (not @p_13) :named @p_63) (! (not @p_10) :named @p_65)) :named @p_66) (! (or @p_53 @p_63 @p_9) :named @p_64)) :named @p_67)) (not @p_66) @p_64) :rule equiv_pos2)
(step t60 (cl (= @p_53 @p_53)) :rule refl)
(step t61 (cl (= @p_63 @p_63)) :rule refl)
(step t62 (cl (! (= @p_65 @p_9) :named @p_68)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_68 1 5))
(step t63 (cl @p_67) :rule cong :premises (t60 t61 t62))
(step t64 (cl @p_53 @p_63 @p_65) :rule and_neg)
(step t65 (cl @p_66 (! (not @p_53) :named @p_54)) :rule or_neg :args (0))
(step t66 (cl @p_66 (not @p_63)) :rule or_neg :args (1))
(step t67 (cl @p_66 (not @p_65)) :rule or_neg :args (2))
(step t68 (cl @p_66 @p_66 @p_66) :rule resolution :premises (t64 t65 t66 t67))
(step t69 (cl @p_66) :rule contraction :premises (t68))
(step t70 (cl @p_64) :rule resolution :premises (t59 t63 t69))
(step t71 (cl @p_53 @p_63 @p_9) :rule or :premises (t70))
(step t72 (cl @p_9 @p_53 @p_63) :rule reordering :premises (t71))
(step t73 (cl (! (not (! (= @p_30 @p_53) :named @p_55)) :named @p_62) @p_30 @p_54) :rule equiv_pos1)
(step t74 (cl @p_30 @p_54 @p_62) :rule reordering :premises (t73))
(step t75 (cl @p_32 (! (not @p_30) :named @p_61)) :rule or_neg :args (1))
(step t76 (cl @p_61) :rule resolution :premises (t75 t39))
(step t77 (cl (not (! (= (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (! (= @p_53 @p_30) :named @p_57)) :named @p_58) (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) @p_55) :named @p_56)) :named @p_59)) (not @p_58) @p_56) :rule equiv_pos2)
(step t78 (cl (! (= @p_57 @p_55) :named @p_60)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_60 1 5))
(step t79 (cl @p_59) :rule cong :premises (t42 t78))
(step t80 (cl @p_58 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule implies_neg1)
(anchor :step t81)
(assume t81.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))
(step t81.t0 (cl (or @p_24 @p_57)) :rule forall_inst :args (@quantifiers_skolemize_3 b d))
(step t81.t1 (cl @p_24 @p_57) :rule or :premises (t81.t0))
(step t81.t2 (cl @p_57) :rule resolution :premises (t81.t1 t55))
(step t81 (cl @p_24 @p_57) :rule subproof :discharge (t81.a0))
(step t82 (cl @p_58 @p_57) :rule resolution :premises (t80 t81))
(step t83 (cl @p_58 (not @p_57)) :rule implies_neg2)
(step t84 (cl @p_58 @p_58) :rule resolution :premises (t82 t83))
(step t85 (cl @p_58) :rule contraction :premises (t84))
(step t86 (cl @p_56) :rule resolution :premises (t77 t79 t85))
(step t87 (cl @p_24 @p_55) :rule implies :premises (t86))
(step t88 (cl @p_55) :rule resolution :premises (t87 t55))
(step t89 (cl @p_54) :rule resolution :premises (t74 t76 t88))
(step t90 (cl @p_52 @p_13) :rule and_pos :args (0))
(step t91 (cl @p_13 @p_52) :rule reordering :premises (t90))
(step t92 (cl @p_13) :rule resolution :premises (t91 t57))
(step t93 (cl @p_9) :rule resolution :premises (t72 t89 t92))
(step t94 (cl @p_12) :rule resolution :premises (t8 a8 t58 t93))
(step t95 (cl (not @p_6) (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2)))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :rule equiv_pos2)
(step t96 (cl @p_6) :rule hole :args ("TRUST_THEORY_REWRITE" @p_6 13 6))
(step t97 (cl (forall ((?x Elem) (?s1 Set) (?s2 Set)) (or (not (member ?x ?s1)) (not (subset ?s1 ?s2)) (member ?x ?s2)))) :rule resolution :premises (t95 t96 a0))
(step t98 (cl) :rule resolution :premises (t6 t94 t97))
