unsat
(define-fun @quantifiers_skolemize_3 () Elem (choice ((?x Elem)) (not (or (not (member ?x (intersection a b))) (member ?x (difference a (difference a b)))))))
(define-fun @quantifiers_skolemize_4 () Elem (choice ((?x Elem)) (not (or (not (member ?x (difference a (difference a b)))) (member ?x (intersection a b))))))
(assume a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2))))
(assume a1 (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))))
(assume a2 (forall ((?s1 Set) (?s2 Set)) (=> (forall ((?x Elem)) (=> (member ?x ?s1) (member ?x ?s2))) (subset ?s1 ?s2))))
(assume a3 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (= ?s1 ?s2))))
(assume a4 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (and (subset ?s1 ?s2) (subset ?s2 ?s1)))))
(assume a5 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (union ?s1 ?s2)) (or (member ?x ?s1) (member ?x ?s2)))))
(assume a6 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (intersection ?s1 ?s2)) (and (member ?x ?s1) (member ?x ?s2)))))
(assume a7 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2))))))
(assume a8 (! (not (! (seteq (! (intersection a b) :named @p_3) (! (difference a (! (difference a b) :named @p_1)) :named @p_2)) :named @p_4)) :named @p_5))
(step t0 (cl (! (not (! (= (! (member @quantifiers_skolemize_4 @p_1) :named @p_6) (! (and (! (member @quantifiers_skolemize_4 a) :named @p_8) (! (not (! (member @quantifiers_skolemize_4 b) :named @p_119)) :named @p_120)) :named @p_121)) :named @p_134)) :named @p_140) @p_6 (! (not @p_121) :named @p_131)) :rule equiv_pos1)
(step t1 (cl @p_6 @p_131 @p_140) :rule reordering :premises (t0))
(step t2 (cl (not (! (= (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (! (= @p_121 @p_6) :named @p_136)) :named @p_137) (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) @p_134) :named @p_135)) :named @p_138)) (not @p_137) @p_135) :rule equiv_pos2)
(step t3 (cl (= (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))) :rule refl)
(step t4 (cl (! (= @p_136 @p_134) :named @p_139)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_139 1 5))
(step t5 (cl @p_138) :rule cong :premises (t3 t4))
(step t6 (cl @p_137 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule implies_neg1)
(anchor :step t7)
(assume t7.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))
(step t7.t0 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :named @p_18) @p_136)) :rule forall_inst :args (@quantifiers_skolemize_4 a b))
(step t7.t1 (cl @p_18 @p_136) :rule or :premises (t7.t0))
(step t7.t2 (cl (not (! (= (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2))))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :named @p_12)) (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule equiv_pos2)
(anchor :step t7.t3 :args ((?x Elem) (?s1 Set) (?s2 Set) (:= (?x Elem) ?x) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t7.t3.t0 (cl (! (= (= (! (member ?x (difference ?s1 ?s2)) :named @p_15) (! (and (member ?x ?s1) (not (member ?x ?s2))) :named @p_16)) (= @p_16 @p_15)) :named @p_17)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_17 1 5))
(step t7.t3 (cl @p_12) :rule bind)
(step t7.t4 (cl (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule resolution :premises (t7.t2 t7.t3 a7))
(step t7.t5 (cl @p_136) :rule resolution :premises (t7.t1 t7.t4))
(step t7 (cl @p_18 @p_136) :rule subproof :discharge (t7.a0))
(step t8 (cl @p_137 @p_136) :rule resolution :premises (t6 t7))
(step t9 (cl @p_137 (not @p_136)) :rule implies_neg2)
(step t10 (cl @p_137 @p_137) :rule resolution :premises (t8 t9))
(step t11 (cl @p_137) :rule contraction :premises (t10))
(step t12 (cl @p_135) :rule resolution :premises (t2 t5 t11))
(step t13 (cl @p_18 @p_134) :rule implies :premises (t12))
(step t14 (cl (not @p_12) (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule equiv_pos2)
(anchor :step t15 :args ((?x Elem) (?s1 Set) (?s2 Set) (:= (?x Elem) ?x) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t15.t0 (cl @p_17) :rule hole :args ("TRUST_THEORY_REWRITE" @p_17 1 5))
(step t15 (cl @p_12) :rule bind)
(step t16 (cl (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule resolution :premises (t14 t15 a7))
(step t17 (cl @p_134) :rule resolution :premises (t13 t16))
(step t18 (cl (not (! (= (! (or @p_121 (! (not @p_8) :named @p_127) (! (not @p_120) :named @p_129)) :named @p_130) (! (or @p_121 @p_127 @p_119) :named @p_128)) :named @p_132)) (not @p_130) @p_128) :rule equiv_pos2)
(step t19 (cl (= @p_121 @p_121)) :rule refl)
(step t20 (cl (= @p_127 @p_127)) :rule refl)
(step t21 (cl (! (= @p_129 @p_119) :named @p_133)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_133 1 5))
(step t22 (cl @p_132) :rule cong :premises (t19 t20 t21))
(step t23 (cl @p_121 @p_127 @p_129) :rule and_neg)
(step t24 (cl @p_130 @p_131) :rule or_neg :args (0))
(step t25 (cl @p_130 (not @p_127)) :rule or_neg :args (1))
(step t26 (cl @p_130 (not @p_129)) :rule or_neg :args (2))
(step t27 (cl @p_130 @p_130 @p_130) :rule resolution :premises (t23 t24 t25 t26))
(step t28 (cl @p_130) :rule contraction :premises (t27))
(step t29 (cl @p_128) :rule resolution :premises (t18 t22 t28))
(step t30 (cl @p_121 @p_127 @p_119) :rule or :premises (t29))
(step t31 (cl @p_119 @p_127 @p_121) :rule reordering :premises (t30))
(step t32 (cl (! (and @p_8 @p_119) :named @p_122) @p_127 @p_120) :rule and_neg)
(step t33 (cl (! (not (! (= (! (member @quantifiers_skolemize_4 @p_3) :named @p_24) @p_122) :named @p_124)) :named @p_126) @p_24 (! (not @p_122) :named @p_123)) :rule equiv_pos1)
(step t34 (cl @p_24 @p_123 @p_126) :rule reordering :premises (t33))
(step t35 (cl (! (or (! (not (! (member @quantifiers_skolemize_4 @p_2) :named @p_10)) :named @p_25) @p_24) :named @p_26) (! (not @p_24) :named @p_125)) :rule or_neg :args (1))
(step t36 (cl (not (! (= (! (or (! (not (! (not (forall ((?x Elem)) (or (not (member ?x (difference a (difference a b)))) (member ?x (intersection a b))))) :named @p_28)) :named @p_105) (! (not @p_26) :named @p_27)) :named @p_106) (! (or (forall ((?x Elem)) (or (not (member ?x (difference a (difference a b)))) (member ?x (intersection a b)))) @p_27) :named @p_104)) :named @p_110)) (not @p_106) @p_104) :rule equiv_pos2)
(step t37 (cl (! (= @p_105 (forall ((?x Elem)) (or (not (member ?x (difference a (difference a b)))) (member ?x (intersection a b))))) :named @p_111)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_111 1 5))
(step t38 (cl (= @p_27 @p_27)) :rule refl)
(step t39 (cl @p_110) :rule cong :premises (t37 t38))
(step t40 (cl (! (=> @p_28 @p_27) :named @p_108) @p_28) :rule implies_neg1)
(anchor :step t41)
(assume t41.a0 @p_28)
(step t41.t0 (cl (not (! (= @p_28 @p_27) :named @p_109)) @p_105 @p_27) :rule equiv_pos2)
(anchor :step t41.t1 :args ((:= (?x Elem) @quantifiers_skolemize_4)))
(step t41.t1.t0 (cl (= (or (not (! (member ?x @p_2) :named @p_93)) (! (member ?x @p_3) :named @p_94)) @p_26)) :rule refl)
(step t41.t1 (cl (= (forall ((?x Elem)) (or (not (member ?x (difference a (difference a b)))) (member ?x (intersection a b)))) @p_26)) :rule sko_forall)
(step t41.t2 (cl @p_109) :rule cong :premises (t41.t1))
(step t41.t3 (cl @p_27) :rule resolution :premises (t41.t0 t41.t2 t41.a0))
(step t41 (cl @p_105 @p_27) :rule subproof :discharge (t41.a0))
(step t42 (cl @p_108 @p_27) :rule resolution :premises (t40 t41))
(step t43 (cl @p_108 (! (not @p_27) :named @p_107)) :rule implies_neg2)
(step t44 (cl @p_108 @p_108) :rule resolution :premises (t42 t43))
(step t45 (cl @p_108) :rule contraction :premises (t44))
(step t46 (cl @p_105 @p_27) :rule implies :premises (t45))
(step t47 (cl @p_106 (not @p_105)) :rule or_neg :args (0))
(step t48 (cl @p_106 @p_107) :rule or_neg :args (1))
(step t49 (cl @p_106 @p_106) :rule resolution :premises (t46 t47 t48))
(step t50 (cl @p_106) :rule contraction :premises (t49))
(step t51 (cl @p_104) :rule resolution :premises (t36 t39 t50))
(step t52 (cl (forall ((?x Elem)) (or (not (member ?x (difference a (difference a b)))) (member ?x (intersection a b)))) @p_27) :rule or :premises (t51))
(step t53 (cl (! (not (! (or (! (subset @p_2 @p_3) :named @p_29) @p_28) :named @p_30)) :named @p_103) @p_29 @p_28) :rule or_pos)
(step t54 (cl @p_29 @p_28 @p_103) :rule reordering :premises (t53))
(step t55 (cl (! (and (! (subset @p_3 @p_2) :named @p_40) @p_29) :named @p_98) (not @p_40) (! (not @p_29) :named @p_39)) :rule and_neg)
(step t56 (cl (! (not (! (= @p_4 @p_98) :named @p_100)) :named @p_102) @p_4 (! (not @p_98) :named @p_99)) :rule equiv_pos1)
(step t57 (cl @p_4 @p_99 @p_102) :rule reordering :premises (t56))
(step t58 (cl (or (! (not (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (and (subset ?s1 ?s2) (subset ?s2 ?s1))))) :named @p_101) @p_100)) :rule forall_inst :args (@p_3 @p_2))
(step t59 (cl @p_101 @p_100) :rule or :premises (t58))
(step t60 (cl @p_100) :rule resolution :premises (t59 a4))
(step t61 (cl @p_99) :rule resolution :premises (t57 a8 t60))
(step t62 (cl (! (not (! (or @p_40 (! (not (forall ((?x Elem)) (or (not (member ?x (intersection a b))) (member ?x (difference a (difference a b)))))) :named @p_41)) :named @p_42)) :named @p_97) @p_40 @p_41) :rule or_pos)
(step t63 (cl @p_40 @p_41 @p_97) :rule reordering :premises (t62))
(step t64 (cl (not (! (= (! (or (! (not @p_41) :named @p_88) (! (not (! (or (! (not (! (member @quantifiers_skolemize_3 @p_3) :named @p_44)) :named @p_45) (! (member @quantifiers_skolemize_3 @p_2) :named @p_43)) :named @p_46)) :named @p_50)) :named @p_89) (! (or (forall ((?x Elem)) (or (not (member ?x (intersection a b))) (member ?x (difference a (difference a b))))) @p_50) :named @p_87)) :named @p_95)) (not @p_89) @p_87) :rule equiv_pos2)
(step t65 (cl (! (= @p_88 (forall ((?x Elem)) (or (not (member ?x (intersection a b))) (member ?x (difference a (difference a b)))))) :named @p_96)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_96 1 5))
(step t66 (cl (= @p_50 @p_50)) :rule refl)
(step t67 (cl @p_95) :rule cong :premises (t65 t66))
(step t68 (cl (! (=> @p_41 @p_50) :named @p_91) @p_41) :rule implies_neg1)
(anchor :step t69)
(assume t69.a0 @p_41)
(step t69.t0 (cl (not (! (= @p_41 @p_50) :named @p_92)) @p_88 @p_50) :rule equiv_pos2)
(anchor :step t69.t1 :args ((:= (?x Elem) @quantifiers_skolemize_3)))
(step t69.t1.t0 (cl (= (or (not @p_94) @p_93) @p_46)) :rule refl)
(step t69.t1 (cl (= (forall ((?x Elem)) (or (not (member ?x (intersection a b))) (member ?x (difference a (difference a b))))) @p_46)) :rule sko_forall)
(step t69.t2 (cl @p_92) :rule cong :premises (t69.t1))
(step t69.t3 (cl @p_50) :rule resolution :premises (t69.t0 t69.t2 t69.a0))
(step t69 (cl @p_88 @p_50) :rule subproof :discharge (t69.a0))
(step t70 (cl @p_91 @p_50) :rule resolution :premises (t68 t69))
(step t71 (cl @p_91 (! (not @p_50) :named @p_90)) :rule implies_neg2)
(step t72 (cl @p_91 @p_91) :rule resolution :premises (t70 t71))
(step t73 (cl @p_91) :rule contraction :premises (t72))
(step t74 (cl @p_88 @p_50) :rule implies :premises (t73))
(step t75 (cl @p_89 (not @p_88)) :rule or_neg :args (0))
(step t76 (cl @p_89 @p_90) :rule or_neg :args (1))
(step t77 (cl @p_89 @p_89) :rule resolution :premises (t74 t75 t76))
(step t78 (cl @p_89) :rule contraction :premises (t77))
(step t79 (cl @p_87) :rule resolution :premises (t64 t67 t78))
(step t80 (cl (forall ((?x Elem)) (or (not (member ?x (intersection a b))) (member ?x (difference a (difference a b))))) @p_50) :rule or :premises (t79))
(step t81 (cl (! (not (! (= (! (member @quantifiers_skolemize_3 @p_1) :named @p_59) (! (and (! (member @quantifiers_skolemize_3 a) :named @p_54) (! (not (! (member @quantifiers_skolemize_3 b) :named @p_53)) :named @p_77)) :named @p_78)) :named @p_80)) :named @p_86) (! (not @p_59) :named @p_60) @p_78) :rule equiv_pos2)
(step t82 (cl @p_60 @p_78 @p_86) :rule reordering :premises (t81))
(step t83 (cl (not (! (= (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (! (= @p_78 @p_59) :named @p_82)) :named @p_83) (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) @p_80) :named @p_81)) :named @p_84)) (not @p_83) @p_81) :rule equiv_pos2)
(step t84 (cl (! (= @p_82 @p_80) :named @p_85)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_85 1 5))
(step t85 (cl @p_84) :rule cong :premises (t3 t84))
(step t86 (cl @p_83 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule implies_neg1)
(anchor :step t87)
(assume t87.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))
(step t87.t0 (cl (or @p_18 @p_82)) :rule forall_inst :args (@quantifiers_skolemize_3 a b))
(step t87.t1 (cl @p_18 @p_82) :rule or :premises (t87.t0))
(step t87.t2 (cl @p_82) :rule resolution :premises (t87.t1 t16))
(step t87 (cl @p_18 @p_82) :rule subproof :discharge (t87.a0))
(step t88 (cl @p_83 @p_82) :rule resolution :premises (t86 t87))
(step t89 (cl @p_83 (not @p_82)) :rule implies_neg2)
(step t90 (cl @p_83 @p_83) :rule resolution :premises (t88 t89))
(step t91 (cl @p_83) :rule contraction :premises (t90))
(step t92 (cl @p_81) :rule resolution :premises (t83 t85 t91))
(step t93 (cl @p_18 @p_80) :rule implies :premises (t92))
(step t94 (cl @p_80) :rule resolution :premises (t93 t16))
(step t95 (cl (! (not @p_78) :named @p_79) @p_77) :rule and_pos :args (1))
(step t96 (cl @p_77 @p_79) :rule reordering :premises (t95))
(step t97 (cl (not (! (= (! (or (! (and @p_54 @p_60) :named @p_61) (! (not @p_54) :named @p_71) (! (not @p_60) :named @p_73)) :named @p_74) (! (or @p_61 @p_71 @p_59) :named @p_72)) :named @p_75)) (not @p_74) @p_72) :rule equiv_pos2)
(step t98 (cl (= @p_61 @p_61)) :rule refl)
(step t99 (cl (= @p_71 @p_71)) :rule refl)
(step t100 (cl (! (= @p_73 @p_59) :named @p_76)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_76 1 5))
(step t101 (cl @p_75) :rule cong :premises (t98 t99 t100))
(step t102 (cl @p_61 @p_71 @p_73) :rule and_neg)
(step t103 (cl @p_74 (! (not @p_61) :named @p_68)) :rule or_neg :args (0))
(step t104 (cl @p_74 (not @p_71)) :rule or_neg :args (1))
(step t105 (cl @p_74 (not @p_73)) :rule or_neg :args (2))
(step t106 (cl @p_74 @p_74 @p_74) :rule resolution :premises (t102 t103 t104 t105))
(step t107 (cl @p_74) :rule contraction :premises (t106))
(step t108 (cl @p_72) :rule resolution :premises (t97 t101 t107))
(step t109 (cl @p_61 @p_71 @p_59) :rule or :premises (t108))
(step t110 (cl @p_59 @p_61 @p_71) :rule reordering :premises (t109))
(step t111 (cl (! (not (! (and @p_54 @p_53) :named @p_55)) :named @p_70) @p_53) :rule and_pos :args (1))
(step t112 (cl @p_53 @p_70) :rule reordering :premises (t111))
(step t113 (cl @p_70 @p_54) :rule and_pos :args (0))
(step t114 (cl @p_54 @p_70) :rule reordering :premises (t113))
(step t115 (cl (! (not (! (= @p_43 @p_61) :named @p_62)) :named @p_69) @p_43 @p_68) :rule equiv_pos1)
(step t116 (cl @p_43 @p_68 @p_69) :rule reordering :premises (t115))
(step t117 (cl (not (! (= (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (! (= @p_61 @p_43) :named @p_64)) :named @p_65) (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) @p_62) :named @p_63)) :named @p_66)) (not @p_65) @p_63) :rule equiv_pos2)
(step t118 (cl (! (= @p_64 @p_62) :named @p_67)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_67 1 5))
(step t119 (cl @p_66) :rule cong :premises (t3 t118))
(step t120 (cl @p_65 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule implies_neg1)
(anchor :step t121)
(assume t121.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))
(step t121.t0 (cl (or @p_18 @p_64)) :rule forall_inst :args (@quantifiers_skolemize_3 a @p_1))
(step t121.t1 (cl @p_18 @p_64) :rule or :premises (t121.t0))
(step t121.t2 (cl @p_64) :rule resolution :premises (t121.t1 t16))
(step t121 (cl @p_18 @p_64) :rule subproof :discharge (t121.a0))
(step t122 (cl @p_65 @p_64) :rule resolution :premises (t120 t121))
(step t123 (cl @p_65 (not @p_64)) :rule implies_neg2)
(step t124 (cl @p_65 @p_65) :rule resolution :premises (t122 t123))
(step t125 (cl @p_65) :rule contraction :premises (t124))
(step t126 (cl @p_63) :rule resolution :premises (t117 t119 t125))
(step t127 (cl @p_18 @p_62) :rule implies :premises (t126))
(step t128 (cl @p_62) :rule resolution :premises (t127 t16))
(step t129 (cl (! (not (! (= @p_44 @p_55) :named @p_56)) :named @p_58) @p_45 @p_55) :rule equiv_pos2)
(step t130 (cl @p_45 @p_55 @p_58) :rule reordering :premises (t129))
(step t131 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (intersection ?s1 ?s2)) (and (member ?x ?s1) (member ?x ?s2))))) :named @p_57) @p_56)) :rule forall_inst :args (@quantifiers_skolemize_3 a b))
(step t132 (cl @p_57 @p_56) :rule or :premises (t131))
(step t133 (cl @p_56) :rule resolution :premises (t132 a6))
(step t134 (cl @p_46 (not @p_43)) :rule or_neg :args (1))
(step t135 (cl (not (! (= (! (or @p_46 (! (not @p_45) :named @p_48)) :named @p_49) (! (or @p_46 @p_44) :named @p_47)) :named @p_51)) (not @p_49) @p_47) :rule equiv_pos2)
(step t136 (cl (= @p_46 @p_46)) :rule refl)
(step t137 (cl (! (= @p_48 @p_44) :named @p_52)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_52 1 5))
(step t138 (cl @p_51) :rule cong :premises (t136 t137))
(step t139 (cl @p_46 @p_48) :rule or_neg :args (0))
(step t140 (cl @p_49 @p_50) :rule or_neg :args (0))
(step t141 (cl @p_49 (not @p_48)) :rule or_neg :args (1))
(step t142 (cl @p_49 @p_49) :rule resolution :premises (t139 t140 t141))
(step t143 (cl @p_49) :rule contraction :premises (t142))
(step t144 (cl @p_47) :rule resolution :premises (t135 t138 t143))
(step t145 (cl @p_46 @p_44) :rule or :premises (t144))
(step t146 (cl @p_44 @p_46) :rule reordering :premises (t145))
(step t147 (cl @p_46) :rule resolution :premises (t82 t94 t96 t110 t112 t114 t116 t128 t130 t133 t134 t146))
(step t148 (cl (forall ((?x Elem)) (or (not (member ?x (intersection a b))) (member ?x (difference a (difference a b)))))) :rule resolution :premises (t80 t147))
(step t149 (cl (or (! (not (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_38) @p_42)) :rule forall_inst :args (@p_3 @p_2))
(step t150 (cl @p_38 @p_42) :rule or :premises (t149))
(step t151 (cl (not (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_31)) (not (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule equiv_pos2)
(anchor :step t152 :args ((?s1 Set) (?s2 Set) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t152.t0 (cl (= (! (not (subset ?s1 ?s2)) :named @p_34) @p_34)) :rule refl)
(step t152.t1 (cl (! (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) (! (not (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2)))))) :named @p_35)) :named @p_37)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_37 13 6))
(step t152.t2 (cl (! (= (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2))))) (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_36)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_36 13 6))
(step t152.t3 (cl (= @p_35 (! (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_33))) :rule cong :premises (t152.t2))
(step t152.t4 (cl (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) @p_33)) :rule trans :premises (t152.t1 t152.t3))
(step t152.t5 (cl (= (=> @p_34 (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))) (=> @p_34 @p_33))) :rule cong :premises (t152.t0 t152.t4))
(step t152 (cl (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))))) :rule bind)
(step t153 (cl (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_32)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_32 13 6))
(step t154 (cl @p_31) :rule trans :premises (t152 t153))
(step t155 (cl (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule resolution :premises (t151 t154 a1))
(step t156 (cl @p_42) :rule resolution :premises (t150 t155))
(step t157 (cl @p_40) :rule resolution :premises (t63 t148 t156))
(step t158 (cl @p_39) :rule resolution :premises (t55 t61 t157))
(step t159 (cl (or @p_38 @p_30)) :rule forall_inst :args (@p_2 @p_3))
(step t160 (cl @p_38 @p_30) :rule or :premises (t159))
(step t161 (cl @p_30) :rule resolution :premises (t160 t155))
(step t162 (cl @p_28) :rule resolution :premises (t54 t158 t161))
(step t163 (cl @p_27) :rule resolution :premises (t52 t162))
(step t164 (cl @p_125) :rule resolution :premises (t35 t163))
(step t165 (cl (or @p_57 @p_124)) :rule forall_inst :args (@quantifiers_skolemize_4 a b))
(step t166 (cl @p_57 @p_124) :rule or :premises (t165))
(step t167 (cl @p_124) :rule resolution :premises (t166 a6))
(step t168 (cl @p_123) :rule resolution :premises (t34 t164 t167))
(step t169 (cl (! (not (! (and @p_8 (! (not @p_6) :named @p_7)) :named @p_9)) :named @p_118) @p_8) :rule and_pos :args (0))
(step t170 (cl @p_8 @p_118) :rule reordering :premises (t169))
(step t171 (cl (! (not (! (= @p_10 @p_9) :named @p_11)) :named @p_117) @p_25 @p_9) :rule equiv_pos2)
(step t172 (cl @p_25 @p_9 @p_117) :rule reordering :premises (t171))
(step t173 (cl (not (! (= (! (or @p_26 (! (not @p_25) :named @p_113)) :named @p_114) (! (or @p_26 @p_10) :named @p_112)) :named @p_115)) (not @p_114) @p_112) :rule equiv_pos2)
(step t174 (cl (= @p_26 @p_26)) :rule refl)
(step t175 (cl (! (= @p_113 @p_10) :named @p_116)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_116 1 5))
(step t176 (cl @p_115) :rule cong :premises (t174 t175))
(step t177 (cl @p_26 @p_113) :rule or_neg :args (0))
(step t178 (cl @p_114 @p_27) :rule or_neg :args (0))
(step t179 (cl @p_114 (not @p_113)) :rule or_neg :args (1))
(step t180 (cl @p_114 @p_114) :rule resolution :premises (t177 t178 t179))
(step t181 (cl @p_114) :rule contraction :premises (t180))
(step t182 (cl @p_112) :rule resolution :premises (t173 t176 t181))
(step t183 (cl @p_26 @p_10) :rule or :premises (t182))
(step t184 (cl @p_10 @p_26) :rule reordering :premises (t183))
(step t185 (cl @p_10) :rule resolution :premises (t184 t163))
(step t186 (cl (not (! (= (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (! (= @p_9 @p_10) :named @p_20)) :named @p_21) (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) @p_11) :named @p_19)) :named @p_22)) (not @p_21) @p_19) :rule equiv_pos2)
(step t187 (cl (! (= @p_20 @p_11) :named @p_23)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_23 1 5))
(step t188 (cl @p_22) :rule cong :premises (t3 t187))
(step t189 (cl @p_21 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule implies_neg1)
(anchor :step t190)
(assume t190.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))
(step t190.t0 (cl (or @p_18 @p_20)) :rule forall_inst :args (@quantifiers_skolemize_4 a @p_1))
(step t190.t1 (cl @p_18 @p_20) :rule or :premises (t190.t0))
(step t190.t2 (cl @p_20) :rule resolution :premises (t190.t1 t16))
(step t190 (cl @p_18 @p_20) :rule subproof :discharge (t190.a0))
(step t191 (cl @p_21 @p_20) :rule resolution :premises (t189 t190))
(step t192 (cl @p_21 (not @p_20)) :rule implies_neg2)
(step t193 (cl @p_21 @p_21) :rule resolution :premises (t191 t192))
(step t194 (cl @p_21) :rule contraction :premises (t193))
(step t195 (cl @p_19) :rule resolution :premises (t186 t188 t194))
(step t196 (cl @p_18 @p_11) :rule implies :premises (t195))
(step t197 (cl @p_11) :rule resolution :premises (t196 t16))
(step t198 (cl @p_9) :rule resolution :premises (t172 t185 t197))
(step t199 (cl @p_8) :rule resolution :premises (t170 t198))
(step t200 (cl @p_120) :rule resolution :premises (t32 t168 t199))
(step t201 (cl @p_121) :rule resolution :premises (t31 t200 t199))
(step t202 (cl @p_118 @p_7) :rule and_pos :args (1))
(step t203 (cl @p_7 @p_118) :rule reordering :premises (t202))
(step t204 (cl @p_7) :rule resolution :premises (t203 t198))
(step t205 (cl) :rule resolution :premises (t1 t17 t201 t204))
