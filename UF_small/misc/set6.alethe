unsat
(define-fun @quantifiers_skolemize_3 () Elem (choice ((?x Elem)) (not (or (not (member ?x (union (difference c a) (difference c b)))) (member ?x (difference c (intersection a b)))))))
(define-fun @quantifiers_skolemize_4 () Elem (choice ((?x Elem)) (not (or (not (member ?x (difference c (intersection a b)))) (member ?x (union (difference c a) (difference c b)))))))
(assume a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2))))
(assume a1 (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))))
(assume a2 (forall ((?s1 Set) (?s2 Set)) (=> (forall ((?x Elem)) (=> (member ?x ?s1) (member ?x ?s2))) (subset ?s1 ?s2))))
(assume a3 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (= ?s1 ?s2))))
(assume a4 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (and (subset ?s1 ?s2) (subset ?s2 ?s1)))))
(assume a5 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (union ?s1 ?s2)) (or (member ?x ?s1) (member ?x ?s2)))))
(assume a6 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (intersection ?s1 ?s2)) (and (member ?x ?s1) (member ?x ?s2)))))
(assume a7 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2))))))
(assume a8 (! (not (! (seteq (! (union (! (difference c a) :named @p_4) (! (difference c b) :named @p_3)) :named @p_5) (! (difference c (! (intersection a b) :named @p_1)) :named @p_2)) :named @p_6)) :named @p_7))
(step t0 (cl (! (and (! (member @quantifiers_skolemize_4 a) :named @p_9) (! (member @quantifiers_skolemize_4 b) :named @p_8)) :named @p_10) (! (not @p_9) :named @p_172) (! (not @p_8) :named @p_147)) :rule and_neg)
(step t1 (cl @p_147 @p_172 @p_10) :rule reordering :premises (t0))
(step t2 (cl (not (! (= (! (or (! (and (! (member @quantifiers_skolemize_4 c) :named @p_16) @p_172) :named @p_173) (! (not @p_16) :named @p_165) (! (not @p_172) :named @p_184)) :named @p_185) (! (or @p_173 @p_165 @p_9) :named @p_183)) :named @p_186)) (not @p_185) @p_183) :rule equiv_pos2)
(step t3 (cl (= @p_173 @p_173)) :rule refl)
(step t4 (cl (= @p_165 @p_165)) :rule refl)
(step t5 (cl (! (= @p_184 @p_9) :named @p_187)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_187 1 5))
(step t6 (cl @p_186) :rule cong :premises (t3 t4 t5))
(step t7 (cl @p_173 @p_165 @p_184) :rule and_neg)
(step t8 (cl @p_185 (! (not @p_173) :named @p_174)) :rule or_neg :args (0))
(step t9 (cl @p_185 (! (not @p_165) :named @p_169)) :rule or_neg :args (1))
(step t10 (cl @p_185 (not @p_184)) :rule or_neg :args (2))
(step t11 (cl @p_185 @p_185 @p_185) :rule resolution :premises (t7 t8 t9 t10))
(step t12 (cl @p_185) :rule contraction :premises (t11))
(step t13 (cl @p_183) :rule resolution :premises (t2 t6 t12))
(step t14 (cl @p_173 @p_165 @p_9) :rule or :premises (t13))
(step t15 (cl @p_165 @p_9 @p_173) :rule reordering :premises (t14))
(step t16 (cl (! (not (! (and @p_16 (! (not (! (member @quantifiers_skolemize_4 @p_1) :named @p_12)) :named @p_15)) :named @p_17)) :named @p_145) @p_16) :rule and_pos :args (0))
(step t17 (cl @p_16 @p_145) :rule reordering :premises (t16))
(step t18 (cl (! (not (! (= (! (member @quantifiers_skolemize_4 @p_2) :named @p_18) @p_17) :named @p_19)) :named @p_144) (! (not @p_18) :named @p_33) @p_17) :rule equiv_pos2)
(step t19 (cl @p_33 @p_17 @p_144) :rule reordering :premises (t18))
(step t20 (cl (not (! (= (! (or (! (or @p_33 (! (member @quantifiers_skolemize_4 @p_5) :named @p_32)) :named @p_34) (! (not @p_33) :named @p_140)) :named @p_141) (! (or @p_34 @p_18) :named @p_139)) :named @p_142)) (not @p_141) @p_139) :rule equiv_pos2)
(step t21 (cl (= @p_34 @p_34)) :rule refl)
(step t22 (cl (! (= @p_140 @p_18) :named @p_143)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_143 1 5))
(step t23 (cl @p_142) :rule cong :premises (t21 t22))
(step t24 (cl @p_34 @p_140) :rule or_neg :args (0))
(step t25 (cl @p_141 (! (not @p_34) :named @p_35)) :rule or_neg :args (0))
(step t26 (cl @p_141 (not @p_140)) :rule or_neg :args (1))
(step t27 (cl @p_141 @p_141) :rule resolution :premises (t24 t25 t26))
(step t28 (cl @p_141) :rule contraction :premises (t27))
(step t29 (cl @p_139) :rule resolution :premises (t20 t23 t28))
(step t30 (cl @p_34 @p_18) :rule or :premises (t29))
(step t31 (cl @p_18 @p_34) :rule reordering :premises (t30))
(step t32 (cl (not (! (= (! (or (! (not (! (not (forall ((?x Elem)) (or (not (member ?x (difference c (intersection a b)))) (member ?x (union (difference c a) (difference c b)))))) :named @p_36)) :named @p_132) @p_35) :named @p_133) (! (or (forall ((?x Elem)) (or (not (member ?x (difference c (intersection a b)))) (member ?x (union (difference c a) (difference c b))))) @p_35) :named @p_131)) :named @p_137)) (not @p_133) @p_131) :rule equiv_pos2)
(step t33 (cl (! (= @p_132 (forall ((?x Elem)) (or (not (member ?x (difference c (intersection a b)))) (member ?x (union (difference c a) (difference c b)))))) :named @p_138)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_138 1 5))
(step t34 (cl (= @p_35 @p_35)) :rule refl)
(step t35 (cl @p_137) :rule cong :premises (t33 t34))
(step t36 (cl (! (=> @p_36 @p_35) :named @p_135) @p_36) :rule implies_neg1)
(anchor :step t37)
(assume t37.a0 @p_36)
(step t37.t0 (cl (not (! (= @p_36 @p_35) :named @p_136)) @p_132 @p_35) :rule equiv_pos2)
(anchor :step t37.t1 :args ((:= (?x Elem) @quantifiers_skolemize_4)))
(step t37.t1.t0 (cl (= (or (not (! (member ?x @p_2) :named @p_120)) (! (member ?x @p_5) :named @p_121)) @p_34)) :rule refl)
(step t37.t1 (cl (= (forall ((?x Elem)) (or (not (member ?x (difference c (intersection a b)))) (member ?x (union (difference c a) (difference c b))))) @p_34)) :rule sko_forall)
(step t37.t2 (cl @p_136) :rule cong :premises (t37.t1))
(step t37.t3 (cl @p_35) :rule resolution :premises (t37.t0 t37.t2 t37.a0))
(step t37 (cl @p_132 @p_35) :rule subproof :discharge (t37.a0))
(step t38 (cl @p_135 @p_35) :rule resolution :premises (t36 t37))
(step t39 (cl @p_135 (! (not @p_35) :named @p_134)) :rule implies_neg2)
(step t40 (cl @p_135 @p_135) :rule resolution :premises (t38 t39))
(step t41 (cl @p_135) :rule contraction :premises (t40))
(step t42 (cl @p_132 @p_35) :rule implies :premises (t41))
(step t43 (cl @p_133 (not @p_132)) :rule or_neg :args (0))
(step t44 (cl @p_133 @p_134) :rule or_neg :args (1))
(step t45 (cl @p_133 @p_133) :rule resolution :premises (t42 t43 t44))
(step t46 (cl @p_133) :rule contraction :premises (t45))
(step t47 (cl @p_131) :rule resolution :premises (t32 t35 t46))
(step t48 (cl (forall ((?x Elem)) (or (not (member ?x (difference c (intersection a b)))) (member ?x (union (difference c a) (difference c b))))) @p_35) :rule or :premises (t47))
(step t49 (cl (! (not (! (or (! (subset @p_2 @p_5) :named @p_37) @p_36) :named @p_38)) :named @p_130) @p_37 @p_36) :rule or_pos)
(step t50 (cl @p_37 @p_36 @p_130) :rule reordering :premises (t49))
(step t51 (cl (! (and (! (subset @p_5 @p_2) :named @p_48) @p_37) :named @p_125) (not @p_48) (! (not @p_37) :named @p_47)) :rule and_neg)
(step t52 (cl (! (not (! (= @p_6 @p_125) :named @p_127)) :named @p_129) @p_6 (! (not @p_125) :named @p_126)) :rule equiv_pos1)
(step t53 (cl @p_6 @p_126 @p_129) :rule reordering :premises (t52))
(step t54 (cl (or (! (not (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (and (subset ?s1 ?s2) (subset ?s2 ?s1))))) :named @p_128) @p_127)) :rule forall_inst :args (@p_5 @p_2))
(step t55 (cl @p_128 @p_127) :rule or :premises (t54))
(step t56 (cl @p_127) :rule resolution :premises (t55 a4))
(step t57 (cl @p_126) :rule resolution :premises (t53 a8 t56))
(step t58 (cl (! (not (! (or @p_48 (! (not (forall ((?x Elem)) (or (not (member ?x (union (difference c a) (difference c b)))) (member ?x (difference c (intersection a b)))))) :named @p_49)) :named @p_50)) :named @p_124) @p_48 @p_49) :rule or_pos)
(step t59 (cl @p_48 @p_49 @p_124) :rule reordering :premises (t58))
(step t60 (cl (not (! (= (! (or (! (not @p_49) :named @p_115) (! (not (! (or (! (not (! (member @quantifiers_skolemize_3 @p_5) :named @p_52)) :named @p_53) (! (member @quantifiers_skolemize_3 @p_2) :named @p_51)) :named @p_54)) :named @p_58)) :named @p_116) (! (or (forall ((?x Elem)) (or (not (member ?x (union (difference c a) (difference c b)))) (member ?x (difference c (intersection a b))))) @p_58) :named @p_114)) :named @p_122)) (not @p_116) @p_114) :rule equiv_pos2)
(step t61 (cl (! (= @p_115 (forall ((?x Elem)) (or (not (member ?x (union (difference c a) (difference c b)))) (member ?x (difference c (intersection a b)))))) :named @p_123)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_123 1 5))
(step t62 (cl (= @p_58 @p_58)) :rule refl)
(step t63 (cl @p_122) :rule cong :premises (t61 t62))
(step t64 (cl (! (=> @p_49 @p_58) :named @p_118) @p_49) :rule implies_neg1)
(anchor :step t65)
(assume t65.a0 @p_49)
(step t65.t0 (cl (not (! (= @p_49 @p_58) :named @p_119)) @p_115 @p_58) :rule equiv_pos2)
(anchor :step t65.t1 :args ((:= (?x Elem) @quantifiers_skolemize_3)))
(step t65.t1.t0 (cl (= (or (not @p_121) @p_120) @p_54)) :rule refl)
(step t65.t1 (cl (= (forall ((?x Elem)) (or (not (member ?x (union (difference c a) (difference c b)))) (member ?x (difference c (intersection a b))))) @p_54)) :rule sko_forall)
(step t65.t2 (cl @p_119) :rule cong :premises (t65.t1))
(step t65.t3 (cl @p_58) :rule resolution :premises (t65.t0 t65.t2 t65.a0))
(step t65 (cl @p_115 @p_58) :rule subproof :discharge (t65.a0))
(step t66 (cl @p_118 @p_58) :rule resolution :premises (t64 t65))
(step t67 (cl @p_118 (! (not @p_58) :named @p_117)) :rule implies_neg2)
(step t68 (cl @p_118 @p_118) :rule resolution :premises (t66 t67))
(step t69 (cl @p_118) :rule contraction :premises (t68))
(step t70 (cl @p_115 @p_58) :rule implies :premises (t69))
(step t71 (cl @p_116 (not @p_115)) :rule or_neg :args (0))
(step t72 (cl @p_116 @p_117) :rule or_neg :args (1))
(step t73 (cl @p_116 @p_116) :rule resolution :premises (t70 t71 t72))
(step t74 (cl @p_116) :rule contraction :premises (t73))
(step t75 (cl @p_114) :rule resolution :premises (t60 t63 t74))
(step t76 (cl (forall ((?x Elem)) (or (not (member ?x (union (difference c a) (difference c b)))) (member ?x (difference c (intersection a b))))) @p_58) :rule or :premises (t75))
(step t77 (cl (! (not (! (= (! (member @quantifiers_skolemize_3 @p_1) :named @p_67) (! (and (! (member @quantifiers_skolemize_3 a) :named @p_79) (! (member @quantifiers_skolemize_3 b) :named @p_89)) :named @p_90)) :named @p_92)) :named @p_93) (! (not @p_67) :named @p_68) @p_90) :rule equiv_pos2)
(step t78 (cl @p_68 @p_90 @p_93) :rule reordering :premises (t77))
(step t79 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (intersection ?s1 ?s2)) (and (member ?x ?s1) (member ?x ?s2))))) :named @p_14) @p_92)) :rule forall_inst :args (@quantifiers_skolemize_3 a b))
(step t80 (cl @p_14 @p_92) :rule or :premises (t79))
(step t81 (cl @p_92) :rule resolution :premises (t80 a6))
(step t82 (cl (! (not @p_90) :named @p_91) @p_89) :rule and_pos :args (1))
(step t83 (cl @p_89 @p_91) :rule reordering :premises (t82))
(step t84 (cl (not (! (= (! (or (! (and (! (member @quantifiers_skolemize_3 c) :named @p_69) @p_68) :named @p_70) (! (not @p_69) :named @p_83) (! (not @p_68) :named @p_85)) :named @p_86) (! (or @p_70 @p_83 @p_67) :named @p_84)) :named @p_87)) (not @p_86) @p_84) :rule equiv_pos2)
(step t85 (cl (= @p_70 @p_70)) :rule refl)
(step t86 (cl (= @p_83 @p_83)) :rule refl)
(step t87 (cl (! (= @p_85 @p_67) :named @p_88)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_88 1 5))
(step t88 (cl @p_87) :rule cong :premises (t85 t86 t87))
(step t89 (cl @p_70 @p_83 @p_85) :rule and_neg)
(step t90 (cl @p_86 (! (not @p_70) :named @p_77)) :rule or_neg :args (0))
(step t91 (cl @p_86 (not @p_83)) :rule or_neg :args (1))
(step t92 (cl @p_86 (not @p_85)) :rule or_neg :args (2))
(step t93 (cl @p_86 @p_86 @p_86) :rule resolution :premises (t89 t90 t91 t92))
(step t94 (cl @p_86) :rule contraction :premises (t93))
(step t95 (cl @p_84) :rule resolution :premises (t84 t88 t94))
(step t96 (cl @p_70 @p_83 @p_67) :rule or :premises (t95))
(step t97 (cl @p_67 @p_70 @p_83) :rule reordering :premises (t96))
(step t98 (cl (! (not (! (and @p_69 (! (not @p_89) :named @p_103)) :named @p_104)) :named @p_113) @p_103) :rule and_pos :args (1))
(step t99 (cl @p_103 @p_113) :rule reordering :premises (t98))
(step t100 (cl @p_113 @p_69) :rule and_pos :args (0))
(step t101 (cl @p_69 @p_113) :rule reordering :premises (t100))
(step t102 (cl (! (not (! (= (! (member @quantifiers_skolemize_3 @p_3) :named @p_61) @p_104) :named @p_105)) :named @p_112) (! (not @p_61) :named @p_111) @p_104) :rule equiv_pos2)
(step t103 (cl @p_111 @p_104 @p_112) :rule reordering :premises (t102))
(step t104 (cl (not (! (= (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (! (= @p_104 @p_61) :named @p_107)) :named @p_108) (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) @p_105) :named @p_106)) :named @p_109)) (not @p_108) @p_106) :rule equiv_pos2)
(step t105 (cl (= (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))) :rule refl)
(step t106 (cl (! (= @p_107 @p_105) :named @p_110)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_110 1 5))
(step t107 (cl @p_109) :rule cong :premises (t105 t106))
(step t108 (cl @p_108 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule implies_neg1)
(anchor :step t109)
(assume t109.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))
(step t109.t0 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :named @p_26) @p_107)) :rule forall_inst :args (@quantifiers_skolemize_3 c b))
(step t109.t1 (cl @p_26 @p_107) :rule or :premises (t109.t0))
(step t109.t2 (cl (not (! (= (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2))))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :named @p_20)) (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule equiv_pos2)
(anchor :step t109.t3 :args ((?x Elem) (?s1 Set) (?s2 Set) (:= (?x Elem) ?x) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t109.t3.t0 (cl (! (= (= (! (member ?x (difference ?s1 ?s2)) :named @p_23) (! (and (member ?x ?s1) (not (member ?x ?s2))) :named @p_24)) (= @p_24 @p_23)) :named @p_25)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_25 1 5))
(step t109.t3 (cl @p_20) :rule bind)
(step t109.t4 (cl (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule resolution :premises (t109.t2 t109.t3 a7))
(step t109.t5 (cl @p_107) :rule resolution :premises (t109.t1 t109.t4))
(step t109 (cl @p_26 @p_107) :rule subproof :discharge (t109.a0))
(step t110 (cl @p_108 @p_107) :rule resolution :premises (t108 t109))
(step t111 (cl @p_108 (not @p_107)) :rule implies_neg2)
(step t112 (cl @p_108 @p_108) :rule resolution :premises (t110 t111))
(step t113 (cl @p_108) :rule contraction :premises (t112))
(step t114 (cl @p_106) :rule resolution :premises (t104 t107 t113))
(step t115 (cl @p_26 @p_105) :rule implies :premises (t114))
(step t116 (cl (not @p_20) (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule equiv_pos2)
(anchor :step t117 :args ((?x Elem) (?s1 Set) (?s2 Set) (:= (?x Elem) ?x) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t117.t0 (cl @p_25) :rule hole :args ("TRUST_THEORY_REWRITE" @p_25 1 5))
(step t117 (cl @p_20) :rule bind)
(step t118 (cl (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule resolution :premises (t116 t117 a7))
(step t119 (cl @p_105) :rule resolution :premises (t115 t118))
(step t120 (cl (! (not (! (or (! (member @quantifiers_skolemize_3 @p_4) :named @p_62) @p_61) :named @p_63)) :named @p_102) @p_62 @p_61) :rule or_pos)
(step t121 (cl @p_62 @p_61 @p_102) :rule reordering :premises (t120))
(step t122 (cl (! (not (! (= @p_62 (! (and @p_69 (! (not @p_79) :named @p_80)) :named @p_81)) :named @p_94)) :named @p_101) (! (not @p_62) :named @p_100) @p_81) :rule equiv_pos2)
(step t123 (cl @p_100 @p_81 @p_101) :rule reordering :premises (t122))
(step t124 (cl (not (! (= (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (! (= @p_81 @p_62) :named @p_96)) :named @p_97) (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) @p_94) :named @p_95)) :named @p_98)) (not @p_97) @p_95) :rule equiv_pos2)
(step t125 (cl (! (= @p_96 @p_94) :named @p_99)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_99 1 5))
(step t126 (cl @p_98) :rule cong :premises (t105 t125))
(step t127 (cl @p_97 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule implies_neg1)
(anchor :step t128)
(assume t128.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))
(step t128.t0 (cl (or @p_26 @p_96)) :rule forall_inst :args (@quantifiers_skolemize_3 c a))
(step t128.t1 (cl @p_26 @p_96) :rule or :premises (t128.t0))
(step t128.t2 (cl @p_96) :rule resolution :premises (t128.t1 t118))
(step t128 (cl @p_26 @p_96) :rule subproof :discharge (t128.a0))
(step t129 (cl @p_97 @p_96) :rule resolution :premises (t127 t128))
(step t130 (cl @p_97 (not @p_96)) :rule implies_neg2)
(step t131 (cl @p_97 @p_97) :rule resolution :premises (t129 t130))
(step t132 (cl @p_97) :rule contraction :premises (t131))
(step t133 (cl @p_95) :rule resolution :premises (t124 t126 t132))
(step t134 (cl @p_26 @p_94) :rule implies :premises (t133))
(step t135 (cl @p_94) :rule resolution :premises (t134 t118))
(step t136 (cl @p_91 @p_79) :rule and_pos :args (0))
(step t137 (cl @p_79 @p_91) :rule reordering :premises (t136))
(step t138 (cl (! (not @p_81) :named @p_82) @p_80) :rule and_pos :args (1))
(step t139 (cl @p_80 @p_82) :rule reordering :premises (t138))
(step t140 (cl @p_82 @p_69) :rule and_pos :args (0))
(step t141 (cl @p_69 @p_82) :rule reordering :premises (t140))
(step t142 (cl @p_70 @p_82) :rule resolution :premises (t78 t81 t137 t97 t139 t141))
(step t143 (cl (! (not (! (= @p_51 @p_70) :named @p_71)) :named @p_78) @p_51 @p_77) :rule equiv_pos1)
(step t144 (cl @p_51 @p_77 @p_78) :rule reordering :premises (t143))
(step t145 (cl (not (! (= (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (! (= @p_70 @p_51) :named @p_73)) :named @p_74) (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) @p_71) :named @p_72)) :named @p_75)) (not @p_74) @p_72) :rule equiv_pos2)
(step t146 (cl (! (= @p_73 @p_71) :named @p_76)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_76 1 5))
(step t147 (cl @p_75) :rule cong :premises (t105 t146))
(step t148 (cl @p_74 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule implies_neg1)
(anchor :step t149)
(assume t149.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))
(step t149.t0 (cl (or @p_26 @p_73)) :rule forall_inst :args (@quantifiers_skolemize_3 c @p_1))
(step t149.t1 (cl @p_26 @p_73) :rule or :premises (t149.t0))
(step t149.t2 (cl @p_73) :rule resolution :premises (t149.t1 t118))
(step t149 (cl @p_26 @p_73) :rule subproof :discharge (t149.a0))
(step t150 (cl @p_74 @p_73) :rule resolution :premises (t148 t149))
(step t151 (cl @p_74 (not @p_73)) :rule implies_neg2)
(step t152 (cl @p_74 @p_74) :rule resolution :premises (t150 t151))
(step t153 (cl @p_74) :rule contraction :premises (t152))
(step t154 (cl @p_72) :rule resolution :premises (t145 t147 t153))
(step t155 (cl @p_26 @p_71) :rule implies :premises (t154))
(step t156 (cl @p_71) :rule resolution :premises (t155 t118))
(step t157 (cl (! (not (! (= @p_52 @p_63) :named @p_64)) :named @p_66) @p_53 @p_63) :rule equiv_pos2)
(step t158 (cl @p_53 @p_63 @p_66) :rule reordering :premises (t157))
(step t159 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (union ?s1 ?s2)) (or (member ?x ?s1) (member ?x ?s2))))) :named @p_65) @p_64)) :rule forall_inst :args (@quantifiers_skolemize_3 @p_4 @p_3))
(step t160 (cl @p_65 @p_64) :rule or :premises (t159))
(step t161 (cl @p_64) :rule resolution :premises (t160 a5))
(step t162 (cl @p_54 (not @p_51)) :rule or_neg :args (1))
(step t163 (cl (not (! (= (! (or @p_54 (! (not @p_53) :named @p_56)) :named @p_57) (! (or @p_54 @p_52) :named @p_55)) :named @p_59)) (not @p_57) @p_55) :rule equiv_pos2)
(step t164 (cl (= @p_54 @p_54)) :rule refl)
(step t165 (cl (! (= @p_56 @p_52) :named @p_60)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_60 1 5))
(step t166 (cl @p_59) :rule cong :premises (t164 t165))
(step t167 (cl @p_54 @p_56) :rule or_neg :args (0))
(step t168 (cl @p_57 @p_58) :rule or_neg :args (0))
(step t169 (cl @p_57 (not @p_56)) :rule or_neg :args (1))
(step t170 (cl @p_57 @p_57) :rule resolution :premises (t167 t168 t169))
(step t171 (cl @p_57) :rule contraction :premises (t170))
(step t172 (cl @p_55) :rule resolution :premises (t163 t166 t171))
(step t173 (cl @p_54 @p_52) :rule or :premises (t172))
(step t174 (cl @p_52 @p_54) :rule reordering :premises (t173))
(step t175 (cl @p_54) :rule resolution :premises (t78 t81 t83 t97 t99 t101 t103 t119 t121 t123 t135 t142 t144 t156 t158 t161 t162 t174))
(step t176 (cl (forall ((?x Elem)) (or (not (member ?x (union (difference c a) (difference c b)))) (member ?x (difference c (intersection a b)))))) :rule resolution :premises (t76 t175))
(step t177 (cl (or (! (not (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_46) @p_50)) :rule forall_inst :args (@p_5 @p_2))
(step t178 (cl @p_46 @p_50) :rule or :premises (t177))
(step t179 (cl (not (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_39)) (not (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule equiv_pos2)
(anchor :step t180 :args ((?s1 Set) (?s2 Set) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t180.t0 (cl (= (! (not (subset ?s1 ?s2)) :named @p_42) @p_42)) :rule refl)
(step t180.t1 (cl (! (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) (! (not (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2)))))) :named @p_43)) :named @p_45)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_45 13 6))
(step t180.t2 (cl (! (= (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2))))) (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_44)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_44 13 6))
(step t180.t3 (cl (= @p_43 (! (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_41))) :rule cong :premises (t180.t2))
(step t180.t4 (cl (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) @p_41)) :rule trans :premises (t180.t1 t180.t3))
(step t180.t5 (cl (= (=> @p_42 (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))) (=> @p_42 @p_41))) :rule cong :premises (t180.t0 t180.t4))
(step t180 (cl (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))))) :rule bind)
(step t181 (cl (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_40)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_40 13 6))
(step t182 (cl @p_39) :rule trans :premises (t180 t181))
(step t183 (cl (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule resolution :premises (t179 t182 a1))
(step t184 (cl @p_50) :rule resolution :premises (t178 t183))
(step t185 (cl @p_48) :rule resolution :premises (t59 t176 t184))
(step t186 (cl @p_47) :rule resolution :premises (t51 t57 t185))
(step t187 (cl (or @p_46 @p_38)) :rule forall_inst :args (@p_2 @p_5))
(step t188 (cl @p_46 @p_38) :rule or :premises (t187))
(step t189 (cl @p_38) :rule resolution :premises (t188 t183))
(step t190 (cl @p_36) :rule resolution :premises (t50 t186 t189))
(step t191 (cl @p_35) :rule resolution :premises (t48 t190))
(step t192 (cl @p_18) :rule resolution :premises (t31 t191))
(step t193 (cl (not (! (= (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (! (= @p_17 @p_18) :named @p_28)) :named @p_29) (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) @p_19) :named @p_27)) :named @p_30)) (not @p_29) @p_27) :rule equiv_pos2)
(step t194 (cl (! (= @p_28 @p_19) :named @p_31)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_31 1 5))
(step t195 (cl @p_30) :rule cong :premises (t105 t194))
(step t196 (cl @p_29 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule implies_neg1)
(anchor :step t197)
(assume t197.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))
(step t197.t0 (cl (or @p_26 @p_28)) :rule forall_inst :args (@quantifiers_skolemize_4 c @p_1))
(step t197.t1 (cl @p_26 @p_28) :rule or :premises (t197.t0))
(step t197.t2 (cl @p_28) :rule resolution :premises (t197.t1 t118))
(step t197 (cl @p_26 @p_28) :rule subproof :discharge (t197.a0))
(step t198 (cl @p_29 @p_28) :rule resolution :premises (t196 t197))
(step t199 (cl @p_29 (not @p_28)) :rule implies_neg2)
(step t200 (cl @p_29 @p_29) :rule resolution :premises (t198 t199))
(step t201 (cl @p_29) :rule contraction :premises (t200))
(step t202 (cl @p_27) :rule resolution :premises (t193 t195 t201))
(step t203 (cl @p_26 @p_19) :rule implies :premises (t202))
(step t204 (cl @p_19) :rule resolution :premises (t203 t118))
(step t205 (cl @p_17) :rule resolution :premises (t19 t192 t204))
(step t206 (cl @p_16) :rule resolution :premises (t17 t205))
(step t207 (cl (! (not (! (= (! (member @quantifiers_skolemize_4 @p_4) :named @p_158) @p_173) :named @p_175)) :named @p_182) @p_158 @p_174) :rule equiv_pos1)
(step t208 (cl @p_158 @p_174 @p_182) :rule reordering :premises (t207))
(step t209 (cl (! (or @p_158 (! (member @quantifiers_skolemize_4 @p_3) :named @p_150)) :named @p_159) (! (not @p_158) :named @p_181)) :rule or_neg :args (0))
(step t210 (cl (! (not (! (= @p_32 @p_159) :named @p_161)) :named @p_163) @p_32 (! (not @p_159) :named @p_160)) :rule equiv_pos1)
(step t211 (cl @p_32 @p_160 @p_163) :rule reordering :premises (t210))
(step t212 (cl @p_34 (! (not @p_32) :named @p_162)) :rule or_neg :args (1))
(step t213 (cl @p_162) :rule resolution :premises (t212 t191))
(step t214 (cl (or @p_65 @p_161)) :rule forall_inst :args (@quantifiers_skolemize_4 @p_4 @p_3))
(step t215 (cl @p_65 @p_161) :rule or :premises (t214))
(step t216 (cl @p_161) :rule resolution :premises (t215 a5))
(step t217 (cl @p_160) :rule resolution :premises (t211 t213 t216))
(step t218 (cl @p_181) :rule resolution :premises (t209 t217))
(step t219 (cl (not (! (= (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (! (= @p_173 @p_158) :named @p_177)) :named @p_178) (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) @p_175) :named @p_176)) :named @p_179)) (not @p_178) @p_176) :rule equiv_pos2)
(step t220 (cl (! (= @p_177 @p_175) :named @p_180)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_180 1 5))
(step t221 (cl @p_179) :rule cong :premises (t105 t220))
(step t222 (cl @p_178 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule implies_neg1)
(anchor :step t223)
(assume t223.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))
(step t223.t0 (cl (or @p_26 @p_177)) :rule forall_inst :args (@quantifiers_skolemize_4 c a))
(step t223.t1 (cl @p_26 @p_177) :rule or :premises (t223.t0))
(step t223.t2 (cl @p_177) :rule resolution :premises (t223.t1 t118))
(step t223 (cl @p_26 @p_177) :rule subproof :discharge (t223.a0))
(step t224 (cl @p_178 @p_177) :rule resolution :premises (t222 t223))
(step t225 (cl @p_178 (not @p_177)) :rule implies_neg2)
(step t226 (cl @p_178 @p_178) :rule resolution :premises (t224 t225))
(step t227 (cl @p_178) :rule contraction :premises (t226))
(step t228 (cl @p_176) :rule resolution :premises (t219 t221 t227))
(step t229 (cl @p_26 @p_175) :rule implies :premises (t228))
(step t230 (cl @p_175) :rule resolution :premises (t229 t118))
(step t231 (cl @p_174) :rule resolution :premises (t208 t218 t230))
(step t232 (cl @p_9) :rule resolution :premises (t15 t206 t231))
(step t233 (cl (not (! (= (! (or (! (and @p_16 @p_147) :named @p_148) @p_165 (! (not @p_147) :named @p_167)) :named @p_168) (! (or @p_148 @p_165 @p_8) :named @p_166)) :named @p_170)) (not @p_168) @p_166) :rule equiv_pos2)
(step t234 (cl (= @p_148 @p_148)) :rule refl)
(step t235 (cl (! (= @p_167 @p_8) :named @p_171)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_171 1 5))
(step t236 (cl @p_170) :rule cong :premises (t234 t4 t235))
(step t237 (cl @p_148 @p_165 @p_167) :rule and_neg)
(step t238 (cl @p_168 (! (not @p_148) :named @p_149)) :rule or_neg :args (0))
(step t239 (cl @p_168 @p_169) :rule or_neg :args (1))
(step t240 (cl @p_168 (not @p_167)) :rule or_neg :args (2))
(step t241 (cl @p_168 @p_168 @p_168) :rule resolution :premises (t237 t238 t239 t240))
(step t242 (cl @p_168) :rule contraction :premises (t241))
(step t243 (cl @p_166) :rule resolution :premises (t233 t236 t242))
(step t244 (cl @p_148 @p_165 @p_8) :rule or :premises (t243))
(step t245 (cl @p_165 @p_8 @p_148) :rule reordering :premises (t244))
(step t246 (cl (! (not (! (= @p_150 @p_148) :named @p_151)) :named @p_164) @p_150 @p_149) :rule equiv_pos1)
(step t247 (cl @p_150 @p_149 @p_164) :rule reordering :premises (t246))
(step t248 (cl @p_159 (! (not @p_150) :named @p_157)) :rule or_neg :args (1))
(step t249 (cl @p_157) :rule resolution :premises (t248 t217))
(step t250 (cl (not (! (= (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) (! (= @p_148 @p_150) :named @p_153)) :named @p_154) (! (=> (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))) @p_151) :named @p_152)) :named @p_155)) (not @p_154) @p_152) :rule equiv_pos2)
(step t251 (cl (! (= @p_153 @p_151) :named @p_156)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_156 1 5))
(step t252 (cl @p_155) :rule cong :premises (t105 t251))
(step t253 (cl @p_154 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2))))) :rule implies_neg1)
(anchor :step t254)
(assume t254.a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (and (member ?x ?s1) (not (member ?x ?s2))) (member ?x (difference ?s1 ?s2)))))
(step t254.t0 (cl (or @p_26 @p_153)) :rule forall_inst :args (@quantifiers_skolemize_4 c b))
(step t254.t1 (cl @p_26 @p_153) :rule or :premises (t254.t0))
(step t254.t2 (cl @p_153) :rule resolution :premises (t254.t1 t118))
(step t254 (cl @p_26 @p_153) :rule subproof :discharge (t254.a0))
(step t255 (cl @p_154 @p_153) :rule resolution :premises (t253 t254))
(step t256 (cl @p_154 (not @p_153)) :rule implies_neg2)
(step t257 (cl @p_154 @p_154) :rule resolution :premises (t255 t256))
(step t258 (cl @p_154) :rule contraction :premises (t257))
(step t259 (cl @p_152) :rule resolution :premises (t250 t252 t258))
(step t260 (cl @p_26 @p_151) :rule implies :premises (t259))
(step t261 (cl @p_151) :rule resolution :premises (t260 t118))
(step t262 (cl @p_149) :rule resolution :premises (t247 t249 t261))
(step t263 (cl @p_8) :rule resolution :premises (t245 t206 t262))
(step t264 (cl (! (not (! (= @p_12 @p_10) :named @p_13)) :named @p_146) @p_12 (! (not @p_10) :named @p_11)) :rule equiv_pos1)
(step t265 (cl @p_12 @p_11 @p_146) :rule reordering :premises (t264))
(step t266 (cl @p_145 @p_15) :rule and_pos :args (1))
(step t267 (cl @p_15 @p_145) :rule reordering :premises (t266))
(step t268 (cl @p_15) :rule resolution :premises (t267 t205))
(step t269 (cl (or @p_14 @p_13)) :rule forall_inst :args (@quantifiers_skolemize_4 a b))
(step t270 (cl @p_14 @p_13) :rule or :premises (t269))
(step t271 (cl @p_13) :rule resolution :premises (t270 a6))
(step t272 (cl @p_11) :rule resolution :premises (t265 t268 t271))
(step t273 (cl) :rule resolution :premises (t1 t232 t263 t272))
