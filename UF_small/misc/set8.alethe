unsat
(define-fun @quantifiers_skolemize_3 () Elem (choice ((?x Elem)) (not (or (not (member ?x (intersection a b))) (member ?x (intersection b a))))))
(define-fun @quantifiers_skolemize_4 () Elem (choice ((?x Elem)) (not (or (not (member ?x (intersection b a))) (member ?x (intersection a b))))))
(assume a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2))))
(assume a1 (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))))
(assume a2 (forall ((?s1 Set) (?s2 Set)) (=> (forall ((?x Elem)) (=> (member ?x ?s1) (member ?x ?s2))) (subset ?s1 ?s2))))
(assume a3 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (= ?s1 ?s2))))
(assume a4 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (and (subset ?s1 ?s2) (subset ?s2 ?s1)))))
(assume a5 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (union ?s1 ?s2)) (or (member ?x ?s1) (member ?x ?s2)))))
(assume a6 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (intersection ?s1 ?s2)) (and (member ?x ?s1) (member ?x ?s2)))))
(assume a7 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2))))))
(assume a8 (! (not (! (seteq (! (intersection a b) :named @p_2) (! (intersection b a) :named @p_1)) :named @p_3)) :named @p_4))
(step t0 (cl (! (and (! (member @quantifiers_skolemize_4 a) :named @p_6) (! (member @quantifiers_skolemize_4 b) :named @p_5)) :named @p_7) (! (not @p_6) :named @p_90) (! (not @p_5) :named @p_89)) :rule and_neg)
(step t1 (cl @p_7 @p_89 @p_90) :rule reordering :premises (t0))
(step t2 (cl (! (not (! (and @p_5 @p_6) :named @p_80)) :named @p_88) @p_6) :rule and_pos :args (1))
(step t3 (cl @p_6 @p_88) :rule reordering :premises (t2))
(step t4 (cl (! (not (! (= (! (member @quantifiers_skolemize_4 @p_1) :named @p_13) @p_80) :named @p_81)) :named @p_87) (! (not @p_13) :named @p_14) @p_80) :rule equiv_pos2)
(step t5 (cl @p_14 @p_80 @p_87) :rule reordering :premises (t4))
(step t6 (cl (not (! (= (! (or (! (or @p_14 (! (member @quantifiers_skolemize_4 @p_2) :named @p_9)) :named @p_15) (! (not @p_14) :named @p_83)) :named @p_84) (! (or @p_15 @p_13) :named @p_82)) :named @p_85)) (not @p_84) @p_82) :rule equiv_pos2)
(step t7 (cl (= @p_15 @p_15)) :rule refl)
(step t8 (cl (! (= @p_83 @p_13) :named @p_86)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_86 1 5))
(step t9 (cl @p_85) :rule cong :premises (t7 t8))
(step t10 (cl @p_15 @p_83) :rule or_neg :args (0))
(step t11 (cl @p_84 (! (not @p_15) :named @p_16)) :rule or_neg :args (0))
(step t12 (cl @p_84 (not @p_83)) :rule or_neg :args (1))
(step t13 (cl @p_84 @p_84) :rule resolution :premises (t10 t11 t12))
(step t14 (cl @p_84) :rule contraction :premises (t13))
(step t15 (cl @p_82) :rule resolution :premises (t6 t9 t14))
(step t16 (cl @p_15 @p_13) :rule or :premises (t15))
(step t17 (cl @p_13 @p_15) :rule reordering :premises (t16))
(step t18 (cl (not (! (= (! (or (! (not (! (not (forall ((?x Elem)) (or (not (member ?x (intersection b a))) (member ?x (intersection a b))))) :named @p_17)) :named @p_72) @p_16) :named @p_73) (! (or (forall ((?x Elem)) (or (not (member ?x (intersection b a))) (member ?x (intersection a b)))) @p_16) :named @p_71)) :named @p_77)) (not @p_73) @p_71) :rule equiv_pos2)
(step t19 (cl (! (= @p_72 (forall ((?x Elem)) (or (not (member ?x (intersection b a))) (member ?x (intersection a b))))) :named @p_78)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_78 1 5))
(step t20 (cl (= @p_16 @p_16)) :rule refl)
(step t21 (cl @p_77) :rule cong :premises (t19 t20))
(step t22 (cl (! (=> @p_17 @p_16) :named @p_75) @p_17) :rule implies_neg1)
(anchor :step t23)
(assume t23.a0 @p_17)
(step t23.t0 (cl (not (! (= @p_17 @p_16) :named @p_76)) @p_72 @p_16) :rule equiv_pos2)
(anchor :step t23.t1 :args ((:= (?x Elem) @quantifiers_skolemize_4)))
(step t23.t1.t0 (cl (= (or (not (! (member ?x @p_1) :named @p_60)) (! (member ?x @p_2) :named @p_61)) @p_15)) :rule refl)
(step t23.t1 (cl (= (forall ((?x Elem)) (or (not (member ?x (intersection b a))) (member ?x (intersection a b)))) @p_15)) :rule sko_forall)
(step t23.t2 (cl @p_76) :rule cong :premises (t23.t1))
(step t23.t3 (cl @p_16) :rule resolution :premises (t23.t0 t23.t2 t23.a0))
(step t23 (cl @p_72 @p_16) :rule subproof :discharge (t23.a0))
(step t24 (cl @p_75 @p_16) :rule resolution :premises (t22 t23))
(step t25 (cl @p_75 (! (not @p_16) :named @p_74)) :rule implies_neg2)
(step t26 (cl @p_75 @p_75) :rule resolution :premises (t24 t25))
(step t27 (cl @p_75) :rule contraction :premises (t26))
(step t28 (cl @p_72 @p_16) :rule implies :premises (t27))
(step t29 (cl @p_73 (not @p_72)) :rule or_neg :args (0))
(step t30 (cl @p_73 @p_74) :rule or_neg :args (1))
(step t31 (cl @p_73 @p_73) :rule resolution :premises (t28 t29 t30))
(step t32 (cl @p_73) :rule contraction :premises (t31))
(step t33 (cl @p_71) :rule resolution :premises (t18 t21 t32))
(step t34 (cl (forall ((?x Elem)) (or (not (member ?x (intersection b a))) (member ?x (intersection a b)))) @p_16) :rule or :premises (t33))
(step t35 (cl (! (not (! (or (! (subset @p_1 @p_2) :named @p_18) @p_17) :named @p_19)) :named @p_70) @p_18 @p_17) :rule or_pos)
(step t36 (cl @p_18 @p_17 @p_70) :rule reordering :premises (t35))
(step t37 (cl (! (and (! (subset @p_2 @p_1) :named @p_29) @p_18) :named @p_65) (not @p_29) (! (not @p_18) :named @p_28)) :rule and_neg)
(step t38 (cl (! (not (! (= @p_3 @p_65) :named @p_67)) :named @p_69) @p_3 (! (not @p_65) :named @p_66)) :rule equiv_pos1)
(step t39 (cl @p_3 @p_66 @p_69) :rule reordering :premises (t38))
(step t40 (cl (or (! (not (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (and (subset ?s1 ?s2) (subset ?s2 ?s1))))) :named @p_68) @p_67)) :rule forall_inst :args (@p_2 @p_1))
(step t41 (cl @p_68 @p_67) :rule or :premises (t40))
(step t42 (cl @p_67) :rule resolution :premises (t41 a4))
(step t43 (cl @p_66) :rule resolution :premises (t39 a8 t42))
(step t44 (cl (! (not (! (or @p_29 (! (not (forall ((?x Elem)) (or (not (member ?x (intersection a b))) (member ?x (intersection b a))))) :named @p_30)) :named @p_31)) :named @p_64) @p_29 @p_30) :rule or_pos)
(step t45 (cl @p_29 @p_30 @p_64) :rule reordering :premises (t44))
(step t46 (cl (not (! (= (! (or (! (not @p_30) :named @p_55) (! (not (! (or (! (not (! (member @quantifiers_skolemize_3 @p_2) :named @p_33)) :named @p_34) (! (member @quantifiers_skolemize_3 @p_1) :named @p_32)) :named @p_35)) :named @p_39)) :named @p_56) (! (or (forall ((?x Elem)) (or (not (member ?x (intersection a b))) (member ?x (intersection b a)))) @p_39) :named @p_54)) :named @p_62)) (not @p_56) @p_54) :rule equiv_pos2)
(step t47 (cl (! (= @p_55 (forall ((?x Elem)) (or (not (member ?x (intersection a b))) (member ?x (intersection b a))))) :named @p_63)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_63 1 5))
(step t48 (cl (= @p_39 @p_39)) :rule refl)
(step t49 (cl @p_62) :rule cong :premises (t47 t48))
(step t50 (cl (! (=> @p_30 @p_39) :named @p_58) @p_30) :rule implies_neg1)
(anchor :step t51)
(assume t51.a0 @p_30)
(step t51.t0 (cl (not (! (= @p_30 @p_39) :named @p_59)) @p_55 @p_39) :rule equiv_pos2)
(anchor :step t51.t1 :args ((:= (?x Elem) @quantifiers_skolemize_3)))
(step t51.t1.t0 (cl (= (or (not @p_61) @p_60) @p_35)) :rule refl)
(step t51.t1 (cl (= (forall ((?x Elem)) (or (not (member ?x (intersection a b))) (member ?x (intersection b a)))) @p_35)) :rule sko_forall)
(step t51.t2 (cl @p_59) :rule cong :premises (t51.t1))
(step t51.t3 (cl @p_39) :rule resolution :premises (t51.t0 t51.t2 t51.a0))
(step t51 (cl @p_55 @p_39) :rule subproof :discharge (t51.a0))
(step t52 (cl @p_58 @p_39) :rule resolution :premises (t50 t51))
(step t53 (cl @p_58 (! (not @p_39) :named @p_57)) :rule implies_neg2)
(step t54 (cl @p_58 @p_58) :rule resolution :premises (t52 t53))
(step t55 (cl @p_58) :rule contraction :premises (t54))
(step t56 (cl @p_55 @p_39) :rule implies :premises (t55))
(step t57 (cl @p_56 (not @p_55)) :rule or_neg :args (0))
(step t58 (cl @p_56 @p_57) :rule or_neg :args (1))
(step t59 (cl @p_56 @p_56) :rule resolution :premises (t56 t57 t58))
(step t60 (cl @p_56) :rule contraction :premises (t59))
(step t61 (cl @p_54) :rule resolution :premises (t46 t49 t60))
(step t62 (cl (forall ((?x Elem)) (or (not (member ?x (intersection a b))) (member ?x (intersection b a)))) @p_39) :rule or :premises (t61))
(step t63 (cl (! (and (! (member @quantifiers_skolemize_3 b) :named @p_42) (! (member @quantifiers_skolemize_3 a) :named @p_43)) :named @p_47) (! (not @p_42) :named @p_53) (! (not @p_43) :named @p_52)) :rule and_neg)
(step t64 (cl @p_47 @p_52 @p_53) :rule reordering :premises (t63))
(step t65 (cl (! (not (! (and @p_43 @p_42) :named @p_44)) :named @p_51) @p_42) :rule and_pos :args (1))
(step t66 (cl @p_42 @p_51) :rule reordering :premises (t65))
(step t67 (cl @p_51 @p_43) :rule and_pos :args (0))
(step t68 (cl @p_43 @p_51) :rule reordering :premises (t67))
(step t69 (cl (! (not (! (= @p_32 @p_47) :named @p_48)) :named @p_50) @p_32 (! (not @p_47) :named @p_49)) :rule equiv_pos1)
(step t70 (cl @p_32 @p_49 @p_50) :rule reordering :premises (t69))
(step t71 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (intersection ?s1 ?s2)) (and (member ?x ?s1) (member ?x ?s2))))) :named @p_11) @p_48)) :rule forall_inst :args (@quantifiers_skolemize_3 b a))
(step t72 (cl @p_11 @p_48) :rule or :premises (t71))
(step t73 (cl @p_48) :rule resolution :premises (t72 a6))
(step t74 (cl (! (not (! (= @p_33 @p_44) :named @p_45)) :named @p_46) @p_34 @p_44) :rule equiv_pos2)
(step t75 (cl @p_34 @p_44 @p_46) :rule reordering :premises (t74))
(step t76 (cl (or @p_11 @p_45)) :rule forall_inst :args (@quantifiers_skolemize_3 a b))
(step t77 (cl @p_11 @p_45) :rule or :premises (t76))
(step t78 (cl @p_45) :rule resolution :premises (t77 a6))
(step t79 (cl @p_35 (not @p_32)) :rule or_neg :args (1))
(step t80 (cl (not (! (= (! (or @p_35 (! (not @p_34) :named @p_37)) :named @p_38) (! (or @p_35 @p_33) :named @p_36)) :named @p_40)) (not @p_38) @p_36) :rule equiv_pos2)
(step t81 (cl (= @p_35 @p_35)) :rule refl)
(step t82 (cl (! (= @p_37 @p_33) :named @p_41)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_41 1 5))
(step t83 (cl @p_40) :rule cong :premises (t81 t82))
(step t84 (cl @p_35 @p_37) :rule or_neg :args (0))
(step t85 (cl @p_38 @p_39) :rule or_neg :args (0))
(step t86 (cl @p_38 (not @p_37)) :rule or_neg :args (1))
(step t87 (cl @p_38 @p_38) :rule resolution :premises (t84 t85 t86))
(step t88 (cl @p_38) :rule contraction :premises (t87))
(step t89 (cl @p_36) :rule resolution :premises (t80 t83 t88))
(step t90 (cl @p_35 @p_33) :rule or :premises (t89))
(step t91 (cl @p_33 @p_35) :rule reordering :premises (t90))
(step t92 (cl @p_35) :rule resolution :premises (t64 t66 t68 t70 t73 t75 t78 t79 t91))
(step t93 (cl (forall ((?x Elem)) (or (not (member ?x (intersection a b))) (member ?x (intersection b a))))) :rule resolution :premises (t62 t92))
(step t94 (cl (or (! (not (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_27) @p_31)) :rule forall_inst :args (@p_2 @p_1))
(step t95 (cl @p_27 @p_31) :rule or :premises (t94))
(step t96 (cl (not (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_20)) (not (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule equiv_pos2)
(anchor :step t97 :args ((?s1 Set) (?s2 Set) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t97.t0 (cl (= (! (not (subset ?s1 ?s2)) :named @p_23) @p_23)) :rule refl)
(step t97.t1 (cl (! (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) (! (not (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2)))))) :named @p_24)) :named @p_26)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_26 13 6))
(step t97.t2 (cl (! (= (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2))))) (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_25)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_25 13 6))
(step t97.t3 (cl (= @p_24 (! (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_22))) :rule cong :premises (t97.t2))
(step t97.t4 (cl (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) @p_22)) :rule trans :premises (t97.t1 t97.t3))
(step t97.t5 (cl (= (=> @p_23 (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))) (=> @p_23 @p_22))) :rule cong :premises (t97.t0 t97.t4))
(step t97 (cl (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))))) :rule bind)
(step t98 (cl (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_21)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_21 13 6))
(step t99 (cl @p_20) :rule trans :premises (t97 t98))
(step t100 (cl (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule resolution :premises (t96 t99 a1))
(step t101 (cl @p_31) :rule resolution :premises (t95 t100))
(step t102 (cl @p_29) :rule resolution :premises (t45 t93 t101))
(step t103 (cl @p_28) :rule resolution :premises (t37 t43 t102))
(step t104 (cl (or @p_27 @p_19)) :rule forall_inst :args (@p_1 @p_2))
(step t105 (cl @p_27 @p_19) :rule or :premises (t104))
(step t106 (cl @p_19) :rule resolution :premises (t105 t100))
(step t107 (cl @p_17) :rule resolution :premises (t36 t103 t106))
(step t108 (cl @p_16) :rule resolution :premises (t34 t107))
(step t109 (cl @p_13) :rule resolution :premises (t17 t108))
(step t110 (cl (or @p_11 @p_81)) :rule forall_inst :args (@quantifiers_skolemize_4 b a))
(step t111 (cl @p_11 @p_81) :rule or :premises (t110))
(step t112 (cl @p_81) :rule resolution :premises (t111 a6))
(step t113 (cl @p_80) :rule resolution :premises (t5 t109 t112))
(step t114 (cl @p_6) :rule resolution :premises (t3 t113))
(step t115 (cl @p_88 @p_5) :rule and_pos :args (0))
(step t116 (cl @p_5 @p_88) :rule reordering :premises (t115))
(step t117 (cl @p_5) :rule resolution :premises (t116 t113))
(step t118 (cl (! (not (! (= @p_9 @p_7) :named @p_10)) :named @p_79) @p_9 (! (not @p_7) :named @p_8)) :rule equiv_pos1)
(step t119 (cl @p_9 @p_8 @p_79) :rule reordering :premises (t118))
(step t120 (cl @p_15 (! (not @p_9) :named @p_12)) :rule or_neg :args (1))
(step t121 (cl @p_12) :rule resolution :premises (t120 t108))
(step t122 (cl (or @p_11 @p_10)) :rule forall_inst :args (@quantifiers_skolemize_4 a b))
(step t123 (cl @p_11 @p_10) :rule or :premises (t122))
(step t124 (cl @p_10) :rule resolution :premises (t123 a6))
(step t125 (cl @p_8) :rule resolution :premises (t119 t121 t124))
(step t126 (cl) :rule resolution :premises (t1 t114 t117 t125))
