unsat
(define-fun @quantifiers_skolemize_3 () Elem (choice ((?x Elem)) (not (or (not (member ?x b)) (member ?x (union a b))))))
(assume a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2))))
(assume a1 (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))))
(assume a2 (forall ((?s1 Set) (?s2 Set)) (=> (forall ((?x Elem)) (=> (member ?x ?s1) (member ?x ?s2))) (subset ?s1 ?s2))))
(assume a3 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (= ?s1 ?s2))))
(assume a4 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (and (subset ?s1 ?s2) (subset ?s2 ?s1)))))
(assume a5 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (union ?s1 ?s2)) (or (member ?x ?s1) (member ?x ?s2)))))
(assume a6 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (intersection ?s1 ?s2)) (and (member ?x ?s1) (member ?x ?s2)))))
(assume a7 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2))))))
(assume a8 (! (not (! (subset b (! (union a b) :named @p_1)) :named @p_2)) :named @p_3))
(step t0 (cl (! (not (! (= (! (member @quantifiers_skolemize_3 @p_1) :named @p_4) (! (or (member @quantifiers_skolemize_3 a) (! (member @quantifiers_skolemize_3 b) :named @p_6)) :named @p_22)) :named @p_28)) :named @p_31) @p_4 (! (not @p_22) :named @p_30)) :rule equiv_pos1)
(step t1 (cl @p_4 @p_30 @p_31) :rule reordering :premises (t0))
(step t2 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (union ?s1 ?s2)) (or (member ?x ?s1) (member ?x ?s2))))) :named @p_29) @p_28)) :rule forall_inst :args (@quantifiers_skolemize_3 a b))
(step t3 (cl @p_29 @p_28) :rule or :premises (t2))
(step t4 (cl @p_28) :rule resolution :premises (t3 a5))
(step t5 (cl @p_22 (! (not @p_6) :named @p_7)) :rule or_neg :args (1))
(step t6 (cl @p_7 @p_22) :rule reordering :premises (t5))
(step t7 (cl (not (! (= (! (or (! (or @p_7 @p_4) :named @p_8) (! (not @p_7) :named @p_24)) :named @p_25) (! (or @p_8 @p_6) :named @p_23)) :named @p_26)) (not @p_25) @p_23) :rule equiv_pos2)
(step t8 (cl (= @p_8 @p_8)) :rule refl)
(step t9 (cl (! (= @p_24 @p_6) :named @p_27)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_27 1 5))
(step t10 (cl @p_26) :rule cong :premises (t8 t9))
(step t11 (cl @p_8 @p_24) :rule or_neg :args (0))
(step t12 (cl @p_25 (! (not @p_8) :named @p_9)) :rule or_neg :args (0))
(step t13 (cl @p_25 (not @p_24)) :rule or_neg :args (1))
(step t14 (cl @p_25 @p_25) :rule resolution :premises (t11 t12 t13))
(step t15 (cl @p_25) :rule contraction :premises (t14))
(step t16 (cl @p_23) :rule resolution :premises (t7 t10 t15))
(step t17 (cl @p_8 @p_6) :rule or :premises (t16))
(step t18 (cl @p_6 @p_8) :rule reordering :premises (t17))
(step t19 (cl (not (! (= (! (not (forall ((?x Elem)) (or (not (member ?x b)) (member ?x (union a b))))) :named @p_10) @p_9) :named @p_21)) (not @p_10) @p_9) :rule equiv_pos2)
(anchor :step t20 :args ((:= (?x Elem) @quantifiers_skolemize_3)))
(step t20.t0 (cl (= (or (not (member ?x b)) (member ?x @p_1)) @p_8)) :rule refl)
(step t20 (cl (= (forall ((?x Elem)) (or (not (member ?x b)) (member ?x (union a b)))) @p_8)) :rule sko_forall)
(step t21 (cl @p_21) :rule cong :premises (t20))
(step t22 (cl (! (not (! (or @p_2 @p_10) :named @p_11)) :named @p_20) @p_2 @p_10) :rule or_pos)
(step t23 (cl @p_2 @p_10 @p_20) :rule reordering :premises (t22))
(step t24 (cl (or (! (not (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_19) @p_11)) :rule forall_inst :args (b @p_1))
(step t25 (cl @p_19 @p_11) :rule or :premises (t24))
(step t26 (cl (not (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_12)) (not (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule equiv_pos2)
(anchor :step t27 :args ((?s1 Set) (?s2 Set) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t27.t0 (cl (= (! (not (subset ?s1 ?s2)) :named @p_15) @p_15)) :rule refl)
(step t27.t1 (cl (! (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) (! (not (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2)))))) :named @p_16)) :named @p_18)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_18 13 6))
(step t27.t2 (cl (! (= (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2))))) (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_17)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_17 13 6))
(step t27.t3 (cl (= @p_16 (! (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_14))) :rule cong :premises (t27.t2))
(step t27.t4 (cl (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) @p_14)) :rule trans :premises (t27.t1 t27.t3))
(step t27.t5 (cl (= (=> @p_15 (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))) (=> @p_15 @p_14))) :rule cong :premises (t27.t0 t27.t4))
(step t27 (cl (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))))) :rule bind)
(step t28 (cl (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_13)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_13 13 6))
(step t29 (cl @p_12) :rule trans :premises (t27 t28))
(step t30 (cl (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule resolution :premises (t26 t29 a1))
(step t31 (cl @p_11) :rule resolution :premises (t25 t30))
(step t32 (cl @p_10) :rule resolution :premises (t23 a8 t31))
(step t33 (cl @p_9) :rule resolution :premises (t19 t21 t32))
(step t34 (cl @p_6) :rule resolution :premises (t18 t33))
(step t35 (cl @p_22) :rule resolution :premises (t6 t34))
(step t36 (cl @p_8 (! (not @p_4) :named @p_5)) :rule or_neg :args (1))
(step t37 (cl @p_5) :rule resolution :premises (t36 t33))
(step t38 (cl) :rule resolution :premises (t1 t4 t35 t37))
