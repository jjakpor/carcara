unsat
(define-fun @quantifiers_skolemize_3 () Elem (choice ((?x Elem)) (not (or (not (member ?x (union (intersection a b) (intersection a c)))) (member ?x (intersection a (union b c)))))))
(define-fun @quantifiers_skolemize_4 () Elem (choice ((?x Elem)) (not (or (not (member ?x (intersection a (union b c)))) (member ?x (union (intersection a b) (intersection a c)))))))
(assume a0 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (=> (and (member ?x ?s1) (subset ?s1 ?s2)) (member ?x ?s2))))
(assume a1 (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))))
(assume a2 (forall ((?s1 Set) (?s2 Set)) (=> (forall ((?x Elem)) (=> (member ?x ?s1) (member ?x ?s2))) (subset ?s1 ?s2))))
(assume a3 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (= ?s1 ?s2))))
(assume a4 (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (and (subset ?s1 ?s2) (subset ?s2 ?s1)))))
(assume a5 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (union ?s1 ?s2)) (or (member ?x ?s1) (member ?x ?s2)))))
(assume a6 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (intersection ?s1 ?s2)) (and (member ?x ?s1) (member ?x ?s2)))))
(assume a7 (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (difference ?s1 ?s2)) (and (member ?x ?s1) (not (member ?x ?s2))))))
(assume a8 (! (= a (! (intersection a b) :named @p_1)) :named @p_2))
(assume a9 (! (not (! (seteq (! (union @p_1 (! (intersection a c) :named @p_5)) :named @p_6) (! (intersection a (! (union b c) :named @p_3)) :named @p_4)) :named @p_7)) :named @p_8))
(step t0 (cl (! (and (! (member @quantifiers_skolemize_4 a) :named @p_9) @p_2) :named @p_113) (! (not @p_9) :named @p_112) (! (not @p_2) :named @p_111)) :rule and_neg)
(step t1 (cl (! (=> @p_113 (! (member @quantifiers_skolemize_4 @p_1) :named @p_104)) :named @p_115) @p_113) :rule implies_neg1)
(anchor :step t2)
(assume t2.a0 @p_9)
(assume t2.a1 @p_2)
(step t2.t0 (cl (= (! (= @p_104 true) :named @p_116) @p_104)) :rule equiv_simplify)
(step t2.t1 (cl (not @p_116) @p_104) :rule equiv1 :premises (t2.t0))
(step t2.t2 (cl (= @quantifiers_skolemize_4 @quantifiers_skolemize_4)) :rule refl)
(step t2.t3 (cl (= @p_1 a)) :rule symm :premises (t2.a1))
(step t2.t4 (cl (= @p_104 @p_9)) :rule cong :premises (t2.t2 t2.t3))
(step t2.t5 (cl (= (! (= @p_9 true) :named @p_117) @p_9)) :rule equiv_simplify)
(step t2.t6 (cl @p_117 @p_112) :rule equiv2 :premises (t2.t5))
(step t2.t7 (cl @p_117) :rule resolution :premises (t2.t6 t2.a0))
(step t2.t8 (cl @p_116) :rule trans :premises (t2.t4 t2.t7))
(step t2.t9 (cl @p_104) :rule resolution :premises (t2.t1 t2.t8))
(step t2 (cl @p_112 @p_111 @p_104) :rule subproof :discharge (t2.a0 t2.a1))
(step t3 (cl (! (not @p_113) :named @p_114) @p_9) :rule and_pos :args (0))
(step t4 (cl @p_114 @p_2) :rule and_pos :args (1))
(step t5 (cl @p_104 @p_114 @p_114) :rule resolution :premises (t2 t3 t4))
(step t6 (cl @p_114 @p_114 @p_104) :rule reordering :premises (t5))
(step t7 (cl @p_114 @p_104) :rule contraction :premises (t6))
(step t8 (cl @p_115 @p_104) :rule resolution :premises (t1 t7))
(step t9 (cl @p_115 (! (not @p_104) :named @p_105)) :rule implies_neg2)
(step t10 (cl @p_115 @p_115) :rule resolution :premises (t8 t9))
(step t11 (cl @p_115) :rule contraction :premises (t10))
(step t12 (cl @p_114 @p_104) :rule implies :premises (t11))
(step t13 (cl @p_112 @p_111 @p_104) :rule resolution :premises (t0 t12))
(step t14 (cl @p_111 @p_104 @p_112) :rule reordering :premises (t13))
(step t15 (cl (! (or @p_104 (member @quantifiers_skolemize_4 @p_5)) :named @p_106) @p_105) :rule or_neg :args (0))
(step t16 (cl (! (not (! (= (! (member @quantifiers_skolemize_4 @p_6) :named @p_14) @p_106) :named @p_108)) :named @p_110) @p_14 (! (not @p_106) :named @p_107)) :rule equiv_pos1)
(step t17 (cl @p_14 @p_107 @p_110) :rule reordering :premises (t16))
(step t18 (cl (! (or (! (not (! (member @quantifiers_skolemize_4 @p_4) :named @p_11)) :named @p_15) @p_14) :named @p_16) (! (not @p_14) :named @p_109)) :rule or_neg :args (1))
(step t19 (cl (not (! (= (! (or (! (not (! (not (forall ((?x Elem)) (or (not (member ?x (intersection a (union b c)))) (member ?x (union (intersection a b) (intersection a c)))))) :named @p_18)) :named @p_90) (! (not @p_16) :named @p_17)) :named @p_91) (! (or (forall ((?x Elem)) (or (not (member ?x (intersection a (union b c)))) (member ?x (union (intersection a b) (intersection a c))))) @p_17) :named @p_89)) :named @p_95)) (not @p_91) @p_89) :rule equiv_pos2)
(step t20 (cl (! (= @p_90 (forall ((?x Elem)) (or (not (member ?x (intersection a (union b c)))) (member ?x (union (intersection a b) (intersection a c)))))) :named @p_96)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_96 1 5))
(step t21 (cl (= @p_17 @p_17)) :rule refl)
(step t22 (cl @p_95) :rule cong :premises (t20 t21))
(step t23 (cl (! (=> @p_18 @p_17) :named @p_93) @p_18) :rule implies_neg1)
(anchor :step t24)
(assume t24.a0 @p_18)
(step t24.t0 (cl (not (! (= @p_18 @p_17) :named @p_94)) @p_90 @p_17) :rule equiv_pos2)
(anchor :step t24.t1 :args ((:= (?x Elem) @quantifiers_skolemize_4)))
(step t24.t1.t0 (cl (= (or (not (! (member ?x @p_4) :named @p_78)) (! (member ?x @p_6) :named @p_79)) @p_16)) :rule refl)
(step t24.t1 (cl (= (forall ((?x Elem)) (or (not (member ?x (intersection a (union b c)))) (member ?x (union (intersection a b) (intersection a c))))) @p_16)) :rule sko_forall)
(step t24.t2 (cl @p_94) :rule cong :premises (t24.t1))
(step t24.t3 (cl @p_17) :rule resolution :premises (t24.t0 t24.t2 t24.a0))
(step t24 (cl @p_90 @p_17) :rule subproof :discharge (t24.a0))
(step t25 (cl @p_93 @p_17) :rule resolution :premises (t23 t24))
(step t26 (cl @p_93 (! (not @p_17) :named @p_92)) :rule implies_neg2)
(step t27 (cl @p_93 @p_93) :rule resolution :premises (t25 t26))
(step t28 (cl @p_93) :rule contraction :premises (t27))
(step t29 (cl @p_90 @p_17) :rule implies :premises (t28))
(step t30 (cl @p_91 (not @p_90)) :rule or_neg :args (0))
(step t31 (cl @p_91 @p_92) :rule or_neg :args (1))
(step t32 (cl @p_91 @p_91) :rule resolution :premises (t29 t30 t31))
(step t33 (cl @p_91) :rule contraction :premises (t32))
(step t34 (cl @p_89) :rule resolution :premises (t19 t22 t33))
(step t35 (cl (forall ((?x Elem)) (or (not (member ?x (intersection a (union b c)))) (member ?x (union (intersection a b) (intersection a c))))) @p_17) :rule or :premises (t34))
(step t36 (cl (! (not (! (or (! (subset @p_4 @p_6) :named @p_19) @p_18) :named @p_20)) :named @p_88) @p_19 @p_18) :rule or_pos)
(step t37 (cl @p_19 @p_18 @p_88) :rule reordering :premises (t36))
(step t38 (cl (! (and (! (subset @p_6 @p_4) :named @p_30) @p_19) :named @p_83) (not @p_30) (! (not @p_19) :named @p_29)) :rule and_neg)
(step t39 (cl (! (not (! (= @p_7 @p_83) :named @p_85)) :named @p_87) @p_7 (! (not @p_83) :named @p_84)) :rule equiv_pos1)
(step t40 (cl @p_7 @p_84 @p_87) :rule reordering :premises (t39))
(step t41 (cl (or (! (not (forall ((?s1 Set) (?s2 Set)) (= (seteq ?s1 ?s2) (and (subset ?s1 ?s2) (subset ?s2 ?s1))))) :named @p_86) @p_85)) :rule forall_inst :args (@p_6 @p_4))
(step t42 (cl @p_86 @p_85) :rule or :premises (t41))
(step t43 (cl @p_85) :rule resolution :premises (t42 a4))
(step t44 (cl @p_84) :rule resolution :premises (t40 a9 t43))
(step t45 (cl (! (not (! (or @p_30 (! (not (forall ((?x Elem)) (or (not (member ?x (union (intersection a b) (intersection a c)))) (member ?x (intersection a (union b c)))))) :named @p_31)) :named @p_32)) :named @p_82) @p_30 @p_31) :rule or_pos)
(step t46 (cl @p_30 @p_31 @p_82) :rule reordering :premises (t45))
(step t47 (cl (not (! (= (! (or (! (not @p_31) :named @p_73) (! (not (! (or (! (not (! (member @quantifiers_skolemize_3 @p_6) :named @p_34)) :named @p_35) (! (member @quantifiers_skolemize_3 @p_4) :named @p_33)) :named @p_36)) :named @p_40)) :named @p_74) (! (or (forall ((?x Elem)) (or (not (member ?x (union (intersection a b) (intersection a c)))) (member ?x (intersection a (union b c))))) @p_40) :named @p_72)) :named @p_80)) (not @p_74) @p_72) :rule equiv_pos2)
(step t48 (cl (! (= @p_73 (forall ((?x Elem)) (or (not (member ?x (union (intersection a b) (intersection a c)))) (member ?x (intersection a (union b c)))))) :named @p_81)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_81 1 5))
(step t49 (cl (= @p_40 @p_40)) :rule refl)
(step t50 (cl @p_80) :rule cong :premises (t48 t49))
(step t51 (cl (! (=> @p_31 @p_40) :named @p_76) @p_31) :rule implies_neg1)
(anchor :step t52)
(assume t52.a0 @p_31)
(step t52.t0 (cl (not (! (= @p_31 @p_40) :named @p_77)) @p_73 @p_40) :rule equiv_pos2)
(anchor :step t52.t1 :args ((:= (?x Elem) @quantifiers_skolemize_3)))
(step t52.t1.t0 (cl (= (or (not @p_79) @p_78) @p_36)) :rule refl)
(step t52.t1 (cl (= (forall ((?x Elem)) (or (not (member ?x (union (intersection a b) (intersection a c)))) (member ?x (intersection a (union b c))))) @p_36)) :rule sko_forall)
(step t52.t2 (cl @p_77) :rule cong :premises (t52.t1))
(step t52.t3 (cl @p_40) :rule resolution :premises (t52.t0 t52.t2 t52.a0))
(step t52 (cl @p_73 @p_40) :rule subproof :discharge (t52.a0))
(step t53 (cl @p_76 @p_40) :rule resolution :premises (t51 t52))
(step t54 (cl @p_76 (! (not @p_40) :named @p_75)) :rule implies_neg2)
(step t55 (cl @p_76 @p_76) :rule resolution :premises (t53 t54))
(step t56 (cl @p_76) :rule contraction :premises (t55))
(step t57 (cl @p_73 @p_40) :rule implies :premises (t56))
(step t58 (cl @p_74 (not @p_73)) :rule or_neg :args (0))
(step t59 (cl @p_74 @p_75) :rule or_neg :args (1))
(step t60 (cl @p_74 @p_74) :rule resolution :premises (t57 t58 t59))
(step t61 (cl @p_74) :rule contraction :premises (t60))
(step t62 (cl @p_72) :rule resolution :premises (t47 t50 t61))
(step t63 (cl (forall ((?x Elem)) (or (not (member ?x (union (intersection a b) (intersection a c)))) (member ?x (intersection a (union b c))))) @p_40) :rule or :premises (t62))
(step t64 (cl (! (not (! (= (! (member @quantifiers_skolemize_3 @p_3) :named @p_49) (! (or (! (member @quantifiers_skolemize_3 b) :named @p_55) (! (member @quantifiers_skolemize_3 c) :named @p_58)) :named @p_59)) :named @p_60)) :named @p_62) @p_49 (! (not @p_59) :named @p_61)) :rule equiv_pos1)
(step t65 (cl @p_49 @p_61 @p_62) :rule reordering :premises (t64))
(step t66 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (union ?s1 ?s2)) (or (member ?x ?s1) (member ?x ?s2))))) :named @p_47) @p_60)) :rule forall_inst :args (@quantifiers_skolemize_3 b c))
(step t67 (cl @p_47 @p_60) :rule or :premises (t66))
(step t68 (cl @p_60) :rule resolution :premises (t67 a5))
(step t69 (cl @p_59 (not @p_58)) :rule or_neg :args (1))
(step t70 (cl (! (and (! (member @quantifiers_skolemize_3 a) :named @p_50) @p_49) :named @p_51) (not @p_50) (not @p_49)) :rule and_neg)
(step t71 (cl (! (not (! (and @p_50 @p_58) :named @p_67)) :named @p_71) @p_58) :rule and_pos :args (1))
(step t72 (cl @p_58 @p_71) :rule reordering :premises (t71))
(step t73 (cl @p_71 @p_50) :rule and_pos :args (0))
(step t74 (cl @p_50 @p_71) :rule reordering :premises (t73))
(step t75 (cl (! (not (! (= (! (member @quantifiers_skolemize_3 @p_5) :named @p_43) @p_67) :named @p_68)) :named @p_70) (! (not @p_43) :named @p_69) @p_67) :rule equiv_pos2)
(step t76 (cl @p_69 @p_67 @p_70) :rule reordering :premises (t75))
(step t77 (cl (or (! (not (forall ((?x Elem) (?s1 Set) (?s2 Set)) (= (member ?x (intersection ?s1 ?s2)) (and (member ?x ?s1) (member ?x ?s2))))) :named @p_13) @p_68)) :rule forall_inst :args (@quantifiers_skolemize_3 a c))
(step t78 (cl @p_13 @p_68) :rule or :premises (t77))
(step t79 (cl @p_68) :rule resolution :premises (t78 a6))
(step t80 (cl (! (not (! (or (! (member @quantifiers_skolemize_3 @p_1) :named @p_44) @p_43) :named @p_45)) :named @p_66) @p_44 @p_43) :rule or_pos)
(step t81 (cl @p_44 @p_43 @p_66) :rule reordering :premises (t80))
(step t82 (cl (! (not (! (= @p_44 (! (and @p_50 @p_55) :named @p_56)) :named @p_63)) :named @p_65) (! (not @p_44) :named @p_64) @p_56) :rule equiv_pos2)
(step t83 (cl @p_64 @p_56 @p_65) :rule reordering :premises (t82))
(step t84 (cl (or @p_13 @p_63)) :rule forall_inst :args (@quantifiers_skolemize_3 a b))
(step t85 (cl @p_13 @p_63) :rule or :premises (t84))
(step t86 (cl @p_63) :rule resolution :premises (t85 a6))
(step t87 (cl @p_59 (not @p_55)) :rule or_neg :args (0))
(step t88 (cl (! (not @p_56) :named @p_57) @p_55) :rule and_pos :args (1))
(step t89 (cl @p_55 @p_57) :rule reordering :premises (t88))
(step t90 (cl @p_57 @p_50) :rule and_pos :args (0))
(step t91 (cl @p_50 @p_57) :rule reordering :premises (t90))
(step t92 (cl @p_51 @p_57) :rule resolution :premises (t65 t68 t87 t70 t89 t91))
(step t93 (cl (! (not (! (= @p_33 @p_51) :named @p_52)) :named @p_54) @p_33 (! (not @p_51) :named @p_53)) :rule equiv_pos1)
(step t94 (cl @p_33 @p_53 @p_54) :rule reordering :premises (t93))
(step t95 (cl (or @p_13 @p_52)) :rule forall_inst :args (@quantifiers_skolemize_3 a @p_3))
(step t96 (cl @p_13 @p_52) :rule or :premises (t95))
(step t97 (cl @p_52) :rule resolution :premises (t96 a6))
(step t98 (cl (! (not (! (= @p_34 @p_45) :named @p_46)) :named @p_48) @p_35 @p_45) :rule equiv_pos2)
(step t99 (cl @p_35 @p_45 @p_48) :rule reordering :premises (t98))
(step t100 (cl (or @p_47 @p_46)) :rule forall_inst :args (@quantifiers_skolemize_3 @p_1 @p_5))
(step t101 (cl @p_47 @p_46) :rule or :premises (t100))
(step t102 (cl @p_46) :rule resolution :premises (t101 a5))
(step t103 (cl @p_36 (not @p_33)) :rule or_neg :args (1))
(step t104 (cl (not (! (= (! (or @p_36 (! (not @p_35) :named @p_38)) :named @p_39) (! (or @p_36 @p_34) :named @p_37)) :named @p_41)) (not @p_39) @p_37) :rule equiv_pos2)
(step t105 (cl (= @p_36 @p_36)) :rule refl)
(step t106 (cl (! (= @p_38 @p_34) :named @p_42)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_42 1 5))
(step t107 (cl @p_41) :rule cong :premises (t105 t106))
(step t108 (cl @p_36 @p_38) :rule or_neg :args (0))
(step t109 (cl @p_39 @p_40) :rule or_neg :args (0))
(step t110 (cl @p_39 (not @p_38)) :rule or_neg :args (1))
(step t111 (cl @p_39 @p_39) :rule resolution :premises (t108 t109 t110))
(step t112 (cl @p_39) :rule contraction :premises (t111))
(step t113 (cl @p_37) :rule resolution :premises (t104 t107 t112))
(step t114 (cl @p_36 @p_34) :rule or :premises (t113))
(step t115 (cl @p_34 @p_36) :rule reordering :premises (t114))
(step t116 (cl @p_36) :rule resolution :premises (t65 t68 t69 t70 t72 t74 t76 t79 t81 t83 t86 t92 t94 t97 t99 t102 t103 t115))
(step t117 (cl (forall ((?x Elem)) (or (not (member ?x (union (intersection a b) (intersection a c)))) (member ?x (intersection a (union b c)))))) :rule resolution :premises (t63 t116))
(step t118 (cl (or (! (not (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_28) @p_32)) :rule forall_inst :args (@p_6 @p_4))
(step t119 (cl @p_28 @p_32) :rule or :premises (t118))
(step t120 (cl (not (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_21)) (not (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule equiv_pos2)
(anchor :step t121 :args ((?s1 Set) (?s2 Set) (:= (?s1 Set) ?s1) (:= (?s2 Set) ?s2)))
(step t121.t0 (cl (= (! (not (subset ?s1 ?s2)) :named @p_24) @p_24)) :rule refl)
(step t121.t1 (cl (! (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) (! (not (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2)))))) :named @p_25)) :named @p_27)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_27 13 6))
(step t121.t2 (cl (! (= (forall ((?x Elem)) (not (and (member ?x ?s1) (not (member ?x ?s2))))) (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_26)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_26 13 6))
(step t121.t3 (cl (= @p_25 (! (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))) :named @p_23))) :rule cong :premises (t121.t2))
(step t121.t4 (cl (= (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))) @p_23)) :rule trans :premises (t121.t1 t121.t3))
(step t121.t5 (cl (= (=> @p_24 (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2))))) (=> @p_24 @p_23))) :rule cong :premises (t121.t0 t121.t4))
(step t121 (cl (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (exists ((?x Elem)) (and (member ?x ?s1) (not (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))))) :rule bind)
(step t122 (cl (! (= (forall ((?s1 Set) (?s2 Set)) (=> (not (subset ?s1 ?s2)) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2)))))) (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :named @p_22)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_22 13 6))
(step t123 (cl @p_21) :rule trans :premises (t121 t122))
(step t124 (cl (forall ((?s1 Set) (?s2 Set)) (or (subset ?s1 ?s2) (not (forall ((?x Elem)) (or (not (member ?x ?s1)) (member ?x ?s2))))))) :rule resolution :premises (t120 t123 a1))
(step t125 (cl @p_32) :rule resolution :premises (t119 t124))
(step t126 (cl @p_30) :rule resolution :premises (t46 t117 t125))
(step t127 (cl @p_29) :rule resolution :premises (t38 t44 t126))
(step t128 (cl (or @p_28 @p_20)) :rule forall_inst :args (@p_4 @p_6))
(step t129 (cl @p_28 @p_20) :rule or :premises (t128))
(step t130 (cl @p_20) :rule resolution :premises (t129 t124))
(step t131 (cl @p_18) :rule resolution :premises (t37 t127 t130))
(step t132 (cl @p_17) :rule resolution :premises (t35 t131))
(step t133 (cl @p_109) :rule resolution :premises (t18 t132))
(step t134 (cl (or @p_47 @p_108)) :rule forall_inst :args (@quantifiers_skolemize_4 @p_1 @p_5))
(step t135 (cl @p_47 @p_108) :rule or :premises (t134))
(step t136 (cl @p_108) :rule resolution :premises (t135 a5))
(step t137 (cl @p_107) :rule resolution :premises (t17 t133 t136))
(step t138 (cl @p_105) :rule resolution :premises (t15 t137))
(step t139 (cl (! (not (! (and @p_9 (member @quantifiers_skolemize_4 @p_3)) :named @p_10)) :named @p_103) @p_9) :rule and_pos :args (0))
(step t140 (cl @p_9 @p_103) :rule reordering :premises (t139))
(step t141 (cl (! (not (! (= @p_11 @p_10) :named @p_12)) :named @p_102) @p_15 @p_10) :rule equiv_pos2)
(step t142 (cl @p_15 @p_10 @p_102) :rule reordering :premises (t141))
(step t143 (cl (not (! (= (! (or @p_16 (! (not @p_15) :named @p_98)) :named @p_99) (! (or @p_16 @p_11) :named @p_97)) :named @p_100)) (not @p_99) @p_97) :rule equiv_pos2)
(step t144 (cl (= @p_16 @p_16)) :rule refl)
(step t145 (cl (! (= @p_98 @p_11) :named @p_101)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_101 1 5))
(step t146 (cl @p_100) :rule cong :premises (t144 t145))
(step t147 (cl @p_16 @p_98) :rule or_neg :args (0))
(step t148 (cl @p_99 @p_17) :rule or_neg :args (0))
(step t149 (cl @p_99 (not @p_98)) :rule or_neg :args (1))
(step t150 (cl @p_99 @p_99) :rule resolution :premises (t147 t148 t149))
(step t151 (cl @p_99) :rule contraction :premises (t150))
(step t152 (cl @p_97) :rule resolution :premises (t143 t146 t151))
(step t153 (cl @p_16 @p_11) :rule or :premises (t152))
(step t154 (cl @p_11 @p_16) :rule reordering :premises (t153))
(step t155 (cl @p_11) :rule resolution :premises (t154 t132))
(step t156 (cl (or @p_13 @p_12)) :rule forall_inst :args (@quantifiers_skolemize_4 a @p_3))
(step t157 (cl @p_13 @p_12) :rule or :premises (t156))
(step t158 (cl @p_12) :rule resolution :premises (t157 a6))
(step t159 (cl @p_10) :rule resolution :premises (t142 t155 t158))
(step t160 (cl @p_9) :rule resolution :premises (t140 t159))
(step t161 (cl) :rule resolution :premises (t14 t138 t160 a8))
