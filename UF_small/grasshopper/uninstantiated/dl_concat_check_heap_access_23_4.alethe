unsat
(assume a0 (forall ((?f FldLoc)) (= (read$0 ?f null$0) null$0)))
(assume a1 (forall ((x Loc) (y Loc)) (or (and (= x y) (in$0 x (setenum$0 y))) (and (not (= x y)) (not (in$0 x (setenum$0 y)))))))
(assume a2 (forall ((X SetLoc) (Y SetLoc) (x Loc)) (or (and (in$0 x X) (in$0 x (setminus$0 X Y)) (not (in$0 x Y))) (and (or (in$0 x Y) (not (in$0 x X))) (not (in$0 x (setminus$0 X Y)))))))
(assume a3 (forall ((X SetLoc) (Y SetLoc) (x Loc)) (or (and (in$0 x X) (in$0 x Y) (in$0 x (intersection$0 X Y))) (and (or (not (in$0 x X)) (not (in$0 x Y))) (not (in$0 x (intersection$0 X Y)))))))
(assume a4 (forall ((X SetLoc) (Y SetLoc) (x Loc)) (or (and (in$0 x (union$0 X Y)) (or (in$0 x X) (in$0 x Y))) (and (not (in$0 x X)) (not (in$0 x Y)) (not (in$0 x (union$0 X Y)))))))
(assume a5 (forall ((x Loc)) (not (in$0 x emptyset$0))))
(assume a6 (or (! (not Axiom_6$0) :named @p_1) (forall ((l1 Loc) (l2 Loc)) (or (= (read$0 prev$0 l2) l1) (not (= (read$0 next$0 l1) l2)) (not (in$0 l1 sk_?X_10$0)) (not (in$0 l2 sk_?X_10$0))))))
(assume a7 (or (and (Btwn$0 next$0 start2$0 null$0 null$0) (or (and (= null$0 end2$0) (! (= start2$0 null$0) :named @p_3)) (and (= (read$0 next$0 end2$0) null$0) (= (read$0 prev$0 start2$0) null$0) (in$0 end2$0 sk_?X_9$0))) Axiom_7$0) (not (! (dlseg_struct$0 sk_?X_9$0 next$0 prev$0 start2$0 null$0 null$0 end2$0) :named @p_2))))
(assume a8 (= Alloc$0 (union$0 FP_Caller$0 Alloc$0)))
(assume a9 (! (= sk_?X_8$0 (! (union$0 sk_?X_10$0 sk_?X_9$0) :named @p_4)) :named @p_5))
(assume a10 (! (= sk_?X_9$0 (! (dlseg_domain$0 next$0 prev$0 start2$0 null$0 null$0 end2$0) :named @p_6)) :named @p_7))
(assume a11 (= FP_Caller$0 (union$0 FP$0 FP_Caller$0)))
(assume a12 (! (dlseg_struct$0 sk_?X_10$0 next$0 prev$0 start1$0 null$0 null$0 end1$0) :named @p_8))
(assume a13 (not @p_3))
(assume a14 (! (not (! (in$0 end1$0 FP$0) :named @p_9)) :named @p_10))
(assume a15 (forall ((l1 Loc)) (or (and (Btwn$0 next$0 start2$0 l1 null$0) (in$0 l1 (dlseg_domain$0 next$0 prev$0 start2$0 null$0 null$0 end2$0)) (not (= l1 null$0))) (and (or (= l1 null$0) (not (Btwn$0 next$0 start2$0 l1 null$0))) (not (in$0 l1 (dlseg_domain$0 next$0 prev$0 start2$0 null$0 null$0 end2$0)))))))
(assume a16 (forall ((?X SetLoc) (?f FldLoc) (?x Loc)) (or (in$0 (ep$0 ?f ?X ?x) ?X) (= ?x (ep$0 ?f ?X ?x)))))
(assume a17 (forall ((?X SetLoc) (?f FldLoc) (?x Loc)) (Btwn$0 ?f ?x (ep$0 ?f ?X ?x) (ep$0 ?f ?X ?x))))
(assume a18 (! (or (! (and (! (Btwn$0 next$0 start1$0 null$0 null$0) :named @p_22) (! (or (! (and (! (= null$0 end1$0) :named @p_19) (! (= start1$0 null$0) :named @p_18)) :named @p_20) (! (and (! (= (! (read$0 next$0 end1$0) :named @p_15) null$0) :named @p_16) (! (= (! (read$0 prev$0 start1$0) :named @p_13) null$0) :named @p_14) (! (in$0 end1$0 sk_?X_10$0) :named @p_12)) :named @p_17)) :named @p_21) Axiom_6$0) :named @p_23) (! (not @p_8) :named @p_11)) :named @p_24))
(assume a19 (or (not Axiom_7$0) (forall ((l1 Loc) (l2 Loc)) (or (= (read$0 prev$0 l2) l1) (not (= (read$0 next$0 l1) l2)) (not (in$0 l1 sk_?X_9$0)) (not (in$0 l2 sk_?X_9$0))))))
(assume a20 (= FP_Caller_1$0 (setminus$0 FP_Caller$0 FP$0)))
(assume a21 (= emptyset$0 (intersection$0 sk_?X_10$0 sk_?X_9$0)))
(assume a22 (! (= sk_?X_8$0 FP$0) :named @p_25))
(assume a23 (! (= sk_?X_10$0 (! (dlseg_domain$0 next$0 prev$0 start1$0 null$0 null$0 end1$0) :named @p_26)) :named @p_27))
(assume a24 @p_2)
(assume a25 (! (not @p_18) :named @p_28))
(assume a26 (not (in$0 null$0 Alloc$0)))
(assume a27 (forall ((l1 Loc)) (or (and (Btwn$0 next$0 start1$0 l1 null$0) (in$0 l1 (dlseg_domain$0 next$0 prev$0 start1$0 null$0 null$0 end1$0)) (not (= l1 null$0))) (and (or (= l1 null$0) (not (Btwn$0 next$0 start1$0 l1 null$0))) (not (in$0 l1 (dlseg_domain$0 next$0 prev$0 start1$0 null$0 null$0 end1$0)))))))
(assume a28 (forall ((?X SetLoc) (?f FldLoc) (?x Loc) (?y Loc)) (or (Btwn$0 ?f ?x (ep$0 ?f ?X ?x) ?y) (not (Btwn$0 ?f ?x ?y ?y)) (not (in$0 ?y ?X)))))
(assume a29 (forall ((?X SetLoc) (?f FldLoc) (?x Loc) (?y Loc)) (or (not (Btwn$0 ?f ?x ?y ?y)) (not (in$0 ?y ?X)) (in$0 (ep$0 ?f ?X ?x) ?X))))
(assume a30 (forall ((?f FldLoc) (?u Loc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 ?f ?x ?y ?z)) (not (Btwn$0 ?f ?x ?u ?y)) (and (Btwn$0 ?f ?x ?u ?z) (Btwn$0 ?f ?u ?y ?z)))))
(assume a31 (forall ((?f FldLoc) (?u Loc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 ?f ?x ?y ?z)) (not (Btwn$0 ?f ?y ?u ?z)) (and (Btwn$0 ?f ?x ?y ?u) (Btwn$0 ?f ?x ?u ?z)))))
(assume a32 (forall ((?f FldLoc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 ?f ?x ?y ?y)) (not (Btwn$0 ?f ?y ?z ?z)) (Btwn$0 ?f ?x ?z ?z))))
(assume a33 (forall ((?f FldLoc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 ?f ?x ?y ?z)) (and (Btwn$0 ?f ?x ?y ?y) (Btwn$0 ?f ?y ?z ?z)))))
(assume a34 (forall ((?f FldLoc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 ?f ?x ?y ?y)) (not (Btwn$0 ?f ?x ?z ?z)) (Btwn$0 ?f ?x ?y ?z) (Btwn$0 ?f ?x ?z ?y))))
(assume a35 (forall ((?f FldLoc) (?x Loc) (?y Loc)) (or (not (Btwn$0 ?f ?x ?y ?x)) (= ?x ?y))))
(assume a36 (forall ((?f FldLoc) (?x Loc) (?y Loc)) (or (not (Btwn$0 ?f ?x ?y ?y)) (= ?x ?y) (Btwn$0 ?f ?x (read$0 ?f ?x) ?y))))
(assume a37 (forall ((?f FldLoc) (?x Loc) (?y Loc)) (or (not (= (read$0 ?f ?x) ?x)) (not (Btwn$0 ?f ?x ?y ?y)) (= ?x ?y))))
(assume a38 (forall ((?f FldLoc) (?x Loc)) (Btwn$0 ?f ?x (read$0 ?f ?x) (read$0 ?f ?x))))
(assume a39 (forall ((?f FldLoc) (?x Loc)) (Btwn$0 ?f ?x ?x ?x)))
(step t0 (cl (! (not (! (or (! (and (! (in$0 end1$0 (! (union$0 (! (dlseg_domain$0 next$0 prev$0 start1$0 @p_15 @p_15 end1$0) :named @p_30) (! (dlseg_domain$0 next$0 prev$0 start2$0 @p_15 @p_15 end2$0) :named @p_29)) :named @p_31)) :named @p_32) (or (! (in$0 end1$0 @p_30) :named @p_35) (! (in$0 end1$0 @p_29) :named @p_34))) :named @p_38) (! (and (! (not @p_35) :named @p_36) (not @p_34) (! (not @p_32) :named @p_33)) :named @p_37)) :named @p_39)) :named @p_101) @p_38 @p_37) :rule or_pos)
(step t1 (cl @p_38 @p_37 @p_101) :rule reordering :premises (t0))
(step t2 (cl (! (not @p_37) :named @p_62) @p_36) :rule and_pos :args (0))
(step t3 (cl @p_36 @p_62) :rule reordering :premises (t2))
(step t4 (cl (! (not (! (and (! (= @p_15 @p_13) :named @p_63) @p_35) :named @p_64)) :named @p_100) @p_35) :rule and_pos :args (1))
(step t5 (cl @p_35 @p_100) :rule reordering :premises (t4))
(step t6 (cl (! (not (! (or (! (and (! (= end1$0 @p_15) :named @p_66) (! (= start1$0 @p_15) :named @p_65)) :named @p_67) @p_64) :named @p_68)) :named @p_99) @p_67 @p_64) :rule or_pos)
(step t7 (cl @p_67 @p_64 @p_99) :rule reordering :premises (t6))
(step t8 (cl (! (not @p_67) :named @p_95) @p_65) :rule and_pos :args (1))
(step t9 (cl @p_65 @p_95) :rule reordering :premises (t8))
(step t10 (cl (not (! (= @p_28 (! (not @p_65) :named @p_96)) :named @p_97)) (not @p_28) @p_96) :rule equiv_pos2)
(step t11 (cl (! (= @p_18 (! (= null$0 start1$0) :named @p_47)) :named @p_57)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_57 2 6))
(step t12 (cl (= @p_28 (! (not @p_47) :named @p_50))) :rule cong :premises (t11))
(step t13 (cl (not (! (= @p_24 (! (or (! (and @p_22 (! (or (! (and @p_19 @p_47) :named @p_48) (! (and (! (= null$0 @p_15) :named @p_44) (! (= null$0 @p_13) :named @p_45) @p_12) :named @p_46)) :named @p_51) Axiom_6$0) :named @p_52) @p_11) :named @p_53)) :named @p_54)) (! (not @p_24) :named @p_58) @p_53) :rule equiv_pos2)
(step t14 (cl (= @p_22 @p_22)) :rule refl)
(step t15 (cl (= @p_19 @p_19)) :rule refl)
(step t16 (cl (= @p_20 @p_48)) :rule cong :premises (t15 t11))
(step t17 (cl (! (= @p_16 @p_44) :named @p_56)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_56 2 6))
(step t18 (cl (! (= @p_14 @p_45) :named @p_55)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_55 2 6))
(step t19 (cl (= @p_12 @p_12)) :rule refl)
(step t20 (cl (= @p_17 @p_46)) :rule cong :premises (t17 t18 t19))
(step t21 (cl (= @p_21 @p_51)) :rule cong :premises (t16 t20))
(step t22 (cl (= Axiom_6$0 Axiom_6$0)) :rule refl)
(step t23 (cl (= @p_23 @p_52)) :rule cong :premises (t14 t21 t22))
(step t24 (cl (= @p_11 @p_11)) :rule refl)
(step t25 (cl @p_54) :rule cong :premises (t23 t24))
(step t26 (cl @p_53) :rule resolution :premises (t13 t25 a18))
(step t27 (cl @p_52 @p_11) :rule or :premises (t26))
(step t28 (cl @p_52) :rule resolution :premises (t27 a12))
(step t29 (cl @p_51) :rule and :premises (t28) :args (1))
(step t30 (cl @p_48 @p_46) :rule or :premises (t29))
(step t31 (cl (! (not @p_48) :named @p_49) @p_47) :rule and_pos :args (1))
(step t32 (cl @p_50) :rule not_symm :premises (a25))
(step t33 (cl @p_49) :rule resolution :premises (t31 t32))
(step t34 (cl @p_46) :rule resolution :premises (t30 t33))
(step t35 (cl @p_44) :rule and :premises (t34) :args (0))
(step t36 (cl (= start1$0 start1$0)) :rule refl)
(step t37 (cl (= @p_47 (! (= @p_15 start1$0) :named @p_78))) :rule cong :premises (t35 t36))
(step t38 (cl (= @p_50 (! (not @p_78) :named @p_98))) :rule cong :premises (t37))
(step t39 (cl (! (= @p_78 @p_65) :named @p_88)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_88 2 6))
(step t40 (cl (= @p_98 @p_96)) :rule cong :premises (t39))
(step t41 (cl (= @p_50 @p_96)) :rule trans :premises (t38 t40))
(step t42 (cl @p_97) :rule trans :premises (t12 t41))
(step t43 (cl @p_96) :rule resolution :premises (t10 t42 a25))
(step t44 (cl @p_95) :rule resolution :premises (t9 t43))
(step t45 (cl (! (not (! (and (! (Btwn$0 next$0 start1$0 @p_15 @p_15) :named @p_69) @p_68) :named @p_70)) :named @p_94) @p_68) :rule and_pos :args (1))
(step t46 (cl @p_68 @p_94) :rule reordering :premises (t45))
(step t47 (cl (not (! (= @p_24 (! (or @p_70 (! (not (! (dlseg_struct$0 @p_30 next$0 prev$0 start1$0 @p_15 @p_15 end1$0) :named @p_71)) :named @p_73)) :named @p_74)) :named @p_75)) @p_58 @p_74) :rule equiv_pos2)
(step t48 (cl (= next$0 next$0)) :rule refl)
(step t49 (cl (= @p_22 @p_69)) :rule cong :premises (t48 t36 t35 t35))
(step t50 (cl (= end1$0 end1$0)) :rule refl)
(step t51 (cl (= @p_19 (! (= @p_15 end1$0) :named @p_79))) :rule cong :premises (t35 t50))
(step t52 (cl (= @p_48 (! (and @p_79 @p_78) :named @p_80))) :rule cong :premises (t51 t37))
(step t53 (cl (! (= @p_15 @p_15) :named @p_76)) :rule refl)
(step t54 (cl (= @p_44 @p_76)) :rule cong :premises (t35 t53))
(step t55 (cl (= @p_13 @p_13)) :rule refl)
(step t56 (cl (= @p_45 @p_63)) :rule cong :premises (t35 t55))
(step t57 (cl (= prev$0 prev$0)) :rule refl)
(step t58 (cl (= @p_26 @p_30)) :rule cong :premises (t48 t57 t36 t35 t35 t50))
(step t59 (cl (= sk_?X_10$0 @p_30)) :rule trans :premises (a23 t58))
(step t60 (cl (= @p_12 @p_35)) :rule cong :premises (t50 t59))
(step t61 (cl (= @p_46 (! (and @p_76 @p_63 @p_35) :named @p_77))) :rule cong :premises (t54 t56 t60))
(step t62 (cl (= @p_51 (! (or @p_80 @p_77) :named @p_81))) :rule cong :premises (t52 t61))
(step t63 (cl (not (! (= Axiom_6$0 (! (= Axiom_6$0 true) :named @p_91)) :named @p_92)) @p_1 @p_91) :rule equiv_pos2)
(step t64 (cl (! (= @p_91 Axiom_6$0) :named @p_93)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_93 1 5))
(step t65 (cl @p_92) :rule symm :premises (t64))
(step t66 (cl Axiom_6$0) :rule and :premises (t28) :args (2))
(step t67 (cl @p_91) :rule resolution :premises (t63 t65 t66))
(step t68 (cl (= @p_52 (! (and @p_69 @p_81 true) :named @p_82))) :rule cong :premises (t49 t62 t67))
(step t69 (cl (! (= @p_8 @p_71) :named @p_72)) :rule cong :premises (t59 t48 t57 t36 t35 t35 t50))
(step t70 (cl (= @p_11 @p_73)) :rule cong :premises (t69))
(step t71 (cl (= @p_53 (! (or @p_82 @p_73) :named @p_83))) :rule cong :premises (t68 t70))
(step t72 (cl (! (= @p_82 (! (and @p_69 @p_81) :named @p_84)) :named @p_90)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_90 1 5))
(step t73 (cl (= @p_69 @p_69)) :rule refl)
(step t74 (cl (! (= @p_79 @p_66) :named @p_89)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_89 2 6))
(step t75 (cl (= @p_80 @p_67)) :rule cong :premises (t74 t39))
(step t76 (cl (! (= @p_76 true) :named @p_87)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_87 2 5))
(step t77 (cl (= @p_63 @p_63)) :rule refl)
(step t78 (cl (= @p_35 @p_35)) :rule refl)
(step t79 (cl (= @p_77 (! (and true @p_63 @p_35) :named @p_85))) :rule cong :premises (t76 t77 t78))
(step t80 (cl (! (= @p_85 @p_64) :named @p_86)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_86 1 6))
(step t81 (cl (= @p_77 @p_64)) :rule trans :premises (t79 t80))
(step t82 (cl (= @p_81 @p_68)) :rule cong :premises (t75 t81))
(step t83 (cl (= @p_84 @p_70)) :rule cong :premises (t73 t82))
(step t84 (cl (= @p_82 @p_70)) :rule trans :premises (t72 t83))
(step t85 (cl (= @p_73 @p_73)) :rule refl)
(step t86 (cl (= @p_83 @p_74)) :rule cong :premises (t84 t85))
(step t87 (cl (= @p_53 @p_74)) :rule trans :premises (t71 t86))
(step t88 (cl @p_75) :rule trans :premises (t25 t87))
(step t89 (cl @p_74) :rule resolution :premises (t47 t88 a18))
(step t90 (cl @p_70 @p_73) :rule or :premises (t89))
(step t91 (cl @p_73 @p_70) :rule reordering :premises (t90))
(step t92 (cl (not @p_72) @p_11 @p_71) :rule equiv_pos2)
(step t93 (cl @p_71) :rule resolution :premises (t92 t69 a12))
(step t94 (cl @p_70) :rule resolution :premises (t91 t93))
(step t95 (cl @p_68) :rule resolution :premises (t46 t94))
(step t96 (cl @p_64) :rule resolution :premises (t7 t44 t95))
(step t97 (cl @p_35) :rule resolution :premises (t5 t96))
(step t98 (cl @p_62) :rule resolution :premises (t3 t97))
(step t99 (cl (! (not @p_38) :named @p_41) @p_32) :rule and_pos :args (0))
(step t100 (cl @p_32 @p_41) :rule reordering :premises (t99))
(step t101 (cl (not (! (= @p_10 @p_33) :named @p_42)) (not @p_10) @p_33) :rule equiv_pos2)
(step t102 (cl (not (! (= (! (= FP$0 sk_?X_8$0) :named @p_60) (! (= FP$0 (! (union$0 sk_?X_10$0 @p_6) :named @p_43)) :named @p_59)) :named @p_61)) (not @p_60) @p_59) :rule equiv_pos2)
(step t103 (cl (= FP$0 FP$0)) :rule refl)
(step t104 (cl (= sk_?X_10$0 sk_?X_10$0)) :rule refl)
(step t105 (cl (= @p_4 @p_43)) :rule cong :premises (t104 a10))
(step t106 (cl (= sk_?X_8$0 @p_43)) :rule trans :premises (a9 t105))
(step t107 (cl @p_61) :rule cong :premises (t103 t106))
(step t108 (cl @p_60) :rule symm :premises (a22))
(step t109 (cl @p_59) :rule resolution :premises (t102 t107 t108))
(step t110 (cl (= start2$0 start2$0)) :rule refl)
(step t111 (cl (= end2$0 end2$0)) :rule refl)
(step t112 (cl (= @p_6 @p_29)) :rule cong :premises (t48 t57 t110 t35 t35 t111))
(step t113 (cl (= @p_43 @p_31)) :rule cong :premises (t59 t112))
(step t114 (cl (= FP$0 @p_31)) :rule trans :premises (t109 t113))
(step t115 (cl (= @p_9 @p_32)) :rule cong :premises (t50 t114))
(step t116 (cl @p_42) :rule cong :premises (t115))
(step t117 (cl @p_33) :rule resolution :premises (t101 t116 a14))
(step t118 (cl @p_41) :rule resolution :premises (t100 t117))
(step t119 (cl (or (! (not (forall ((X SetLoc) (Y SetLoc) (x Loc)) (or (and (in$0 x (union$0 X Y)) (or (in$0 x X) (in$0 x Y))) (and (not (in$0 x X)) (not (in$0 x Y)) (not (in$0 x (union$0 X Y))))))) :named @p_40) @p_39)) :rule forall_inst :args (@p_30 @p_29 end1$0))
(step t120 (cl @p_40 @p_39) :rule or :premises (t119))
(step t121 (cl @p_39) :rule resolution :premises (t120 a4))
(step t122 (cl) :rule resolution :premises (t1 t98 t118 t121))
