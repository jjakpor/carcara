unsat
(assume a0 (forall ((?f FldLoc)) (= (read$0 ?f null$0) null$0)))
(assume a1 (forall ((x Loc) (y Loc)) (or (and (= x y) (in$0 x (setenum$0 y))) (and (not (= x y)) (not (in$0 x (setenum$0 y)))))))
(assume a2 (forall ((X SetLoc) (Y SetLoc) (x Loc)) (or (and (in$0 x X) (in$0 x (setminus$0 X Y)) (not (in$0 x Y))) (and (or (in$0 x Y) (not (in$0 x X))) (not (in$0 x (setminus$0 X Y)))))))
(assume a3 (forall ((X SetLoc) (Y SetLoc) (x Loc)) (or (and (in$0 x X) (in$0 x Y) (in$0 x (intersection$0 X Y))) (and (or (not (in$0 x X)) (not (in$0 x Y))) (not (in$0 x (intersection$0 X Y)))))))
(assume a4 (forall ((X SetLoc) (Y SetLoc) (x Loc)) (or (and (in$0 x (union$0 X Y)) (or (in$0 x X) (in$0 x Y))) (and (not (in$0 x X)) (not (in$0 x Y)) (not (in$0 x (union$0 X Y)))))))
(assume a5 (forall ((x Loc)) (not (in$0 x emptyset$0))))
(assume a6 (= FP_Caller_2$0 (setminus$0 FP_Caller$0 FP$0)))
(assume a7 (= (read$0 next$0 root_x$0) null$0))
(assume a8 (= emptyset$0 (intersection$0 sk_?X_5$0 sk_?X_3$0)))
(assume a9 (! (= sk_?X_2$0 (! (union$0 sk_?X_5$0 sk_?X_3$0) :named @p_1)) :named @p_2))
(assume a10 (! (= sk_?X_3$0 sk_?X_4$0) :named @p_3))
(assume a11 (! (= sk_?X_5$0 (! (lseg_set_domain$0 next$0 x$0 root_x$0) :named @p_4)) :named @p_5))
(assume a12 (! (lseg_set_struct$0 sk_?X_5$0 next$0 x$0 root_x$0 X$0) :named @p_6))
(assume a13 (! (not (! (in$0 x$0 FP$0) :named @p_7)) :named @p_8))
(assume a14 (forall ((l1 Loc)) (or (and (Btwn$0 next$0 x$0 l1 root_x$0) (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)) (not (= l1 root_x$0))) (and (or (= l1 root_x$0) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)))))))
(assume a15 (forall ((?X SetLoc) (?f FldLoc) (?x Loc)) (or (in$0 (ep$0 ?f ?X ?x) ?X) (= ?x (ep$0 ?f ?X ?x)))))
(assume a16 (forall ((?X SetLoc) (?f FldLoc) (?x Loc)) (Btwn$0 ?f ?x (ep$0 ?f ?X ?x) (ep$0 ?f ?X ?x))))
(assume a17 (! (or (! (Btwn$0 next$0 x$0 root_x$0 root_x$0) :named @p_10) (! (not @p_6) :named @p_9)) :named @p_11))
(assume a18 (= Alloc$0 (union$0 FP_Caller$0 Alloc$0)))
(assume a19 (= emptyset$0 emptyset$0))
(assume a20 (! (= X$0 (! (lseg_set_X$0 next$0 x$0 root_x$0) :named @p_12)) :named @p_13))
(assume a21 (! (= sk_?X_2$0 FP$0) :named @p_14))
(assume a22 (! (= sk_?X_4$0 (! (setenum$0 root_x$0) :named @p_15)) :named @p_16))
(assume a23 (= FP_Caller$0 (union$0 FP$0 FP_Caller$0)))
(assume a24 (not (in$0 null$0 Alloc$0)))
(assume a25 (forall ((l1 Loc)) (or (and (Btwn$0 next$0 x$0 l1 root_x$0) (in$0 l1 (lseg_set_X$0 next$0 x$0 root_x$0)) (not (= l1 root_x$0))) (and (or (= l1 root_x$0) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_X$0 next$0 x$0 root_x$0)))))))
(assume a26 (forall ((?X SetLoc) (?f FldLoc) (?x Loc) (?y Loc)) (or (Btwn$0 ?f ?x (ep$0 ?f ?X ?x) ?y) (not (Btwn$0 ?f ?x ?y ?y)) (not (in$0 ?y ?X)))))
(assume a27 (forall ((?X SetLoc) (?f FldLoc) (?x Loc) (?y Loc)) (or (not (Btwn$0 ?f ?x ?y ?y)) (not (in$0 ?y ?X)) (in$0 (ep$0 ?f ?X ?x) ?X))))
(assume a28 (forall ((?f FldLoc) (?u Loc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 ?f ?x ?y ?z)) (not (Btwn$0 ?f ?x ?u ?y)) (and (Btwn$0 ?f ?x ?u ?z) (Btwn$0 ?f ?u ?y ?z)))))
(assume a29 (forall ((?f FldLoc) (?u Loc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 ?f ?x ?y ?z)) (not (Btwn$0 ?f ?y ?u ?z)) (and (Btwn$0 ?f ?x ?y ?u) (Btwn$0 ?f ?x ?u ?z)))))
(assume a30 (forall ((?f FldLoc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 ?f ?x ?y ?y)) (not (Btwn$0 ?f ?y ?z ?z)) (Btwn$0 ?f ?x ?z ?z))))
(assume a31 (forall ((?f FldLoc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 ?f ?x ?y ?z)) (and (Btwn$0 ?f ?x ?y ?y) (Btwn$0 ?f ?y ?z ?z)))))
(assume a32 (forall ((?f FldLoc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 ?f ?x ?y ?y)) (not (Btwn$0 ?f ?x ?z ?z)) (Btwn$0 ?f ?x ?y ?z) (Btwn$0 ?f ?x ?z ?y))))
(assume a33 (forall ((?f FldLoc) (?x Loc) (?y Loc)) (or (not (Btwn$0 ?f ?x ?y ?x)) (= ?x ?y))))
(assume a34 (forall ((?f FldLoc) (?x Loc) (?y Loc)) (or (not (Btwn$0 ?f ?x ?y ?y)) (= ?x ?y) (Btwn$0 ?f ?x (read$0 ?f ?x) ?y))))
(assume a35 (forall ((?f FldLoc) (?x Loc) (?y Loc)) (or (not (= (read$0 ?f ?x) ?x)) (not (Btwn$0 ?f ?x ?y ?y)) (= ?x ?y))))
(assume a36 (forall ((?f FldLoc) (?x Loc)) (Btwn$0 ?f ?x (read$0 ?f ?x) (read$0 ?f ?x))))
(assume a37 (forall ((?f FldLoc) (?x Loc)) (Btwn$0 ?f ?x ?x ?x)))
(step t0 (cl (! (not (! (or (! (not (! (Btwn$0 next$0 x$0 x$0 x$0) :named @p_17)) :named @p_22) (! (not (! (Btwn$0 next$0 x$0 root_x$0 x$0) :named @p_19)) :named @p_130) (! (and (! (Btwn$0 next$0 x$0 x$0 root_x$0) :named @p_20) @p_19) :named @p_128)) :named @p_131)) :named @p_133) @p_22 @p_130 @p_128) :rule or_pos)
(step t1 (cl @p_22 @p_130 @p_128 @p_133) :rule reordering :premises (t0))
(step t2 (cl (or (! (not (forall ((?f FldLoc) (?u Loc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 ?f ?x ?y ?z)) (not (Btwn$0 ?f ?y ?u ?z)) (and (Btwn$0 ?f ?x ?y ?u) (Btwn$0 ?f ?x ?u ?z))))) :named @p_132) @p_131)) :rule forall_inst :args (next$0 root_x$0 x$0 x$0 x$0))
(step t3 (cl @p_132 @p_131) :rule or :premises (t2))
(step t4 (cl @p_131) :rule resolution :premises (t3 a29))
(step t5 (cl (! (not @p_128) :named @p_129) @p_20) :rule and_pos :args (0))
(step t6 (cl @p_20 @p_129) :rule reordering :premises (t5))
(step t7 (cl (! (not (! (or (! (= root_x$0 x$0) :named @p_26) (! (not @p_20) :named @p_25)) :named @p_27)) :named @p_121) @p_26 @p_25) :rule or_pos)
(step t8 (cl @p_26 @p_25 @p_121) :rule reordering :premises (t7))
(step t9 (cl (not (! (= (! (or (! (not (! (not (! (in$0 x$0 @p_15) :named @p_72)) :named @p_73)) :named @p_109) (! (not @p_26) :named @p_88) (! (not (! (in$0 root_x$0 @p_15) :named @p_89)) :named @p_107)) :named @p_110) (! (or @p_72 @p_88 @p_107) :named @p_108)) :named @p_119)) (not @p_110) @p_108) :rule equiv_pos2)
(step t10 (cl (! (= @p_109 @p_72) :named @p_120)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_120 1 5))
(step t11 (cl (= @p_88 @p_88)) :rule refl)
(step t12 (cl (= @p_107 @p_107)) :rule refl)
(step t13 (cl @p_119) :rule cong :premises (t10 t11 t12))
(step t14 (cl (! (=> (! (and @p_73 @p_26 @p_89) :named @p_112) false) :named @p_114) @p_112) :rule implies_neg1)
(anchor :step t15)
(assume t15.a0 @p_73)
(assume t15.a1 @p_26)
(assume t15.a2 @p_89)
(step t15.t0 (cl (not (! (= (! (= true false) :named @p_115) false) :named @p_118)) (not @p_115) false) :rule equiv_pos2)
(step t15.t1 (cl @p_118) :rule hole :args ("TRUST_THEORY_REWRITE" @p_118 1 5))
(step t15.t2 (cl (= (! (= @p_89 true) :named @p_117) @p_89)) :rule equiv_simplify)
(step t15.t3 (cl @p_117 @p_107) :rule equiv2 :premises (t15.t2))
(step t15.t4 (cl (or (! (not (forall ((BOUND_VARIABLE_557 Loc)) (in$0 BOUND_VARIABLE_557 (setenum$0 BOUND_VARIABLE_557)))) :named @p_106) @p_89)) :rule forall_inst :args (root_x$0))
(step t15.t5 (cl @p_106 @p_89) :rule or :premises (t15.t4))
(step t15.t6 (cl (not (! (= (forall ((x Loc) (y Loc)) (or (and (= x y) (in$0 x (setenum$0 y))) (and (not (= x y)) (not (in$0 x (setenum$0 y)))))) (! (and (forall ((BOUND_VARIABLE_557 Loc)) (in$0 BOUND_VARIABLE_557 (setenum$0 BOUND_VARIABLE_557))) (forall ((BOUND_VARIABLE_567 Loc) (BOUND_VARIABLE_569 Loc)) (or (and (= BOUND_VARIABLE_567 BOUND_VARIABLE_569) (in$0 BOUND_VARIABLE_567 (setenum$0 BOUND_VARIABLE_569))) (not (in$0 BOUND_VARIABLE_567 (setenum$0 BOUND_VARIABLE_569)))))) :named @p_90)) :named @p_91)) (not (forall ((x Loc) (y Loc)) (or (and (= x y) (in$0 x (setenum$0 y))) (and (not (= x y)) (not (in$0 x (setenum$0 y))))))) @p_90) :rule equiv_pos2)
(step t15.t7 (cl (! (= (forall ((x Loc) (y Loc)) (or (and (= x y) (in$0 x (setenum$0 y))) (and (not (= x y)) (not (in$0 x (setenum$0 y)))))) (forall ((x Loc) (y Loc)) (and (or (and (= x y) (in$0 x (setenum$0 y))) (not (= x y))) (or (and (= x y) (in$0 x (setenum$0 y))) (not (in$0 x (setenum$0 y))))))) :named @p_105)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_105 13 6))
(step t15.t8 (cl (! (= (forall ((x Loc) (y Loc)) (and (or (and (= x y) (in$0 x (setenum$0 y))) (not (= x y))) (or (and (= x y) (in$0 x (setenum$0 y))) (not (in$0 x (setenum$0 y)))))) (! (and (forall ((BOUND_VARIABLE_555 Loc) (BOUND_VARIABLE_557 Loc)) (or (and (= BOUND_VARIABLE_555 BOUND_VARIABLE_557) (in$0 BOUND_VARIABLE_555 (setenum$0 BOUND_VARIABLE_557))) (not (= BOUND_VARIABLE_555 BOUND_VARIABLE_557)))) (forall ((BOUND_VARIABLE_567 Loc) (BOUND_VARIABLE_569 Loc)) (or (and (= BOUND_VARIABLE_567 BOUND_VARIABLE_569) (in$0 BOUND_VARIABLE_567 (setenum$0 BOUND_VARIABLE_569))) (not (in$0 BOUND_VARIABLE_567 (setenum$0 BOUND_VARIABLE_569)))))) :named @p_92)) :named @p_104)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_104 13 6))
(step t15.t9 (cl (! (= (forall ((BOUND_VARIABLE_555 Loc) (BOUND_VARIABLE_557 Loc)) (or (and (= BOUND_VARIABLE_555 BOUND_VARIABLE_557) (in$0 BOUND_VARIABLE_555 (setenum$0 BOUND_VARIABLE_557))) (not (= BOUND_VARIABLE_555 BOUND_VARIABLE_557)))) (forall ((BOUND_VARIABLE_557 Loc)) (or (and (= BOUND_VARIABLE_557 BOUND_VARIABLE_557) (in$0 BOUND_VARIABLE_557 (setenum$0 BOUND_VARIABLE_557))) (not (= BOUND_VARIABLE_557 BOUND_VARIABLE_557))))) :named @p_103)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_103 13 6))
(anchor :step t15.t10 :args ((BOUND_VARIABLE_557 Loc) (:= (BOUND_VARIABLE_557 Loc) BOUND_VARIABLE_557)))
(step t15.t10.t0 (cl (! (= (! (= BOUND_VARIABLE_557 BOUND_VARIABLE_557) :named @p_93) true) :named @p_100)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_100 2 5))
(step t15.t10.t1 (cl (= (! (in$0 BOUND_VARIABLE_557 (setenum$0 BOUND_VARIABLE_557)) :named @p_94) @p_94)) :rule refl)
(step t15.t10.t2 (cl (= (! (and @p_93 @p_94) :named @p_96) (! (and true @p_94) :named @p_101))) :rule cong :premises (t15.t10.t0 t15.t10.t1))
(step t15.t10.t3 (cl (! (= @p_101 @p_94) :named @p_102)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_102 1 6))
(step t15.t10.t4 (cl (= @p_96 @p_94)) :rule trans :premises (t15.t10.t2 t15.t10.t3))
(step t15.t10.t5 (cl (= (! (not @p_93) :named @p_95) (! (not true) :named @p_48))) :rule cong :premises (t15.t10.t0))
(step t15.t10.t6 (cl (! (= @p_48 false) :named @p_49)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_49 1 6))
(step t15.t10.t7 (cl (= @p_95 false)) :rule trans :premises (t15.t10.t5 t15.t10.t6))
(step t15.t10.t8 (cl (= (! (or @p_96 @p_95) :named @p_97) (! (or @p_94 false) :named @p_98))) :rule cong :premises (t15.t10.t4 t15.t10.t7))
(step t15.t10.t9 (cl (! (= @p_98 @p_94) :named @p_99)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_99 1 6))
(step t15.t10.t10 (cl (= @p_97 @p_94)) :rule trans :premises (t15.t10.t8 t15.t10.t9))
(step t15.t10 (cl (= (forall ((BOUND_VARIABLE_557 Loc)) (or (and (= BOUND_VARIABLE_557 BOUND_VARIABLE_557) (in$0 BOUND_VARIABLE_557 (setenum$0 BOUND_VARIABLE_557))) (not (= BOUND_VARIABLE_557 BOUND_VARIABLE_557)))) (forall ((BOUND_VARIABLE_557 Loc)) (in$0 BOUND_VARIABLE_557 (setenum$0 BOUND_VARIABLE_557))))) :rule bind)
(step t15.t11 (cl (= (forall ((BOUND_VARIABLE_555 Loc) (BOUND_VARIABLE_557 Loc)) (or (and (= BOUND_VARIABLE_555 BOUND_VARIABLE_557) (in$0 BOUND_VARIABLE_555 (setenum$0 BOUND_VARIABLE_557))) (not (= BOUND_VARIABLE_555 BOUND_VARIABLE_557)))) (forall ((BOUND_VARIABLE_557 Loc)) (in$0 BOUND_VARIABLE_557 (setenum$0 BOUND_VARIABLE_557))))) :rule trans :premises (t15.t9 t15.t10))
(step t15.t12 (cl (= (forall ((BOUND_VARIABLE_567 Loc) (BOUND_VARIABLE_569 Loc)) (or (and (= BOUND_VARIABLE_567 BOUND_VARIABLE_569) (in$0 BOUND_VARIABLE_567 (setenum$0 BOUND_VARIABLE_569))) (not (in$0 BOUND_VARIABLE_567 (setenum$0 BOUND_VARIABLE_569))))) (forall ((BOUND_VARIABLE_567 Loc) (BOUND_VARIABLE_569 Loc)) (or (and (= BOUND_VARIABLE_567 BOUND_VARIABLE_569) (in$0 BOUND_VARIABLE_567 (setenum$0 BOUND_VARIABLE_569))) (not (in$0 BOUND_VARIABLE_567 (setenum$0 BOUND_VARIABLE_569))))))) :rule refl)
(step t15.t13 (cl (= @p_92 @p_90)) :rule cong :premises (t15.t11 t15.t12))
(step t15.t14 (cl (= (forall ((x Loc) (y Loc)) (and (or (and (= x y) (in$0 x (setenum$0 y))) (not (= x y))) (or (and (= x y) (in$0 x (setenum$0 y))) (not (in$0 x (setenum$0 y)))))) @p_90)) :rule trans :premises (t15.t8 t15.t13))
(step t15.t15 (cl @p_91) :rule trans :premises (t15.t7 t15.t14))
(step t15.t16 (cl @p_90) :rule resolution :premises (t15.t6 t15.t15 a1))
(step t15.t17 (cl (forall ((BOUND_VARIABLE_557 Loc)) (in$0 BOUND_VARIABLE_557 (setenum$0 BOUND_VARIABLE_557)))) :rule and :premises (t15.t16) :args (0))
(step t15.t18 (cl @p_89) :rule resolution :premises (t15.t5 t15.t17))
(step t15.t19 (cl @p_117) :rule resolution :premises (t15.t3 t15.t18))
(step t15.t20 (cl (= true @p_89)) :rule symm :premises (t15.t19))
(step t15.t21 (cl (= x$0 root_x$0)) :rule symm :premises (t15.a1))
(step t15.t22 (cl @p_26) :rule symm :premises (t15.t21))
(step t15.t23 (cl (= @p_15 @p_15)) :rule refl)
(step t15.t24 (cl (= @p_89 @p_72)) :rule cong :premises (t15.t22 t15.t23))
(step t15.t25 (cl (= (! (= @p_72 false) :named @p_116) @p_73)) :rule equiv_simplify)
(step t15.t26 (cl @p_116 @p_109) :rule equiv2 :premises (t15.t25))
(step t15.t27 (cl (! (not @p_109) :named @p_111) @p_72) :rule not_not)
(step t15.t28 (cl @p_116 @p_72) :rule resolution :premises (t15.t26 t15.t27))
(step t15.t29 (cl (! (not (! (and (! (not (! (in$0 x$0 @p_4) :named @p_28)) :named @p_29) @p_73 (! (not (! (in$0 x$0 (! (union$0 @p_4 @p_15) :named @p_69)) :named @p_70)) :named @p_71)) :named @p_74)) :named @p_85) @p_73) :rule and_pos :args (1))
(step t15.t30 (cl @p_73 @p_85) :rule reordering :premises (t15.t29))
(step t15.t31 (cl (! (not (! (or (! (and @p_70 (or @p_28 @p_72)) :named @p_75) @p_74) :named @p_76)) :named @p_84) @p_75 @p_74) :rule or_pos)
(step t15.t32 (cl @p_75 @p_74 @p_84) :rule reordering :premises (t15.t31))
(step t15.t33 (cl (! (not @p_75) :named @p_78) @p_70) :rule and_pos :args (0))
(step t15.t34 (cl @p_70 @p_78) :rule reordering :premises (t15.t33))
(step t15.t35 (cl (not (! (= @p_8 @p_71) :named @p_79)) (not @p_8) @p_71) :rule equiv_pos2)
(step t15.t36 (cl (= x$0 x$0)) :rule refl)
(step t15.t37 (cl (not (! (= (! (= FP$0 sk_?X_2$0) :named @p_82) (! (= FP$0 (! (union$0 @p_4 sk_?X_4$0) :named @p_80)) :named @p_81)) :named @p_83)) (not @p_82) @p_81) :rule equiv_pos2)
(step t15.t38 (cl (= FP$0 FP$0)) :rule refl)
(step t15.t39 (cl (= @p_1 @p_80)) :rule cong :premises (a11 a10))
(step t15.t40 (cl (= sk_?X_2$0 @p_80)) :rule trans :premises (a9 t15.t39))
(step t15.t41 (cl @p_83) :rule cong :premises (t15.t38 t15.t40))
(step t15.t42 (cl @p_82) :rule symm :premises (a21))
(step t15.t43 (cl @p_81) :rule resolution :premises (t15.t37 t15.t41 t15.t42))
(step t15.t44 (cl (= @p_4 @p_4)) :rule refl)
(step t15.t45 (cl (= @p_80 @p_69)) :rule cong :premises (t15.t44 a22))
(step t15.t46 (cl (= FP$0 @p_69)) :rule trans :premises (t15.t43 t15.t45))
(step t15.t47 (cl (= @p_7 @p_70)) :rule cong :premises (t15.t36 t15.t46))
(step t15.t48 (cl @p_79) :rule cong :premises (t15.t47))
(step t15.t49 (cl @p_71) :rule resolution :premises (t15.t35 t15.t48 a13))
(step t15.t50 (cl @p_78) :rule resolution :premises (t15.t34 t15.t49))
(step t15.t51 (cl (or (! (not (forall ((X SetLoc) (Y SetLoc) (x Loc)) (or (and (in$0 x (union$0 X Y)) (or (in$0 x X) (in$0 x Y))) (and (not (in$0 x X)) (not (in$0 x Y)) (not (in$0 x (union$0 X Y))))))) :named @p_77) @p_76)) :rule forall_inst :args (@p_4 @p_15 x$0))
(step t15.t52 (cl @p_77 @p_76) :rule or :premises (t15.t51))
(step t15.t53 (cl @p_76) :rule resolution :premises (t15.t52 a4))
(step t15.t54 (cl @p_74) :rule resolution :premises (t15.t32 t15.t50 t15.t53))
(step t15.t55 (cl @p_73) :rule resolution :premises (t15.t30 t15.t54))
(step t15.t56 (cl @p_116) :rule resolution :premises (t15.t28 t15.t55))
(step t15.t57 (cl @p_115) :rule trans :premises (t15.t20 t15.t24 t15.t56))
(step t15.t58 (cl false) :rule resolution :premises (t15.t0 t15.t1 t15.t57))
(step t15 (cl @p_109 @p_88 @p_107 false) :rule subproof :discharge (t15.a0 t15.a1 t15.a2))
(step t16 (cl (! (not @p_112) :named @p_113) @p_73) :rule and_pos :args (0))
(step t17 (cl @p_113 @p_26) :rule and_pos :args (1))
(step t18 (cl @p_113 @p_89) :rule and_pos :args (2))
(step t19 (cl false @p_113 @p_113 @p_113) :rule resolution :premises (t15 t16 t17 t18))
(step t20 (cl @p_113 @p_113 @p_113 false) :rule reordering :premises (t19))
(step t21 (cl @p_113 false) :rule contraction :premises (t20))
(step t22 (cl @p_114 false) :rule resolution :premises (t14 t21))
(step t23 (cl @p_114 (not false)) :rule implies_neg2)
(step t24 (cl @p_114 @p_114) :rule resolution :premises (t22 t23))
(step t25 (cl @p_114) :rule contraction :premises (t24))
(step t26 (cl (= @p_114 @p_113)) :rule implies_simplify)
(step t27 (cl (not @p_114) @p_113) :rule equiv1 :premises (t26))
(step t28 (cl @p_113) :rule resolution :premises (t25 t27))
(step t29 (cl @p_109 @p_88 @p_107) :rule not_and :premises (t28))
(step t30 (cl @p_110 @p_111) :rule or_neg :args (0))
(step t31 (cl @p_110 (not @p_88)) :rule or_neg :args (1))
(step t32 (cl @p_110 (not @p_107)) :rule or_neg :args (2))
(step t33 (cl @p_110 @p_110 @p_110) :rule resolution :premises (t29 t30 t31 t32))
(step t34 (cl @p_110) :rule contraction :premises (t33))
(step t35 (cl @p_108) :rule resolution :premises (t9 t13 t34))
(step t36 (cl @p_72 @p_88 @p_107) :rule or :premises (t35))
(step t37 (cl @p_72 @p_107 @p_88) :rule reordering :premises (t36))
(step t38 (cl @p_85 @p_73) :rule and_pos :args (1))
(step t39 (cl @p_73 @p_85) :rule reordering :premises (t38))
(step t40 (cl @p_84 @p_75 @p_74) :rule or_pos)
(step t41 (cl @p_75 @p_74 @p_84) :rule reordering :premises (t40))
(step t42 (cl @p_78 @p_70) :rule and_pos :args (0))
(step t43 (cl @p_70 @p_78) :rule reordering :premises (t42))
(step t44 (cl (not @p_79) (not @p_8) @p_71) :rule equiv_pos2)
(step t45 (cl (= x$0 x$0)) :rule refl)
(step t46 (cl (not @p_83) (not @p_82) @p_81) :rule equiv_pos2)
(step t47 (cl (= FP$0 FP$0)) :rule refl)
(step t48 (cl (= @p_1 @p_80)) :rule cong :premises (a11 a10))
(step t49 (cl (= sk_?X_2$0 @p_80)) :rule trans :premises (a9 t48))
(step t50 (cl @p_83) :rule cong :premises (t47 t49))
(step t51 (cl @p_82) :rule symm :premises (a21))
(step t52 (cl @p_81) :rule resolution :premises (t46 t50 t51))
(step t53 (cl (= @p_4 @p_4)) :rule refl)
(step t54 (cl (= @p_80 @p_69)) :rule cong :premises (t53 a22))
(step t55 (cl (= FP$0 @p_69)) :rule trans :premises (t52 t54))
(step t56 (cl (= @p_7 @p_70)) :rule cong :premises (t45 t55))
(step t57 (cl @p_79) :rule cong :premises (t56))
(step t58 (cl @p_71) :rule resolution :premises (t44 t57 a13))
(step t59 (cl @p_78) :rule resolution :premises (t43 t58))
(step t60 (cl (or @p_77 @p_76)) :rule forall_inst :args (@p_4 @p_15 x$0))
(step t61 (cl @p_77 @p_76) :rule or :premises (t60))
(step t62 (cl @p_76) :rule resolution :premises (t61 a4))
(step t63 (cl @p_74) :rule resolution :premises (t41 t59 t62))
(step t64 (cl @p_73) :rule resolution :premises (t39 t63))
(step t65 (cl (or @p_106 @p_89)) :rule forall_inst :args (root_x$0))
(step t66 (cl @p_106 @p_89) :rule or :premises (t65))
(step t67 (cl (not @p_91) (not (forall ((x Loc) (y Loc)) (or (and (= x y) (in$0 x (setenum$0 y))) (and (not (= x y)) (not (in$0 x (setenum$0 y))))))) @p_90) :rule equiv_pos2)
(step t68 (cl @p_105) :rule hole :args ("TRUST_THEORY_REWRITE" @p_105 13 6))
(step t69 (cl @p_104) :rule hole :args ("TRUST_THEORY_REWRITE" @p_104 13 6))
(step t70 (cl @p_103) :rule hole :args ("TRUST_THEORY_REWRITE" @p_103 13 6))
(anchor :step t71 :args ((BOUND_VARIABLE_557 Loc) (:= (BOUND_VARIABLE_557 Loc) BOUND_VARIABLE_557)))
(step t71.t0 (cl @p_100) :rule hole :args ("TRUST_THEORY_REWRITE" @p_100 2 5))
(step t71.t1 (cl (= @p_94 @p_94)) :rule refl)
(step t71.t2 (cl (= @p_96 @p_101)) :rule cong :premises (t71.t0 t71.t1))
(step t71.t3 (cl @p_102) :rule hole :args ("TRUST_THEORY_REWRITE" @p_102 1 6))
(step t71.t4 (cl (= @p_96 @p_94)) :rule trans :premises (t71.t2 t71.t3))
(step t71.t5 (cl (= @p_95 @p_48)) :rule cong :premises (t71.t0))
(step t71.t6 (cl @p_49) :rule hole :args ("TRUST_THEORY_REWRITE" @p_49 1 6))
(step t71.t7 (cl (= @p_95 false)) :rule trans :premises (t71.t5 t71.t6))
(step t71.t8 (cl (= @p_97 @p_98)) :rule cong :premises (t71.t4 t71.t7))
(step t71.t9 (cl @p_99) :rule hole :args ("TRUST_THEORY_REWRITE" @p_99 1 6))
(step t71.t10 (cl (= @p_97 @p_94)) :rule trans :premises (t71.t8 t71.t9))
(step t71 (cl (= (forall ((BOUND_VARIABLE_557 Loc)) (or (and (= BOUND_VARIABLE_557 BOUND_VARIABLE_557) (in$0 BOUND_VARIABLE_557 (setenum$0 BOUND_VARIABLE_557))) (not (= BOUND_VARIABLE_557 BOUND_VARIABLE_557)))) (forall ((BOUND_VARIABLE_557 Loc)) (in$0 BOUND_VARIABLE_557 (setenum$0 BOUND_VARIABLE_557))))) :rule bind)
(step t72 (cl (= (forall ((BOUND_VARIABLE_555 Loc) (BOUND_VARIABLE_557 Loc)) (or (and (= BOUND_VARIABLE_555 BOUND_VARIABLE_557) (in$0 BOUND_VARIABLE_555 (setenum$0 BOUND_VARIABLE_557))) (not (= BOUND_VARIABLE_555 BOUND_VARIABLE_557)))) (forall ((BOUND_VARIABLE_557 Loc)) (in$0 BOUND_VARIABLE_557 (setenum$0 BOUND_VARIABLE_557))))) :rule trans :premises (t70 t71))
(step t73 (cl (= (forall ((BOUND_VARIABLE_567 Loc) (BOUND_VARIABLE_569 Loc)) (or (and (= BOUND_VARIABLE_567 BOUND_VARIABLE_569) (in$0 BOUND_VARIABLE_567 (setenum$0 BOUND_VARIABLE_569))) (not (in$0 BOUND_VARIABLE_567 (setenum$0 BOUND_VARIABLE_569))))) (forall ((BOUND_VARIABLE_567 Loc) (BOUND_VARIABLE_569 Loc)) (or (and (= BOUND_VARIABLE_567 BOUND_VARIABLE_569) (in$0 BOUND_VARIABLE_567 (setenum$0 BOUND_VARIABLE_569))) (not (in$0 BOUND_VARIABLE_567 (setenum$0 BOUND_VARIABLE_569))))))) :rule refl)
(step t74 (cl (= @p_92 @p_90)) :rule cong :premises (t72 t73))
(step t75 (cl (= (forall ((x Loc) (y Loc)) (and (or (and (= x y) (in$0 x (setenum$0 y))) (not (= x y))) (or (and (= x y) (in$0 x (setenum$0 y))) (not (in$0 x (setenum$0 y)))))) @p_90)) :rule trans :premises (t69 t74))
(step t76 (cl @p_91) :rule trans :premises (t68 t75))
(step t77 (cl @p_90) :rule resolution :premises (t67 t76 a1))
(step t78 (cl (forall ((BOUND_VARIABLE_557 Loc)) (in$0 BOUND_VARIABLE_557 (setenum$0 BOUND_VARIABLE_557)))) :rule and :premises (t77) :args (0))
(step t79 (cl @p_89) :rule resolution :premises (t66 t78))
(step t80 (cl @p_88) :rule resolution :premises (t37 t64 t79))
(step t81 (cl (! (not (! (and @p_27 @p_29) :named @p_30)) :named @p_87) @p_27) :rule and_pos :args (0))
(step t82 (cl @p_27 @p_87) :rule reordering :premises (t81))
(step t83 (cl (! (not (! (or @p_28 @p_30) :named @p_31)) :named @p_86) @p_28 @p_30) :rule or_pos)
(step t84 (cl @p_28 @p_30 @p_86) :rule reordering :premises (t83))
(step t85 (cl @p_85 @p_29) :rule and_pos :args (0))
(step t86 (cl @p_29 @p_85) :rule reordering :premises (t85))
(step t87 (cl @p_29) :rule resolution :premises (t86 t63))
(step t88 (cl (or (! (not (forall ((BOUND_VARIABLE_618 Loc)) (or (in$0 BOUND_VARIABLE_618 (lseg_set_domain$0 next$0 x$0 root_x$0)) (and (or (= root_x$0 BOUND_VARIABLE_618) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_618 root_x$0))) (not (in$0 BOUND_VARIABLE_618 (lseg_set_domain$0 next$0 x$0 root_x$0))))))) :named @p_68) @p_31)) :rule forall_inst :args (x$0))
(step t89 (cl @p_68 @p_31) :rule or :premises (t88))
(step t90 (cl (not (! (= (forall ((l1 Loc)) (or (and (Btwn$0 next$0 x$0 l1 root_x$0) (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)) (not (= l1 root_x$0))) (and (or (= l1 root_x$0) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)))))) (! (and (forall ((BOUND_VARIABLE_606 Loc)) (or (Btwn$0 next$0 x$0 BOUND_VARIABLE_606 root_x$0) (and (or (= root_x$0 BOUND_VARIABLE_606) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_606 root_x$0))) (not (in$0 BOUND_VARIABLE_606 (lseg_set_domain$0 next$0 x$0 root_x$0)))))) (forall ((BOUND_VARIABLE_618 Loc)) (or (in$0 BOUND_VARIABLE_618 (lseg_set_domain$0 next$0 x$0 root_x$0)) (and (or (= root_x$0 BOUND_VARIABLE_618) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_618 root_x$0))) (not (in$0 BOUND_VARIABLE_618 (lseg_set_domain$0 next$0 x$0 root_x$0)))))) (! (not (in$0 root_x$0 @p_4)) :named @p_32)) :named @p_33)) :named @p_34)) (not (forall ((l1 Loc)) (or (and (Btwn$0 next$0 x$0 l1 root_x$0) (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)) (not (= l1 root_x$0))) (and (or (= l1 root_x$0) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0))))))) @p_33) :rule equiv_pos2)
(anchor :step t91 :args ((l1 Loc) (:= (l1 Loc) l1)))
(step t91.t0 (cl (= (! (Btwn$0 next$0 x$0 l1 root_x$0) :named @p_55) @p_55)) :rule refl)
(step t91.t1 (cl (= (! (in$0 l1 @p_4) :named @p_53) @p_53)) :rule refl)
(step t91.t2 (cl (! (= (! (= l1 root_x$0) :named @p_62) (! (= root_x$0 l1) :named @p_57)) :named @p_67)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_67 2 6))
(step t91.t3 (cl (= (! (not @p_62) :named @p_65) (! (not @p_57) :named @p_60))) :rule cong :premises (t91.t2))
(step t91.t4 (cl (= (! (and @p_55 @p_53 @p_65) :named @p_66) (! (and @p_55 @p_53 @p_60) :named @p_61))) :rule cong :premises (t91.t0 t91.t1 t91.t3))
(step t91.t5 (cl (= (! (not @p_55) :named @p_56) @p_56)) :rule refl)
(step t91.t6 (cl (= (! (or @p_62 @p_56) :named @p_63) (! (or @p_57 @p_56) :named @p_58))) :rule cong :premises (t91.t2 t91.t5))
(step t91.t7 (cl (= (! (not @p_53) :named @p_54) @p_54)) :rule refl)
(step t91.t8 (cl (= (! (and @p_63 @p_54) :named @p_64) (! (and @p_58 @p_54) :named @p_59))) :rule cong :premises (t91.t6 t91.t7))
(step t91.t9 (cl (= (or @p_66 @p_64) (or @p_61 @p_59))) :rule cong :premises (t91.t4 t91.t8))
(step t91 (cl (= (forall ((l1 Loc)) (or (and (Btwn$0 next$0 x$0 l1 root_x$0) (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)) (not (= l1 root_x$0))) (and (or (= l1 root_x$0) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)))))) (forall ((l1 Loc)) (or (and (Btwn$0 next$0 x$0 l1 root_x$0) (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)) (not (= root_x$0 l1))) (and (or (= root_x$0 l1) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)))))))) :rule bind)
(step t92 (cl (! (= (forall ((l1 Loc)) (or (and (Btwn$0 next$0 x$0 l1 root_x$0) (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)) (not (= root_x$0 l1))) (and (or (= root_x$0 l1) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)))))) (forall ((l1 Loc)) (and (or (Btwn$0 next$0 x$0 l1 root_x$0) (and (or (= root_x$0 l1) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0))))) (or (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)) (and (or (= root_x$0 l1) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0))))) (or (not (= root_x$0 l1)) (and (or (= root_x$0 l1) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)))))))) :named @p_52)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_52 13 6))
(step t93 (cl (! (= (forall ((l1 Loc)) (and (or (Btwn$0 next$0 x$0 l1 root_x$0) (and (or (= root_x$0 l1) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0))))) (or (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)) (and (or (= root_x$0 l1) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0))))) (or (not (= root_x$0 l1)) (and (or (= root_x$0 l1) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0))))))) (! (and (forall ((BOUND_VARIABLE_606 Loc)) (or (Btwn$0 next$0 x$0 BOUND_VARIABLE_606 root_x$0) (and (or (= root_x$0 BOUND_VARIABLE_606) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_606 root_x$0))) (not (in$0 BOUND_VARIABLE_606 (lseg_set_domain$0 next$0 x$0 root_x$0)))))) (forall ((BOUND_VARIABLE_618 Loc)) (or (in$0 BOUND_VARIABLE_618 (lseg_set_domain$0 next$0 x$0 root_x$0)) (and (or (= root_x$0 BOUND_VARIABLE_618) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_618 root_x$0))) (not (in$0 BOUND_VARIABLE_618 (lseg_set_domain$0 next$0 x$0 root_x$0)))))) (forall ((BOUND_VARIABLE_630 Loc)) (or (not (= root_x$0 BOUND_VARIABLE_630)) (and (or (= root_x$0 BOUND_VARIABLE_630) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_630 root_x$0))) (not (in$0 BOUND_VARIABLE_630 (lseg_set_domain$0 next$0 x$0 root_x$0))))))) :named @p_35)) :named @p_51)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_51 13 6))
(step t94 (cl (= (forall ((BOUND_VARIABLE_606 Loc)) (or (Btwn$0 next$0 x$0 BOUND_VARIABLE_606 root_x$0) (and (or (= root_x$0 BOUND_VARIABLE_606) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_606 root_x$0))) (not (in$0 BOUND_VARIABLE_606 (lseg_set_domain$0 next$0 x$0 root_x$0)))))) (forall ((BOUND_VARIABLE_606 Loc)) (or (Btwn$0 next$0 x$0 BOUND_VARIABLE_606 root_x$0) (and (or (= root_x$0 BOUND_VARIABLE_606) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_606 root_x$0))) (not (in$0 BOUND_VARIABLE_606 (lseg_set_domain$0 next$0 x$0 root_x$0)))))))) :rule refl)
(step t95 (cl (= (forall ((BOUND_VARIABLE_618 Loc)) (or (in$0 BOUND_VARIABLE_618 (lseg_set_domain$0 next$0 x$0 root_x$0)) (and (or (= root_x$0 BOUND_VARIABLE_618) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_618 root_x$0))) (not (in$0 BOUND_VARIABLE_618 (lseg_set_domain$0 next$0 x$0 root_x$0)))))) (forall ((BOUND_VARIABLE_618 Loc)) (or (in$0 BOUND_VARIABLE_618 (lseg_set_domain$0 next$0 x$0 root_x$0)) (and (or (= root_x$0 BOUND_VARIABLE_618) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_618 root_x$0))) (not (in$0 BOUND_VARIABLE_618 (lseg_set_domain$0 next$0 x$0 root_x$0)))))))) :rule refl)
(step t96 (cl (! (= (forall ((BOUND_VARIABLE_630 Loc)) (or (not (= root_x$0 BOUND_VARIABLE_630)) (and (or (= root_x$0 BOUND_VARIABLE_630) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_630 root_x$0))) (not (in$0 BOUND_VARIABLE_630 (lseg_set_domain$0 next$0 x$0 root_x$0)))))) (! (or (! (not (! (= root_x$0 root_x$0) :named @p_36)) :named @p_39) (! (and (! (or (! (= root_x$0 root_x$0) :named @p_36) (! (not @p_10) :named @p_21)) :named @p_37) @p_32) :named @p_38)) :named @p_40)) :named @p_50)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_50 13 6))
(step t97 (cl (! (= @p_36 true) :named @p_47)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_47 2 5))
(step t98 (cl (= @p_39 @p_48)) :rule cong :premises (t97))
(step t99 (cl @p_49) :rule hole :args ("TRUST_THEORY_REWRITE" @p_49 1 6))
(step t100 (cl (= @p_39 false)) :rule trans :premises (t98 t99))
(step t101 (cl (= @p_21 @p_21)) :rule refl)
(step t102 (cl (= @p_37 (! (or true @p_21) :named @p_45))) :rule cong :premises (t97 t101))
(step t103 (cl (! (= @p_45 true) :named @p_46)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_46 1 6))
(step t104 (cl (= @p_37 true)) :rule trans :premises (t102 t103))
(step t105 (cl (= @p_32 @p_32)) :rule refl)
(step t106 (cl (= @p_38 (! (and true @p_32) :named @p_43))) :rule cong :premises (t104 t105))
(step t107 (cl (! (= @p_43 @p_32) :named @p_44)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_44 1 6))
(step t108 (cl (= @p_38 @p_32)) :rule trans :premises (t106 t107))
(step t109 (cl (= @p_40 (! (or false @p_32) :named @p_41))) :rule cong :premises (t100 t108))
(step t110 (cl (! (= @p_41 @p_32) :named @p_42)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_42 1 6))
(step t111 (cl (= @p_40 @p_32)) :rule trans :premises (t109 t110))
(step t112 (cl (= (forall ((BOUND_VARIABLE_630 Loc)) (or (not (= root_x$0 BOUND_VARIABLE_630)) (and (or (= root_x$0 BOUND_VARIABLE_630) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_630 root_x$0))) (not (in$0 BOUND_VARIABLE_630 (lseg_set_domain$0 next$0 x$0 root_x$0)))))) @p_32)) :rule trans :premises (t96 t111))
(step t113 (cl (= @p_35 @p_33)) :rule cong :premises (t94 t95 t112))
(step t114 (cl (= (forall ((l1 Loc)) (and (or (Btwn$0 next$0 x$0 l1 root_x$0) (and (or (= root_x$0 l1) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0))))) (or (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)) (and (or (= root_x$0 l1) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0))))) (or (not (= root_x$0 l1)) (and (or (= root_x$0 l1) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0))))))) @p_33)) :rule trans :premises (t93 t113))
(step t115 (cl (= (forall ((l1 Loc)) (or (and (Btwn$0 next$0 x$0 l1 root_x$0) (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)) (not (= root_x$0 l1))) (and (or (= root_x$0 l1) (not (Btwn$0 next$0 x$0 l1 root_x$0))) (not (in$0 l1 (lseg_set_domain$0 next$0 x$0 root_x$0)))))) @p_33)) :rule trans :premises (t92 t114))
(step t116 (cl @p_34) :rule trans :premises (t91 t115))
(step t117 (cl @p_33) :rule resolution :premises (t90 t116 a14))
(step t118 (cl (forall ((BOUND_VARIABLE_618 Loc)) (or (in$0 BOUND_VARIABLE_618 (lseg_set_domain$0 next$0 x$0 root_x$0)) (and (or (= root_x$0 BOUND_VARIABLE_618) (not (Btwn$0 next$0 x$0 BOUND_VARIABLE_618 root_x$0))) (not (in$0 BOUND_VARIABLE_618 (lseg_set_domain$0 next$0 x$0 root_x$0))))))) :rule and :premises (t117) :args (1))
(step t119 (cl @p_31) :rule resolution :premises (t89 t118))
(step t120 (cl @p_30) :rule resolution :premises (t84 t87 t119))
(step t121 (cl @p_27) :rule resolution :premises (t82 t120))
(step t122 (cl @p_25) :rule resolution :premises (t8 t80 t121))
(step t123 (cl @p_129) :rule resolution :premises (t6 t122))
(step t124 (cl (! (not (! (or @p_22 @p_21 @p_20 @p_19) :named @p_23)) :named @p_127) @p_22 @p_21 @p_20 @p_19) :rule or_pos)
(step t125 (cl @p_21 @p_20 @p_22 @p_19 @p_127) :rule reordering :premises (t124))
(step t126 (cl (not (! (= @p_11 (! (or @p_10 (! (not (! (lseg_set_struct$0 @p_4 next$0 x$0 root_x$0 @p_12) :named @p_122)) :named @p_124)) :named @p_125)) :named @p_126)) (not @p_11) @p_125) :rule equiv_pos2)
(step t127 (cl (= @p_10 @p_10)) :rule refl)
(step t128 (cl (= next$0 next$0)) :rule refl)
(step t129 (cl @p_36) :rule refl)
(step t130 (cl (! (= @p_6 @p_122) :named @p_123)) :rule cong :premises (a11 t128 t45 t129 a20))
(step t131 (cl (= @p_9 @p_124)) :rule cong :premises (t130))
(step t132 (cl @p_126) :rule cong :premises (t127 t131))
(step t133 (cl @p_125) :rule resolution :premises (t126 t132 a17))
(step t134 (cl @p_10 @p_124) :rule or :premises (t133))
(step t135 (cl (not @p_123) @p_9 @p_122) :rule equiv_pos2)
(step t136 (cl @p_122) :rule resolution :premises (t135 t130 a12))
(step t137 (cl @p_10) :rule resolution :premises (t134 t136))
(step t138 (cl (or (! (not (forall ((?f FldLoc) (?x Loc)) (Btwn$0 ?f ?x ?x ?x))) :named @p_18) @p_17)) :rule forall_inst :args (next$0 x$0))
(step t139 (cl @p_18 @p_17) :rule or :premises (t138))
(step t140 (cl @p_17) :rule resolution :premises (t139 a37))
(step t141 (cl (or (! (not (forall ((?f FldLoc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 ?f ?x ?y ?y)) (not (Btwn$0 ?f ?x ?z ?z)) (Btwn$0 ?f ?x ?y ?z) (Btwn$0 ?f ?x ?z ?y)))) :named @p_24) @p_23)) :rule forall_inst :args (next$0 x$0 x$0 root_x$0))
(step t142 (cl @p_24 @p_23) :rule or :premises (t141))
(step t143 (cl @p_23) :rule resolution :premises (t142 a32))
(step t144 (cl @p_19) :rule resolution :premises (t125 t137 t122 t140 t143))
(step t145 (cl) :rule resolution :premises (t1 t4 t123 t144 t140))
