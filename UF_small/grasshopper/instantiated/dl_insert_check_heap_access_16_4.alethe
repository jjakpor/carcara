unsat
(assume a0 (forall ((?y Loc)) (or (not (Btwn$0 next$0 elt$0 ?y ?y)) (= elt$0 ?y) (Btwn$0 next$0 elt$0 (read$0 next$0 elt$0) ?y))))
(assume a1 (forall ((?y Loc)) (or (not (Btwn$0 next$0 null$0 ?y ?y)) (= null$0 ?y) (Btwn$0 next$0 null$0 (read$0 next$0 null$0) ?y))))
(assume a2 (forall ((?y Loc)) (or (not (Btwn$0 next$0 b$0 ?y ?y)) (= b$0 ?y) (Btwn$0 next$0 b$0 (read$0 next$0 b$0) ?y))))
(assume a3 (forall ((?y Loc)) (or (not (= (read$0 next$0 elt$0) elt$0)) (not (Btwn$0 next$0 elt$0 ?y ?y)) (= elt$0 ?y))))
(assume a4 (forall ((?y Loc)) (or (not (= (read$0 next$0 null$0) null$0)) (not (Btwn$0 next$0 null$0 ?y ?y)) (= null$0 ?y))))
(assume a5 (forall ((?y Loc)) (or (not (= (read$0 next$0 b$0) b$0)) (not (Btwn$0 next$0 b$0 ?y ?y)) (= b$0 ?y))))
(assume a6 (Btwn$0 next$0 elt$0 (! (read$0 next$0 elt$0) :named @p_1) @p_1))
(assume a7 (Btwn$0 next$0 null$0 (! (read$0 next$0 null$0) :named @p_2) @p_2))
(assume a8 (Btwn$0 next$0 b$0 (! (read$0 next$0 b$0) :named @p_3) @p_3))
(assume a9 (or (! (not Axiom$0) :named @p_7) (or (= (! (read$0 prev$0 null$0) :named @p_6) elt$0) (not (! (= @p_1 null$0) :named @p_5)) (not (in$0 elt$0 sk_?X_3$0)) (! (not (in$0 null$0 sk_?X_3$0)) :named @p_4))))
(assume a10 (or @p_7 (or (! (= @p_6 null$0) :named @p_9) (not (! (= @p_2 null$0) :named @p_8)) @p_4 @p_4)))
(assume a11 (or @p_7 (or (= @p_6 b$0) (not (! (= @p_3 null$0) :named @p_11)) (not (! (in$0 b$0 sk_?X_3$0) :named @p_10)) @p_4)))
(assume a12 (forall ((x Loc)) (or (and (in$0 x (union$0 FP_Caller$0 Alloc$0)) (or (in$0 x FP_Caller$0) (in$0 x Alloc$0))) (and (not (in$0 x FP_Caller$0)) (not (in$0 x Alloc$0)) (not (in$0 x (union$0 FP_Caller$0 Alloc$0)))))))
(assume a13 (forall ((x Loc)) (or (and (in$0 x (union$0 sk_?X_3$0 sk_?X_1$0)) (or (in$0 x sk_?X_3$0) (in$0 x sk_?X_1$0))) (and (not (in$0 x sk_?X_3$0)) (not (in$0 x sk_?X_1$0)) (not (in$0 x (union$0 sk_?X_3$0 sk_?X_1$0)))))))
(assume a14 (forall ((x Loc)) (or (and (in$0 x (union$0 FP$0 FP_Caller$0)) (or (in$0 x FP$0) (in$0 x FP_Caller$0))) (and (not (in$0 x FP$0)) (not (in$0 x FP_Caller$0)) (not (in$0 x (union$0 FP$0 FP_Caller$0)))))))
(assume a15 (forall ((x Loc)) (or (and (in$0 x sk_?X_3$0) (in$0 x sk_?X_1$0) (in$0 x (intersection$0 sk_?X_3$0 sk_?X_1$0))) (and (or (not (in$0 x sk_?X_3$0)) (not (in$0 x sk_?X_1$0))) (not (in$0 x (intersection$0 sk_?X_3$0 sk_?X_1$0)))))))
(assume a16 (forall ((x Loc)) (or (and (in$0 x FP_Caller$0) (in$0 x (setminus$0 FP_Caller$0 FP$0)) (not (in$0 x FP$0))) (and (or (in$0 x FP$0) (not (in$0 x FP_Caller$0))) (not (in$0 x (setminus$0 FP_Caller$0 FP$0)))))))
(assume a17 (forall ((y Loc) (x Loc)) (or (and (= x y) (in$0 x (setenum$0 y))) (and (not (= x y)) (not (in$0 x (setenum$0 y)))))))
(assume a18 @p_8)
(assume a19 @p_9)
(assume a20 (forall ((x Loc)) (not (in$0 x emptyset$0))))
(assume a21 (= FP_Caller_1$0 (setminus$0 FP_Caller$0 FP$0)))
(assume a22 (= Alloc$0 (union$0 FP_Caller$0 Alloc$0)))
(assume a23 (= emptyset$0 emptyset$0))
(assume a24 (! (= sk_?X$0 (! (union$0 sk_?X_3$0 sk_?X_1$0) :named @p_12)) :named @p_13))
(assume a25 (! (= sk_?X_1$0 sk_?X_2$0) :named @p_14))
(assume a26 (! (= sk_?X_3$0 (! (dlseg_domain$0 next$0 prev$0 a$0 null$0 null$0 b$0) :named @p_15)) :named @p_16))
(assume a27 (! (dlseg_struct$0 sk_?X_3$0 next$0 prev$0 a$0 null$0 null$0 b$0) :named @p_17))
(assume a28 (! (not (! (in$0 elt$0 FP$0) :named @p_18)) :named @p_19))
(assume a29 (or (and (Btwn$0 next$0 a$0 null$0 null$0) (or (and (= null$0 b$0) (! (= a$0 null$0) :named @p_20)) (and @p_11 (= (read$0 prev$0 a$0) null$0) @p_10)) Axiom$0) (not @p_17)))
(assume a30 @p_20)
(assume a31 @p_5)
(assume a32 (= emptyset$0 (intersection$0 sk_?X_3$0 sk_?X_1$0)))
(assume a33 (! (= sk_?X$0 FP$0) :named @p_21))
(assume a34 (! (= sk_?X_2$0 (! (setenum$0 elt$0) :named @p_22)) :named @p_23))
(assume a35 (= FP_Caller$0 (union$0 FP$0 FP_Caller$0)))
(assume a36 (not (in$0 null$0 Alloc$0)))
(assume a37 (forall ((l1 Loc)) (or (and (Btwn$0 next$0 a$0 l1 null$0) (in$0 l1 (dlseg_domain$0 next$0 prev$0 a$0 null$0 null$0 b$0)) (not (= l1 null$0))) (and (or (= l1 null$0) (not (Btwn$0 next$0 a$0 l1 null$0))) (not (in$0 l1 (dlseg_domain$0 next$0 prev$0 a$0 null$0 null$0 b$0)))))))
(assume a38 (forall ((?x Loc)) (Btwn$0 next$0 ?x ?x ?x)))
(assume a39 (forall ((?x Loc) (?y Loc)) (or (not (Btwn$0 next$0 ?x ?y ?x)) (= ?x ?y))))
(assume a40 (forall ((?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?y)) (not (Btwn$0 next$0 ?x ?z ?z)) (Btwn$0 next$0 ?x ?y ?z) (Btwn$0 next$0 ?x ?z ?y))))
(assume a41 (forall ((?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?z)) (and (Btwn$0 next$0 ?x ?y ?y) (Btwn$0 next$0 ?y ?z ?z)))))
(assume a42 (forall ((?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?y)) (not (Btwn$0 next$0 ?y ?z ?z)) (Btwn$0 next$0 ?x ?z ?z))))
(assume a43 (forall ((?u Loc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?z)) (not (Btwn$0 next$0 ?y ?u ?z)) (and (Btwn$0 next$0 ?x ?y ?u) (Btwn$0 next$0 ?x ?u ?z)))))
(assume a44 (forall ((?u Loc) (?x Loc) (?y Loc) (?z Loc)) (or (not (Btwn$0 next$0 ?x ?y ?z)) (not (Btwn$0 next$0 ?x ?u ?y)) (and (Btwn$0 next$0 ?x ?u ?z) (Btwn$0 next$0 ?u ?y ?z)))))
(step t0 (cl (! (not (! (and (not (! (in$0 elt$0 (! (dlseg_domain$0 next$0 prev$0 @p_1 @p_1 @p_1 b$0) :named @p_59)) :named @p_64)) (! (not (! (in$0 elt$0 @p_22) :named @p_24)) :named @p_63) (! (not (! (in$0 elt$0 (! (union$0 @p_59 @p_22) :named @p_60)) :named @p_61)) :named @p_62)) :named @p_65)) :named @p_99) @p_63) :rule and_pos :args (1))
(step t1 (cl @p_63 @p_99) :rule reordering :premises (t0))
(step t2 (cl (! (not (! (or (! (and @p_61 (or @p_64 @p_24)) :named @p_66) @p_65) :named @p_67)) :named @p_98) @p_66 @p_65) :rule or_pos)
(step t3 (cl @p_66 @p_65 @p_98) :rule reordering :premises (t2))
(step t4 (cl (! (not @p_66) :named @p_92) @p_61) :rule and_pos :args (0))
(step t5 (cl @p_61 @p_92) :rule reordering :premises (t4))
(step t6 (cl (not (! (= @p_19 @p_62) :named @p_93)) (not @p_19) @p_62) :rule equiv_pos2)
(step t7 (cl (= elt$0 elt$0)) :rule refl)
(step t8 (cl (not (! (= (! (= FP$0 sk_?X$0) :named @p_96) (! (= FP$0 (! (union$0 @p_59 sk_?X_2$0) :named @p_94)) :named @p_95)) :named @p_97)) (not @p_96) @p_95) :rule equiv_pos2)
(step t9 (cl (= FP$0 FP$0)) :rule refl)
(step t10 (cl (= next$0 next$0)) :rule refl)
(step t11 (cl (= prev$0 prev$0)) :rule refl)
(step t12 (cl (not (! (= (! (= null$0 @p_1) :named @p_88) (! (= a$0 @p_1) :named @p_89)) :named @p_90)) (not @p_88) @p_89) :rule equiv_pos2)
(step t13 (cl (= null$0 a$0)) :rule symm :premises (a30))
(step t14 (cl (= @p_1 @p_1)) :rule refl)
(step t15 (cl @p_90) :rule cong :premises (t13 t14))
(step t16 (cl @p_88) :rule symm :premises (a31))
(step t17 (cl @p_89) :rule resolution :premises (t12 t15 t16))
(step t18 (cl (= b$0 b$0)) :rule refl)
(step t19 (cl (= @p_15 @p_59)) :rule cong :premises (t10 t11 t17 t16 t16 t18))
(step t20 (cl (= sk_?X_3$0 @p_59)) :rule trans :premises (a26 t19))
(step t21 (cl (= @p_12 @p_94)) :rule cong :premises (t20 a25))
(step t22 (cl (= sk_?X$0 @p_94)) :rule trans :premises (a24 t21))
(step t23 (cl @p_97) :rule cong :premises (t9 t22))
(step t24 (cl @p_96) :rule symm :premises (a33))
(step t25 (cl @p_95) :rule resolution :premises (t8 t23 t24))
(step t26 (cl (= @p_59 @p_59)) :rule refl)
(step t27 (cl (= @p_94 @p_60)) :rule cong :premises (t26 a34))
(step t28 (cl (= FP$0 @p_60)) :rule trans :premises (t25 t27))
(step t29 (cl (= @p_18 @p_61)) :rule cong :premises (t7 t28))
(step t30 (cl @p_93) :rule cong :premises (t29))
(step t31 (cl @p_62) :rule resolution :premises (t6 t30 a28))
(step t32 (cl @p_92) :rule resolution :premises (t5 t31))
(step t33 (cl (or (! (not (forall ((x Loc)) (or (and (in$0 x (union$0 (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0) (setenum$0 elt$0))) (or (in$0 x (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0)) (in$0 x (setenum$0 elt$0)))) (and (not (in$0 x (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0))) (not (in$0 x (setenum$0 elt$0))) (not (in$0 x (union$0 (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0) (setenum$0 elt$0)))))))) :named @p_91) @p_67)) :rule forall_inst :args (elt$0))
(step t34 (cl @p_91 @p_67) :rule or :premises (t33))
(step t35 (cl (not (! (= (forall ((x Loc)) (or (and (in$0 x (union$0 sk_?X_3$0 sk_?X_1$0)) (or (in$0 x sk_?X_3$0) (in$0 x sk_?X_1$0))) (and (not (in$0 x sk_?X_3$0)) (not (in$0 x sk_?X_1$0)) (not (in$0 x (union$0 sk_?X_3$0 sk_?X_1$0)))))) (forall ((x Loc)) (or (and (in$0 x (union$0 (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0) (setenum$0 elt$0))) (or (in$0 x (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0)) (in$0 x (setenum$0 elt$0)))) (and (not (in$0 x (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0))) (not (in$0 x (setenum$0 elt$0))) (not (in$0 x (union$0 (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0) (setenum$0 elt$0)))))))) :named @p_68)) (not (forall ((x Loc)) (or (and (in$0 x (union$0 sk_?X_3$0 sk_?X_1$0)) (or (in$0 x sk_?X_3$0) (in$0 x sk_?X_1$0))) (and (not (in$0 x sk_?X_3$0)) (not (in$0 x sk_?X_1$0)) (not (in$0 x (union$0 sk_?X_3$0 sk_?X_1$0))))))) (forall ((x Loc)) (or (and (in$0 x (union$0 (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0) (setenum$0 elt$0))) (or (in$0 x (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0)) (in$0 x (setenum$0 elt$0)))) (and (not (in$0 x (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0))) (not (in$0 x (setenum$0 elt$0))) (not (in$0 x (union$0 (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0) (setenum$0 elt$0)))))))) :rule equiv_pos2)
(anchor :step t36 :args ((x Loc) (:= (x Loc) x)))
(step t36.t0 (cl (! (= x x) :named @p_69)) :rule refl)
(step t36.t1 (cl (= sk_?X_1$0 @p_22)) :rule trans :premises (a25 a34))
(step t36.t2 (cl (= @p_12 @p_60)) :rule cong :premises (t20 t36.t1))
(step t36.t3 (cl (= (! (in$0 x @p_12) :named @p_79) (! (in$0 x @p_60) :named @p_70))) :rule cong :premises (t36.t0 t36.t2))
(step t36.t4 (cl (= (! (in$0 x sk_?X_3$0) :named @p_83) (! (in$0 x @p_59) :named @p_74))) :rule cong :premises (t36.t0 t20))
(step t36.t5 (cl (= (! (in$0 x sk_?X_1$0) :named @p_81) (! (in$0 x @p_22) :named @p_72))) :rule cong :premises (t36.t0 t36.t1))
(step t36.t6 (cl (= (! (or @p_83 @p_81) :named @p_86) (! (or @p_74 @p_72) :named @p_77))) :rule cong :premises (t36.t4 t36.t5))
(step t36.t7 (cl (= (! (and @p_79 @p_86) :named @p_87) (! (and @p_70 @p_77) :named @p_78))) :rule cong :premises (t36.t3 t36.t6))
(step t36.t8 (cl (= (! (not @p_83) :named @p_84) (! (not @p_74) :named @p_75))) :rule cong :premises (t36.t4))
(step t36.t9 (cl (= (! (not @p_81) :named @p_82) (! (not @p_72) :named @p_73))) :rule cong :premises (t36.t5))
(step t36.t10 (cl (= (! (not @p_79) :named @p_80) (! (not @p_70) :named @p_71))) :rule cong :premises (t36.t3))
(step t36.t11 (cl (= (! (and @p_84 @p_82 @p_80) :named @p_85) (! (and @p_75 @p_73 @p_71) :named @p_76))) :rule cong :premises (t36.t8 t36.t9 t36.t10))
(step t36.t12 (cl (= (or @p_87 @p_85) (or @p_78 @p_76))) :rule cong :premises (t36.t7 t36.t11))
(step t36 (cl @p_68) :rule bind)
(step t37 (cl (forall ((x Loc)) (or (and (in$0 x (union$0 (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0) (setenum$0 elt$0))) (or (in$0 x (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0)) (in$0 x (setenum$0 elt$0)))) (and (not (in$0 x (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0))) (not (in$0 x (setenum$0 elt$0))) (not (in$0 x (union$0 (dlseg_domain$0 next$0 prev$0 (read$0 next$0 elt$0) (read$0 next$0 elt$0) (read$0 next$0 elt$0) b$0) (setenum$0 elt$0)))))))) :rule resolution :premises (t35 t36 a13))
(step t38 (cl @p_67) :rule resolution :premises (t34 t37))
(step t39 (cl @p_65) :rule resolution :premises (t3 t32 t38))
(step t40 (cl (or (! (not (forall ((BOUND_VARIABLE_631 Loc)) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_631)))) :named @p_58) @p_24)) :rule forall_inst :args (elt$0))
(step t41 (cl @p_58 @p_24) :rule or :premises (t40))
(step t42 (cl (not (! (= (forall ((y Loc) (x Loc)) (or (and (= x y) (in$0 x (setenum$0 y))) (and (not (= x y)) (not (in$0 x (setenum$0 y)))))) (! (and (forall ((BOUND_VARIABLE_631 Loc)) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_631))) (forall ((BOUND_VARIABLE_641 Loc) (BOUND_VARIABLE_643 Loc)) (or (and (= BOUND_VARIABLE_641 BOUND_VARIABLE_643) (in$0 BOUND_VARIABLE_643 (setenum$0 BOUND_VARIABLE_641))) (not (in$0 BOUND_VARIABLE_643 (setenum$0 BOUND_VARIABLE_641)))))) :named @p_25)) :named @p_26)) (not (forall ((y Loc) (x Loc)) (or (and (= x y) (in$0 x (setenum$0 y))) (and (not (= x y)) (not (in$0 x (setenum$0 y))))))) @p_25) :rule equiv_pos2)
(step t43 (cl (! (= (forall ((y Loc) (x Loc)) (or (and (= x y) (in$0 x (setenum$0 y))) (and (not (= x y)) (not (in$0 x (setenum$0 y)))))) (forall ((y Loc) (x Loc)) (and (or (and (= x y) (in$0 x (setenum$0 y))) (not (= x y))) (or (and (= x y) (in$0 x (setenum$0 y))) (not (in$0 x (setenum$0 y))))))) :named @p_57)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_57 13 6))
(step t44 (cl (! (= (forall ((y Loc) (x Loc)) (and (or (and (= x y) (in$0 x (setenum$0 y))) (not (= x y))) (or (and (= x y) (in$0 x (setenum$0 y))) (not (in$0 x (setenum$0 y)))))) (! (and (forall ((BOUND_VARIABLE_629 Loc) (BOUND_VARIABLE_631 Loc)) (or (and (= BOUND_VARIABLE_631 BOUND_VARIABLE_629) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_629))) (not (= BOUND_VARIABLE_631 BOUND_VARIABLE_629)))) (forall ((BOUND_VARIABLE_641 Loc) (BOUND_VARIABLE_643 Loc)) (or (and (= BOUND_VARIABLE_643 BOUND_VARIABLE_641) (in$0 BOUND_VARIABLE_643 (setenum$0 BOUND_VARIABLE_641))) (not (in$0 BOUND_VARIABLE_643 (setenum$0 BOUND_VARIABLE_641)))))) :named @p_27)) :named @p_56)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_56 13 6))
(anchor :step t45 :args ((BOUND_VARIABLE_629 Loc) (BOUND_VARIABLE_631 Loc) (:= (BOUND_VARIABLE_629 Loc) BOUND_VARIABLE_629) (:= (BOUND_VARIABLE_631 Loc) BOUND_VARIABLE_631)))
(step t45.t0 (cl (! (= (! (= BOUND_VARIABLE_631 BOUND_VARIABLE_629) :named @p_52) (! (= BOUND_VARIABLE_629 BOUND_VARIABLE_631) :named @p_48)) :named @p_55)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_55 2 6))
(step t45.t1 (cl (= (! (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_629)) :named @p_50) @p_50)) :rule refl)
(step t45.t2 (cl (= (! (and @p_52 @p_50) :named @p_54) (! (and @p_48 @p_50) :named @p_51))) :rule cong :premises (t45.t0 t45.t1))
(step t45.t3 (cl (= (! (not @p_52) :named @p_53) (! (not @p_48) :named @p_49))) :rule cong :premises (t45.t0))
(step t45.t4 (cl (= (or @p_54 @p_53) (or @p_51 @p_49))) :rule cong :premises (t45.t2 t45.t3))
(step t45 (cl (= (forall ((BOUND_VARIABLE_629 Loc) (BOUND_VARIABLE_631 Loc)) (or (and (= BOUND_VARIABLE_631 BOUND_VARIABLE_629) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_629))) (not (= BOUND_VARIABLE_631 BOUND_VARIABLE_629)))) (forall ((BOUND_VARIABLE_629 Loc) (BOUND_VARIABLE_631 Loc)) (or (and (= BOUND_VARIABLE_629 BOUND_VARIABLE_631) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_629))) (not (= BOUND_VARIABLE_629 BOUND_VARIABLE_631)))))) :rule bind)
(step t46 (cl (! (= (forall ((BOUND_VARIABLE_629 Loc) (BOUND_VARIABLE_631 Loc)) (or (and (= BOUND_VARIABLE_629 BOUND_VARIABLE_631) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_629))) (not (= BOUND_VARIABLE_629 BOUND_VARIABLE_631)))) (forall ((BOUND_VARIABLE_631 Loc)) (or (and (= BOUND_VARIABLE_631 BOUND_VARIABLE_631) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_631))) (not (= BOUND_VARIABLE_631 BOUND_VARIABLE_631))))) :named @p_47)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_47 13 6))
(anchor :step t47 :args ((BOUND_VARIABLE_631 Loc) (:= (BOUND_VARIABLE_631 Loc) BOUND_VARIABLE_631)))
(step t47.t0 (cl (! (= (! (= BOUND_VARIABLE_631 BOUND_VARIABLE_631) :named @p_35) true) :named @p_44)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_44 2 5))
(step t47.t1 (cl (= (! (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_631)) :named @p_36) @p_36)) :rule refl)
(step t47.t2 (cl (= (! (and @p_35 @p_36) :named @p_38) (! (and true @p_36) :named @p_45))) :rule cong :premises (t47.t0 t47.t1))
(step t47.t3 (cl (! (= @p_45 @p_36) :named @p_46)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_46 1 6))
(step t47.t4 (cl (= @p_38 @p_36)) :rule trans :premises (t47.t2 t47.t3))
(step t47.t5 (cl (= (! (not @p_35) :named @p_37) (! (not true) :named @p_42))) :rule cong :premises (t47.t0))
(step t47.t6 (cl (! (= @p_42 false) :named @p_43)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_43 1 6))
(step t47.t7 (cl (= @p_37 false)) :rule trans :premises (t47.t5 t47.t6))
(step t47.t8 (cl (= (! (or @p_38 @p_37) :named @p_39) (! (or @p_36 false) :named @p_40))) :rule cong :premises (t47.t4 t47.t7))
(step t47.t9 (cl (! (= @p_40 @p_36) :named @p_41)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_41 1 6))
(step t47.t10 (cl (= @p_39 @p_36)) :rule trans :premises (t47.t8 t47.t9))
(step t47 (cl (= (forall ((BOUND_VARIABLE_631 Loc)) (or (and (= BOUND_VARIABLE_631 BOUND_VARIABLE_631) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_631))) (not (= BOUND_VARIABLE_631 BOUND_VARIABLE_631)))) (forall ((BOUND_VARIABLE_631 Loc)) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_631))))) :rule bind)
(step t48 (cl (= (forall ((BOUND_VARIABLE_629 Loc) (BOUND_VARIABLE_631 Loc)) (or (and (= BOUND_VARIABLE_629 BOUND_VARIABLE_631) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_629))) (not (= BOUND_VARIABLE_629 BOUND_VARIABLE_631)))) (forall ((BOUND_VARIABLE_631 Loc)) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_631))))) :rule trans :premises (t46 t47))
(step t49 (cl (= (forall ((BOUND_VARIABLE_629 Loc) (BOUND_VARIABLE_631 Loc)) (or (and (= BOUND_VARIABLE_631 BOUND_VARIABLE_629) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_629))) (not (= BOUND_VARIABLE_631 BOUND_VARIABLE_629)))) (forall ((BOUND_VARIABLE_631 Loc)) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_631))))) :rule trans :premises (t45 t48))
(anchor :step t50 :args ((BOUND_VARIABLE_641 Loc) (BOUND_VARIABLE_643 Loc) (:= (BOUND_VARIABLE_641 Loc) BOUND_VARIABLE_641) (:= (BOUND_VARIABLE_643 Loc) BOUND_VARIABLE_643)))
(step t50.t0 (cl (! (= (! (= BOUND_VARIABLE_643 BOUND_VARIABLE_641) :named @p_32) (! (= BOUND_VARIABLE_641 BOUND_VARIABLE_643) :named @p_30)) :named @p_34)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_34 2 6))
(step t50.t1 (cl (= (! (in$0 BOUND_VARIABLE_643 (setenum$0 BOUND_VARIABLE_641)) :named @p_28) @p_28)) :rule refl)
(step t50.t2 (cl (= (! (and @p_32 @p_28) :named @p_33) (! (and @p_30 @p_28) :named @p_31))) :rule cong :premises (t50.t0 t50.t1))
(step t50.t3 (cl (= (! (not @p_28) :named @p_29) @p_29)) :rule refl)
(step t50.t4 (cl (= (or @p_33 @p_29) (or @p_31 @p_29))) :rule cong :premises (t50.t2 t50.t3))
(step t50 (cl (= (forall ((BOUND_VARIABLE_641 Loc) (BOUND_VARIABLE_643 Loc)) (or (and (= BOUND_VARIABLE_643 BOUND_VARIABLE_641) (in$0 BOUND_VARIABLE_643 (setenum$0 BOUND_VARIABLE_641))) (not (in$0 BOUND_VARIABLE_643 (setenum$0 BOUND_VARIABLE_641))))) (forall ((BOUND_VARIABLE_641 Loc) (BOUND_VARIABLE_643 Loc)) (or (and (= BOUND_VARIABLE_641 BOUND_VARIABLE_643) (in$0 BOUND_VARIABLE_643 (setenum$0 BOUND_VARIABLE_641))) (not (in$0 BOUND_VARIABLE_643 (setenum$0 BOUND_VARIABLE_641))))))) :rule bind)
(step t51 (cl (= @p_27 @p_25)) :rule cong :premises (t49 t50))
(step t52 (cl (= (forall ((y Loc) (x Loc)) (and (or (and (= x y) (in$0 x (setenum$0 y))) (not (= x y))) (or (and (= x y) (in$0 x (setenum$0 y))) (not (in$0 x (setenum$0 y)))))) @p_25)) :rule trans :premises (t44 t51))
(step t53 (cl @p_26) :rule trans :premises (t43 t52))
(step t54 (cl @p_25) :rule resolution :premises (t42 t53 a17))
(step t55 (cl (forall ((BOUND_VARIABLE_631 Loc)) (in$0 BOUND_VARIABLE_631 (setenum$0 BOUND_VARIABLE_631)))) :rule and :premises (t54) :args (0))
(step t56 (cl @p_24) :rule resolution :premises (t41 t55))
(step t57 (cl) :rule resolution :premises (t1 t39 t56))
