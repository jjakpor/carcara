(set-info :smt-lib-version 2.6)
(set-logic UF)
(set-info :source |
Generated by: Andrew Reynolds
Generated on: 2017-04-28
Generator: Sledgehammer, converted to v2.6 by CVC4
Application: Verfication goals in Isabelle
Target solver: CVC4, Z3
Publications: "A Decision Procedure for (Co)Datatypes" by Andrew Reynolds and Jasmin Blanchette, CADE 2015.
|)
(set-info :license "https://creativecommons.org/licenses/by/4.0/")
(set-info :category "industrial")
(set-info :status unsat)


(declare-sort A$ 0)
(declare-sort Nat$ 0)
(declare-sort A_a_fun$ 0)
(declare-sort Nat_nat_fun$ 0)
(declare-sort Bool_nat_fun$ 0)
(declare-sort Nat_bool_fun$ 0)
(declare-sort Enat_bool_fun$ 0)
(declare-sort Enat_enat_fun$ 0)
(declare-sort A_llist_bool_fun$ 0)
(declare-sort A_llist_enat_fun$ 0)
(declare-sort Natural_bool_fun$ 0)
(declare-sort A_a_fun_a_a_fun_fun$ 0)
(declare-sort A_llist_a_llist_fun$ 0)
(declare-sort Natural_natural_fun$ 0)
(declare-sort Nat_nat_bool_fun_fun$ 0)
(declare-sort Enat_enat_bool_fun_fun$ 0)
(declare-sort Nat_a_a_fun_a_a_fun_fun_fun$ 0)
(declare-sort Natural_natural_bool_fun_fun$ 0)
(declare-sort A_llist$ 0)
(declare-fun lNil$ () A_llist$)
(declare-fun lhd$ (A_llist$) A$)
(declare-fun ltl$ (A_llist$) A_llist$)
(declare-fun lCons$ (A$ A_llist$) A_llist$)
(declare-sort Nat_option$ 0)
(declare-sort Enat$ 0)
(declare-sort Natural$ 0)
(declare-sort Nibble$ 0)
(declare-sort Char$ 0)
(declare-sort Char_list$ 0)
(declare-sort Literal$ 0)
(declare-fun none$ () Nat_option$)
(declare-fun the$ (Nat_option$) Nat$)
(declare-fun some$ (Nat$) Nat_option$)
(declare-fun rep_enat$ (Enat$) Nat_option$)
(declare-fun abs_enat$ (Nat_option$) Enat$)
(declare-fun nat_of_natural$ (Natural$) Nat$)
(declare-fun natural_of_nat$ (Nat$) Natural$)
(declare-fun nibble0$ () Nibble$)
(declare-fun nibble1$ () Nibble$)
(declare-fun nibble2$ () Nibble$)
(declare-fun nibble3$ () Nibble$)
(declare-fun nibble4$ () Nibble$)
(declare-fun nibble5$ () Nibble$)
(declare-fun nibble6$ () Nibble$)
(declare-fun nibble7$ () Nibble$)
(declare-fun nibble8$ () Nibble$)
(declare-fun nibble9$ () Nibble$)
(declare-fun nibbleA$ () Nibble$)
(declare-fun nibbleB$ () Nibble$)
(declare-fun nibbleC$ () Nibble$)
(declare-fun nibbleD$ () Nibble$)
(declare-fun nibbleE$ () Nibble$)
(declare-fun nibbleF$ () Nibble$)
(declare-fun select$ (Char$) Nibble$)
(declare-fun selecta$ (Char$) Nibble$)
(declare-fun char$ (Nibble$ Nibble$) Char$)
(declare-fun nil$ () Char_list$)
(declare-fun hd$ (Char_list$) Char$)
(declare-fun tl$ (Char_list$) Char_list$)
(declare-fun cons$ (Char$ Char_list$) Char_list$)
(declare-fun explode$ (Literal$) Char_list$)
(declare-fun str$ (Char_list$) Literal$)
(declare-fun f$ () A_a_fun$)
(declare-fun n$ () Nat$)
(declare-fun x$ () A$)
(declare-fun enat$ (Nat$) Enat$)
(declare-fun lmap$ (A_a_fun$) A_llist_a_llist_fun$)
(declare-fun plus$ (Enat$) Enat_enat_fun$)
(declare-fun size$ (Enat$) Nat$)
(declare-fun zero$ () Enat$)
(declare-fun ldrop$ (Enat$) A_llist_a_llist_fun$)
(declare-fun lnull$ (A_llist$) Bool)
(declare-fun ltake$ (Enat$) A_llist_a_llist_fun$)
(declare-fun minus$ (Nat$) Nat_nat_fun$)
(declare-fun plus$a (Nat$) Nat_nat_fun$)
(declare-fun plus$b (Natural$ Natural$) Natural$)
(declare-fun size$a (Literal$) Nat$)
(declare-fun size$b (Nibble$) Nat$)
(declare-fun size$c (Char$) Nat$)
(declare-fun size$d () Bool_nat_fun$)
(declare-fun size$e (Natural$) Nat$)
(declare-fun times$ (Enat$ Enat$) Enat$)
(declare-fun zero$a () Nat$)
(declare-fun zero$b () Natural$)
(declare-fun compow$ () Nat_a_a_fun_a_a_fun_fun_fun$)
(declare-fun funpow$ () Nat_a_a_fun_a_a_fun_fun_fun$)
(declare-fun ldropn$ (Nat$) A_llist_a_llist_fun$)
(declare-fun minus$a (Natural$) Natural_natural_fun$)
(declare-fun times$a (Natural$ Natural$) Natural$)
(declare-fun times$b (Nat$) Nat_nat_fun$)
(declare-fun fun_app$ (A_llist_a_llist_fun$ A_llist$) A_llist$)
(declare-fun lappend$ (A_llist$) A_llist_a_llist_fun$)
(declare-fun less_eq$ (Enat$) Enat_bool_fun$)
(declare-fun llength$ () A_llist_enat_fun$)
(declare-fun lmember$ (A$) A_llist_bool_fun$)
(declare-fun fun_app$a (A_a_fun$ A$) A$)
(declare-fun fun_app$b (A_a_fun_a_a_fun_fun$ A_a_fun$) A_a_fun$)
(declare-fun fun_app$c (Nat_a_a_fun_a_a_fun_fun_fun$ Nat$) A_a_fun_a_a_fun_fun$)
(declare-fun fun_app$d (Enat_enat_fun$ Enat$) Enat$)
(declare-fun fun_app$e (Nat_nat_fun$ Nat$) Nat$)
(declare-fun fun_app$f (A_llist_enat_fun$ A_llist$) Enat$)
(declare-fun fun_app$g (A_llist_bool_fun$ A_llist$) Bool)
(declare-fun fun_app$h (Nat_bool_fun$ Nat$) Bool)
(declare-fun fun_app$i (Nat_nat_bool_fun_fun$ Nat$) Nat_bool_fun$)
(declare-fun fun_app$j (Bool_nat_fun$ Bool) Nat$)
(declare-fun fun_app$k (Enat_bool_fun$ Enat$) Bool)
(declare-fun fun_app$l (Natural_bool_fun$ Natural$) Bool)
(declare-fun fun_app$m (Natural_natural_bool_fun_fun$ Natural$) Natural_bool_fun$)
(declare-fun fun_app$n (Enat_enat_bool_fun_fun$ Enat$) Enat_bool_fun$)
(declare-fun fun_app$o (Natural_natural_fun$ Natural$) Natural$)
(declare-fun infinity$ () Enat$)
(declare-fun iterates$ (A_a_fun$ A$) A_llist$)
(declare-fun less_eq$a (Natural$ Natural$) Bool)
(declare-fun less_eq$b (Nat$) Nat_bool_fun$)
(declare-fun rec_bool$ (Nat$ Nat$) Bool_nat_fun$)
(declare-fun the_enat$ (Enat$) Nat$)
(declare-fun size_bool$ () Bool_nat_fun$)
(declare-fun size_char$ (Char$) Nat$)
(declare-fun size_enat$ (Enat$) Nat$)
(declare-fun gen_llength$ (Nat$) A_llist_enat_fun$)
(declare-fun size_natural$ (Natural$) Nat$)
(assert (not (= (fun_app$ (ldrop$ (enat$ n$)) (iterates$ f$ x$)) (iterates$ f$ (fun_app$a (fun_app$b (fun_app$c compow$ n$) f$) x$)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (= (enat$ ?v0) (enat$ ?v1)) (= ?v0 ?v1)) ))
(assert (forall ((?v0 A_a_fun$) (?v1 Nat$) (?v2 A$)) (= (fun_app$a ?v0 (fun_app$a (fun_app$b (fun_app$c compow$ ?v1) ?v0) ?v2)) (fun_app$a (fun_app$b (fun_app$c compow$ ?v1) ?v0) (fun_app$a ?v0 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 A_a_fun$) (?v2 A$)) (= (fun_app$ (ldropn$ ?v0) (iterates$ ?v1 ?v2)) (iterates$ ?v1 (fun_app$a (fun_app$b (fun_app$c compow$ ?v0) ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 A_llist$)) (! (= (fun_app$ (ldrop$ (enat$ ?v0)) ?v1) (fun_app$ (ldropn$ ?v0) ?v1)) :pattern ((fun_app$ (ldrop$ (enat$ ?v0)) ?v1)))))
(assert (= funpow$ compow$))
(assert (forall ((?v0 A_llist$)) (= (fun_app$ (ldrop$ zero$) ?v0) ?v0) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 A_llist$)) (= (fun_app$ (ldrop$ ?v0) (fun_app$ (ldrop$ ?v1) ?v2)) (fun_app$ (ldrop$ (fun_app$d (plus$ ?v0) ?v1)) ?v2)) ))
(assert (forall ((?v0 Enat$)) (! (= (fun_app$ (ldrop$ ?v0) lNil$) lNil$) :pattern ((ldrop$ ?v0)))))
(assert (forall ((?v0 Enat$) (?v1 A_a_fun$) (?v2 A_llist$)) (= (fun_app$ (ldrop$ ?v0) (fun_app$ (lmap$ ?v1) ?v2)) (fun_app$ (lmap$ ?v1) (fun_app$ (ldrop$ ?v0) ?v2))) ))
(assert (forall ((?v0 A_a_fun$) (?v1 A$)) (= (fun_app$ (lmap$ ?v0) (iterates$ ?v0 ?v1)) (iterates$ ?v0 (fun_app$a ?v0 ?v1))) ))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$ (ldropn$ ?v0) lNil$) lNil$) :pattern ((ldropn$ ?v0)))))
(assert (forall ((?v0 Nat$) (?v1 A_a_fun$) (?v2 A_llist$)) (= (fun_app$ (ldropn$ ?v0) (fun_app$ (lmap$ ?v1) ?v2)) (fun_app$ (lmap$ ?v1) (fun_app$ (ldropn$ ?v0) ?v2))) ))
(assert (forall ((?v0 A_a_fun$) (?v1 A_llist$)) (= (= (fun_app$ (lmap$ ?v0) ?v1) lNil$) (= ?v1 lNil$)) ))
(assert (forall ((?v0 A_a_fun$) (?v1 A_llist$)) (= (= lNil$ (fun_app$ (lmap$ ?v0) ?v1)) (= ?v1 lNil$)) ))
(assert (forall ((?v0 A_a_fun$)) (! (= (fun_app$ (lmap$ ?v0) lNil$) lNil$) :pattern ((lmap$ ?v0)))))
(assert (forall ((?v0 Enat$) (?v1 Nat$) (?v2 Enat$)) (= (= (fun_app$d (plus$ ?v0) (enat$ ?v1)) (fun_app$d (plus$ ?v2) (enat$ ?v1))) (= ?v0 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Enat$) (?v2 Enat$)) (= (= (fun_app$d (plus$ (enat$ ?v0)) ?v1) (fun_app$d (plus$ (enat$ ?v0)) ?v2)) (= ?v1 ?v2)) ))
(assert (forall ((?v0 Enat$)) (= (fun_app$d (plus$ ?v0) zero$) ?v0) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$e (plus$a ?v0) zero$a) ?v0) ))
(assert (forall ((?v0 Natural$)) (= (plus$b ?v0 zero$b) ?v0) ))
(assert (forall ((?v0 Enat$)) (= (fun_app$d (plus$ zero$) ?v0) ?v0) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$e (plus$a zero$a) ?v0) ?v0) ))
(assert (forall ((?v0 Natural$)) (= (plus$b zero$b ?v0) ?v0) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (= (plus$b ?v0 ?v1) (plus$b ?v2 ?v1)) (= ?v0 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$e (plus$a ?v0) ?v1) (fun_app$e (plus$a ?v2) ?v1)) (= ?v0 ?v2)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (= (plus$b ?v0 ?v1) (plus$b ?v0 ?v2)) (= ?v1 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$e (plus$a ?v0) ?v1) (fun_app$e (plus$a ?v0) ?v2)) (= ?v1 ?v2)) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$)) (= (= (fun_app$d (plus$ ?v0) ?v1) zero$) (and (= ?v0 zero$) (= ?v1 zero$))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (= ?v0 (fun_app$e (plus$a ?v0) ?v1)) (= ?v1 zero$a)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 A_llist$)) (= (fun_app$ (ldropn$ ?v0) (fun_app$ (ldropn$ ?v1) ?v2)) (fun_app$ (ldropn$ (fun_app$e (plus$a ?v0) ?v1)) ?v2)) ))
(assert (forall ((?v0 A_llist$)) (! (= (fun_app$ (ldropn$ zero$a) ?v0) ?v0) :pattern ((fun_app$ (ldropn$ zero$a) ?v0)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (fun_app$d (plus$ (enat$ ?v0)) (enat$ ?v1)) (enat$ (fun_app$e (plus$a ?v0) ?v1))) :pattern ((fun_app$d (plus$ (enat$ ?v0)) (enat$ ?v1))))))
(assert (= zero$ (enat$ zero$a)))
(assert (forall ((?v0 Nat$)) (= (= zero$ (enat$ ?v0)) (= ?v0 zero$a)) ))
(assert (forall ((?v0 Nat$)) (= (= (enat$ ?v0) zero$) (= ?v0 zero$a)) ))
(assert (forall ((?v0 Enat$)) (= (= zero$ ?v0) (= ?v0 zero$)) ))
(assert (forall ((?v0 Nat$)) (= (= zero$a ?v0) (= ?v0 zero$a)) ))
(assert (forall ((?v0 Natural$)) (= (= zero$b ?v0) (= ?v0 zero$b)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$) (?v3 Natural$)) (=> (and (= ?v0 ?v1) (= ?v2 ?v3)) (= (plus$b ?v0 ?v2) (plus$b ?v1 ?v3))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$) (?v3 Enat$)) (=> (and (= ?v0 ?v1) (= ?v2 ?v3)) (= (fun_app$d (plus$ ?v0) ?v2) (fun_app$d (plus$ ?v1) ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (= ?v0 ?v1) (= ?v2 ?v3)) (= (fun_app$e (plus$a ?v0) ?v2) (fun_app$e (plus$a ?v1) ?v3))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (=> (= (plus$b ?v0 ?v1) (plus$b ?v0 ?v2)) (= ?v1 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (= (fun_app$e (plus$a ?v0) ?v1) (fun_app$e (plus$a ?v0) ?v2)) (= ?v1 ?v2)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (=> (= (plus$b ?v0 ?v1) (plus$b ?v2 ?v1)) (= ?v0 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (= (fun_app$e (plus$a ?v0) ?v1) (fun_app$e (plus$a ?v2) ?v1)) (= ?v0 ?v2)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (= (plus$b ?v0 ?v1) (plus$b ?v1 ?v0)) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$)) (= (fun_app$d (plus$ ?v0) ?v1) (fun_app$d (plus$ ?v1) ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$e (plus$a ?v0) ?v1) (fun_app$e (plus$a ?v1) ?v0)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (plus$b ?v0 (plus$b ?v1 ?v2)) (plus$b ?v1 (plus$b ?v0 ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (= (fun_app$d (plus$ ?v0) (fun_app$d (plus$ ?v1) ?v2)) (fun_app$d (plus$ ?v1) (fun_app$d (plus$ ?v0) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (plus$a ?v0) (fun_app$e (plus$a ?v1) ?v2)) (fun_app$e (plus$a ?v1) (fun_app$e (plus$a ?v0) ?v2))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (plus$b (plus$b ?v0 ?v1) ?v2) (plus$b ?v0 (plus$b ?v1 ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (= (fun_app$d (plus$ (fun_app$d (plus$ ?v0) ?v1)) ?v2) (fun_app$d (plus$ ?v0) (fun_app$d (plus$ ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (plus$a (fun_app$e (plus$a ?v0) ?v1)) ?v2) (fun_app$e (plus$a ?v0) (fun_app$e (plus$a ?v1) ?v2))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (plus$b (plus$b ?v0 ?v1) ?v2) (plus$b ?v0 (plus$b ?v1 ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (= (fun_app$d (plus$ (fun_app$d (plus$ ?v0) ?v1)) ?v2) (fun_app$d (plus$ ?v0) (fun_app$d (plus$ ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (plus$a (fun_app$e (plus$a ?v0) ?v1)) ?v2) (fun_app$e (plus$a ?v0) (fun_app$e (plus$a ?v1) ?v2))) ))
(assert (forall ((?v0 Enat$)) (=> (and (=> (= ?v0 zero$) false) (=> (not (= ?v0 zero$)) false)) false) ))
(assert (forall ((?v0 Enat$)) (= (fun_app$d (plus$ zero$) ?v0) ?v0) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$e (plus$a zero$a) ?v0) ?v0) ))
(assert (forall ((?v0 Natural$)) (= (plus$b zero$b ?v0) ?v0) ))
(assert (forall ((?v0 Enat$)) (= (fun_app$d (plus$ ?v0) zero$) ?v0) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$e (plus$a ?v0) zero$a) ?v0) ))
(assert (forall ((?v0 Natural$)) (= (plus$b ?v0 zero$b) ?v0) ))
(assert (forall ((?v0 Nat$)) (! (= (size_enat$ (enat$ ?v0)) zero$a) :pattern ((enat$ ?v0)))))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$f (gen_llength$ ?v0) lNil$) (enat$ ?v0)) :pattern ((gen_llength$ ?v0)))))
(assert (forall ((?v0 Nat$)) (! (= (size$ (enat$ ?v0)) zero$a) :pattern ((enat$ ?v0)))))
(assert (forall ((?v0 A$)) (! (= (fun_app$g (lmember$ ?v0) lNil$) false) :pattern ((lmember$ ?v0)))))
(assert (forall ((?v0 Enat$) (?v1 Nat$) (?v2 A_llist$)) (= (fun_app$ (ltake$ ?v0) (fun_app$ (ldropn$ ?v1) ?v2)) (fun_app$ (ldropn$ ?v1) (fun_app$ (ltake$ (fun_app$d (plus$ ?v0) (enat$ ?v1))) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (= (fun_app$e (plus$a ?v0) ?v1) zero$a) (and (= ?v0 zero$a) (= ?v1 zero$a))) ))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$e (plus$a ?v0) zero$a) ?v0) :pattern ((plus$a ?v0)))))
(assert (forall ((?v0 Enat$)) (! (= (fun_app$ (ltake$ ?v0) lNil$) lNil$) :pattern ((ltake$ ?v0)))))
(assert (forall ((?v0 Enat$) (?v1 A_a_fun$) (?v2 A_llist$)) (= (fun_app$ (ltake$ ?v0) (fun_app$ (lmap$ ?v1) ?v2)) (fun_app$ (lmap$ ?v1) (fun_app$ (ltake$ ?v0) ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 A_llist$)) (= (= lNil$ (fun_app$ (ltake$ ?v0) ?v1)) (or (= ?v1 lNil$) (= ?v0 zero$))) ))
(assert (forall ((?v0 A_llist$)) (= (fun_app$ (ltake$ zero$) ?v0) lNil$) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$e (plus$a ?v0) ?v1) (fun_app$e (plus$a ?v2) ?v1)) (= ?v0 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$e (plus$a ?v0) ?v1) (fun_app$e (plus$a ?v0) ?v2)) (= ?v1 ?v2)) ))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$e (plus$a zero$a) ?v0) ?v0) :pattern ((fun_app$e (plus$a zero$a) ?v0)))))
(assert (forall ((?v0 Nat$)) (=> (and (=> (= ?v0 zero$a) false) (=> (not (= ?v0 zero$a)) false)) false) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (= (fun_app$e (plus$a ?v0) ?v1) ?v0) (= ?v1 zero$a)) ))
(assert (forall ((?v0 Enat$) (?v1 A_llist$)) (= (= (fun_app$ (ltake$ ?v0) ?v1) lNil$) (or (= ?v1 lNil$) (= ?v0 zero$))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 A_llist$)) (= (fun_app$ (ltake$ ?v0) (fun_app$ (ldrop$ ?v1) ?v2)) (fun_app$ (ldrop$ ?v1) (fun_app$ (ltake$ (fun_app$d (plus$ ?v0) ?v1)) ?v2))) ))
(assert (forall ((?v0 Nat_nat_bool_fun_fun$) (?v1 Nat$) (?v2 Nat$)) (=> (and (forall ((?v3 Nat$) (?v4 Nat$)) (= (fun_app$h (fun_app$i ?v0 ?v3) ?v4) (fun_app$h (fun_app$i ?v0 ?v4) ?v3)) ) (and (forall ((?v3 Nat$)) (fun_app$h (fun_app$i ?v0 ?v3) zero$a) ) (forall ((?v3 Nat$) (?v4 Nat$)) (=> (fun_app$h (fun_app$i ?v0 ?v3) ?v4) (fun_app$h (fun_app$i ?v0 ?v3) (fun_app$e (plus$a ?v3) ?v4))) ))) (fun_app$h (fun_app$i ?v0 ?v1) ?v2)) ))
(assert (= (the_enat$ zero$) zero$a))
(assert (forall ((?v0 Nat$) (?v1 A_llist$)) (= (fun_app$ (lappend$ (fun_app$ (ltake$ (enat$ ?v0)) ?v1)) (fun_app$ (ldropn$ ?v0) ?v1)) ?v1) ))
(assert (forall ((?v0 Nat$) (?v1 A_llist$)) (! (= (fun_app$f (gen_llength$ ?v0) ?v1) (fun_app$d (plus$ (enat$ ?v0)) (fun_app$f llength$ ?v1))) :pattern ((fun_app$f (gen_llength$ ?v0) ?v1)))))
(assert (= (size$ infinity$) zero$a))
(assert (= (size_enat$ infinity$) zero$a))
(assert (forall ((?v0 Enat$) (?v1 Enat$)) (=> (not (= (size$ ?v0) (size$ ?v1))) (not (= ?v0 ?v1))) ))
(assert (forall ((?v0 Literal$) (?v1 Literal$)) (=> (not (= (size$a ?v0) (size$a ?v1))) (not (= ?v0 ?v1))) ))
(assert (forall ((?v0 Nibble$) (?v1 Nibble$)) (=> (not (= (size$b ?v0) (size$b ?v1))) (not (= ?v0 ?v1))) ))
(assert (forall ((?v0 Char$) (?v1 Char$)) (=> (not (= (size$c ?v0) (size$c ?v1))) (not (= ?v0 ?v1))) ))
(assert (forall ((?v0 Bool) (?v1 Bool)) (=> (not (= (fun_app$j size$d ?v0) (fun_app$j size$d ?v1))) (not (= ?v0 ?v1))) ))
(assert (forall ((?v0 Enat$)) (= (not (= ?v0 infinity$)) (exists ((?v1 Nat$)) (= ?v0 (enat$ ?v1)) )) ))
(assert (forall ((?v0 Enat$)) (= (forall ((?v1 Nat$)) (not (= ?v0 (enat$ ?v1))) ) (= ?v0 infinity$)) ))
(assert (forall ((?v0 A_llist$)) (! (= (fun_app$ (lappend$ lNil$) ?v0) ?v0) :pattern ((fun_app$ (lappend$ lNil$) ?v0)))))
(assert (forall ((?v0 A_llist$)) (! (= (fun_app$ (lappend$ ?v0) lNil$) ?v0) :pattern ((lappend$ ?v0)))))
(assert (forall ((?v0 Enat$)) (! (= (fun_app$d (plus$ infinity$) ?v0) infinity$) :pattern ((fun_app$d (plus$ infinity$) ?v0)))))
(assert (forall ((?v0 Enat$)) (! (= (fun_app$d (plus$ ?v0) infinity$) infinity$) :pattern ((plus$ ?v0)))))
(assert (forall ((?v0 A_a_fun$) (?v1 A_llist$)) (= (fun_app$f llength$ (fun_app$ (lmap$ ?v0) ?v1)) (fun_app$f llength$ ?v1)) ))
(assert (= (fun_app$f llength$ lNil$) zero$))
(assert (forall ((?v0 A_llist$)) (! (= (fun_app$ (ldrop$ infinity$) ?v0) lNil$) :pattern ((fun_app$ (ldrop$ infinity$) ?v0)))))
(assert (forall ((?v0 A_llist$) (?v1 A_llist$)) (= (fun_app$f llength$ (fun_app$ (lappend$ ?v0) ?v1)) (fun_app$d (plus$ (fun_app$f llength$ ?v0)) (fun_app$f llength$ ?v1))) ))
(assert (forall ((?v0 A_a_fun$) (?v1 A$)) (= (fun_app$f llength$ (iterates$ ?v0 ?v1)) infinity$) ))
(assert (forall ((?v0 Enat$)) (=> (not (= ?v0 infinity$)) (= (enat$ (the_enat$ ?v0)) ?v0)) ))
(assert (forall ((?v0 A_llist$) (?v1 A_llist$) (?v2 A_llist$)) (= (fun_app$ (lappend$ (fun_app$ (lappend$ ?v0) ?v1)) ?v2) (fun_app$ (lappend$ ?v0) (fun_app$ (lappend$ ?v1) ?v2))) ))
(assert (= (fun_app$ (lappend$ lNil$) lNil$) lNil$))
(assert (forall ((?v0 A_llist$) (?v1 A_llist$)) (= (= (fun_app$ (lappend$ ?v0) ?v1) lNil$) (and (= ?v0 lNil$) (= ?v1 lNil$))) ))
(assert (forall ((?v0 A_llist$) (?v1 A_llist$)) (= (= lNil$ (fun_app$ (lappend$ ?v0) ?v1)) (and (= ?v0 lNil$) (= ?v1 lNil$))) ))
(assert (forall ((?v0 Enat$)) (=> (and (forall ((?v1 Nat$)) (=> (= ?v0 (enat$ ?v1)) false) ) (=> (= ?v0 infinity$) false)) false) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$)) (=> (and (forall ((?v2 Nat$) (?v3 Nat$)) (=> (and (= ?v0 (enat$ ?v2)) (= ?v1 (enat$ ?v3))) false) ) (and (forall ((?v2 Nat$)) (=> (and (= ?v0 (enat$ ?v2)) (= ?v1 infinity$)) false) ) (and (forall ((?v2 Nat$)) (=> (and (= ?v0 infinity$) (= ?v1 (enat$ ?v2))) false) ) (=> (and (= ?v0 infinity$) (= ?v1 infinity$)) false)))) false) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (=> (and (forall ((?v3 Nat$) (?v4 Nat$) (?v5 Nat$)) (=> (and (= ?v0 (enat$ ?v3)) (and (= ?v1 (enat$ ?v4)) (= ?v2 (enat$ ?v5)))) false) ) (and (forall ((?v3 Nat$) (?v4 Nat$)) (=> (and (= ?v0 (enat$ ?v3)) (and (= ?v1 (enat$ ?v4)) (= ?v2 infinity$))) false) ) (and (forall ((?v3 Nat$) (?v4 Nat$)) (=> (and (= ?v0 (enat$ ?v3)) (and (= ?v1 infinity$) (= ?v2 (enat$ ?v4)))) false) ) (and (forall ((?v3 Nat$)) (=> (and (= ?v0 (enat$ ?v3)) (and (= ?v1 infinity$) (= ?v2 infinity$))) false) ) (and (forall ((?v3 Nat$) (?v4 Nat$)) (=> (and (= ?v0 infinity$) (and (= ?v1 (enat$ ?v3)) (= ?v2 (enat$ ?v4)))) false) ) (and (forall ((?v3 Nat$)) (=> (and (= ?v0 infinity$) (and (= ?v1 (enat$ ?v3)) (= ?v2 infinity$))) false) ) (and (forall ((?v3 Nat$)) (=> (and (= ?v0 infinity$) (and (= ?v1 infinity$) (= ?v2 (enat$ ?v3)))) false) ) (=> (and (= ?v0 infinity$) (and (= ?v1 infinity$) (= ?v2 infinity$))) false)))))))) false) ))
(assert (forall ((?v0 Nat$)) (not (= (enat$ ?v0) infinity$)) ))
(assert (forall ((?v0 Nat$)) (not (= infinity$ (enat$ ?v0))) ))
(assert (not (= infinity$ zero$)))
(assert (forall ((?v0 A_a_fun$) (?v1 A_llist$) (?v2 A_llist$)) (= (fun_app$ (lmap$ ?v0) (fun_app$ (lappend$ ?v1) ?v2)) (fun_app$ (lappend$ (fun_app$ (lmap$ ?v0) ?v1)) (fun_app$ (lmap$ ?v0) ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (= (= (fun_app$d (plus$ ?v0) ?v1) (fun_app$d (plus$ ?v0) ?v2)) (or (= ?v0 infinity$) (= ?v1 ?v2))) ))
(assert (forall ((?v0 A_a_fun$) (?v1 A$) (?v2 A_llist$)) (= (fun_app$ (lappend$ (iterates$ ?v0 ?v1)) ?v2) (iterates$ ?v0 ?v1)) ))
(assert (forall ((?v0 Nat$)) (! (= (the_enat$ (enat$ ?v0)) ?v0) :pattern ((enat$ ?v0)))))
(assert (forall ((?v0 Enat$) (?v1 A_llist$)) (= (fun_app$ (lappend$ (fun_app$ (ltake$ ?v0) ?v1)) (fun_app$ (ldrop$ ?v0) ?v1)) ?v1) ))
(assert (= llength$ (gen_llength$ zero$a)))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 A_llist$)) (= (fun_app$ (ltake$ (fun_app$d (plus$ ?v0) ?v1)) ?v2) (fun_app$ (lappend$ (fun_app$ (ltake$ ?v0) ?v2)) (fun_app$ (ltake$ ?v1) (fun_app$ (ldrop$ ?v0) ?v2)))) ))
(assert (forall ((?v0 Nibble$)) (! (= (size$b ?v0) zero$a) :pattern ((size$b ?v0)))))
(assert (= (size$e zero$b) zero$a))
(assert (= (fun_app$j size$d false) zero$a))
(assert (= (fun_app$j size$d true) zero$a))
(assert (forall ((?v0 Char$)) (! (= (size$c ?v0) zero$a) :pattern ((size$c ?v0)))))
(assert (forall ((?v0 Nat$)) (! (= (times$ infinity$ (enat$ ?v0)) (ite (= ?v0 zero$a) zero$ infinity$)) :pattern ((enat$ ?v0)))))
(assert (forall ((?v0 Enat$) (?v1 Enat$)) (= (= (times$ ?v0 ?v1) zero$) (or (= ?v0 zero$) (= ?v1 zero$))) ))
(assert (= (times$ infinity$ infinity$) infinity$))
(assert (forall ((?v0 Nat$)) (! (= (times$ (enat$ ?v0) infinity$) (ite (= ?v0 zero$a) zero$ infinity$)) :pattern ((enat$ ?v0)))))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (= (times$a ?v0 ?v1) (times$a ?v1 ?v0)) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$)) (= (times$ ?v0 ?v1) (times$ ?v1 ?v0)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$e (times$b ?v0) ?v1) (fun_app$e (times$b ?v1) ?v0)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (times$a ?v0 (times$a ?v1 ?v2)) (times$a ?v1 (times$a ?v0 ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (= (times$ ?v0 (times$ ?v1 ?v2)) (times$ ?v1 (times$ ?v0 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (times$b ?v0) (fun_app$e (times$b ?v1) ?v2)) (fun_app$e (times$b ?v1) (fun_app$e (times$b ?v0) ?v2))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (times$a (times$a ?v0 ?v1) ?v2) (times$a ?v0 (times$a ?v1 ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (= (times$ (times$ ?v0 ?v1) ?v2) (times$ ?v0 (times$ ?v1 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (times$b (fun_app$e (times$b ?v0) ?v1)) ?v2) (fun_app$e (times$b ?v0) (fun_app$e (times$b ?v1) ?v2))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (times$a (times$a ?v0 ?v1) ?v2) (times$a ?v0 (times$a ?v1 ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (= (times$ (times$ ?v0 ?v1) ?v2) (times$ ?v0 (times$ ?v1 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (times$b (fun_app$e (times$b ?v0) ?v1)) ?v2) (fun_app$e (times$b ?v0) (fun_app$e (times$b ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (= (= (fun_app$e (plus$a (fun_app$e (times$b ?v0) ?v1)) (fun_app$e (times$b ?v2) ?v3)) (fun_app$e (plus$a (fun_app$e (times$b ?v0) ?v3)) (fun_app$e (times$b ?v2) ?v1))) (or (= ?v0 ?v2) (= ?v1 ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (= (and (not (= ?v0 ?v1)) (not (= ?v2 ?v3))) (not (= (fun_app$e (plus$a (fun_app$e (times$b ?v0) ?v2)) (fun_app$e (times$b ?v1) ?v3)) (fun_app$e (plus$a (fun_app$e (times$b ?v0) ?v3)) (fun_app$e (times$b ?v1) ?v2))))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$) (?v4 Nat$)) (=> (and (not (= ?v0 zero$a)) (and (= ?v1 ?v2) (not (= ?v3 ?v4)))) (not (= (fun_app$e (plus$a ?v1) (fun_app$e (times$b ?v0) ?v3)) (fun_app$e (plus$a ?v2) (fun_app$e (times$b ?v0) ?v4))))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$)) (= (= (times$ ?v0 ?v1) infinity$) (or (and (= ?v0 infinity$) (not (= ?v1 zero$))) (and (= ?v1 infinity$) (not (= ?v0 zero$))))) ))
(assert (= zero$a zero$a))
(assert (forall ((?v0 Literal$)) (! (= (size$a ?v0) zero$a) :pattern ((size$a ?v0)))))
(assert (forall ((?v0 Bool)) (! (= (fun_app$j size$d ?v0) zero$a) :pattern ((fun_app$j size$d ?v0)))))
(assert (forall ((?v0 Natural$)) (= (times$a zero$b ?v0) zero$b) ))
(assert (forall ((?v0 Enat$)) (= (times$ zero$ ?v0) zero$) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$e (times$b zero$a) ?v0) zero$a) ))
(assert (forall ((?v0 Natural$)) (= (times$a ?v0 zero$b) zero$b) ))
(assert (forall ((?v0 Enat$)) (= (times$ ?v0 zero$) zero$) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$e (times$b ?v0) zero$a) zero$a) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (= (= (times$a ?v0 ?v1) zero$b) (or (= ?v0 zero$b) (= ?v1 zero$b))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (= (fun_app$e (times$b ?v0) ?v1) zero$a) (or (= ?v0 zero$a) (= ?v1 zero$a))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (= (times$a ?v0 ?v1) (times$a ?v0 ?v2)) (or (= ?v0 zero$b) (= ?v1 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$e (times$b ?v0) ?v1) (fun_app$e (times$b ?v0) ?v2)) (or (= ?v0 zero$a) (= ?v1 ?v2))) ))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$e (times$b ?v0) zero$a) zero$a) :pattern ((times$b ?v0)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (= (fun_app$e (times$b ?v0) ?v1) zero$a) (or (= ?v0 zero$a) (= ?v1 zero$a))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$e (times$b ?v0) ?v1) (fun_app$e (times$b ?v0) ?v2)) (or (= ?v1 ?v2) (= ?v0 zero$a))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$e (times$b ?v0) ?v1) (fun_app$e (times$b ?v2) ?v1)) (or (= ?v0 ?v2) (= ?v1 zero$a))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (= (times$a ?v0 ?v1) (times$a ?v2 ?v1)) (or (= ?v1 zero$b) (= ?v0 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$e (times$b ?v0) ?v1) (fun_app$e (times$b ?v2) ?v1)) (or (= ?v1 zero$a) (= ?v0 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (= (times$ (enat$ ?v0) (enat$ ?v1)) (enat$ (fun_app$e (times$b ?v0) ?v1))) :pattern ((times$ (enat$ ?v0) (enat$ ?v1))))))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$e (times$b zero$a) ?v0) zero$a) :pattern ((fun_app$e (times$b zero$a) ?v0)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (times$b (fun_app$e (plus$a ?v0) ?v1)) ?v2) (fun_app$e (plus$a (fun_app$e (times$b ?v0) ?v2)) (fun_app$e (times$b ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (times$b ?v0) (fun_app$e (plus$a ?v1) ?v2)) (fun_app$e (plus$a (fun_app$e (times$b ?v0) ?v1)) (fun_app$e (times$b ?v0) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 A_a_fun$)) (= (fun_app$b (fun_app$c compow$ ?v0) (fun_app$b (fun_app$c compow$ ?v1) ?v2)) (fun_app$b (fun_app$c compow$ (fun_app$e (times$b ?v1) ?v0)) ?v2)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (=> (not (= ?v0 zero$b)) (= (= (times$a ?v0 ?v1) (times$a ?v0 ?v2)) (= ?v1 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (not (= ?v0 zero$a)) (= (= (fun_app$e (times$b ?v0) ?v1) (fun_app$e (times$b ?v0) ?v2)) (= ?v1 ?v2))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (=> (not (= ?v0 zero$b)) (= (= (times$a ?v1 ?v0) (times$a ?v2 ?v0)) (= ?v1 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (not (= ?v0 zero$a)) (= (= (fun_app$e (times$b ?v1) ?v0) (fun_app$e (times$b ?v2) ?v0)) (= ?v1 ?v2))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (=> (and (not (= ?v0 zero$b)) (not (= ?v1 zero$b))) (not (= (times$a ?v0 ?v1) zero$b))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (not (= ?v0 zero$a)) (not (= ?v1 zero$a))) (not (= (fun_app$e (times$b ?v0) ?v1) zero$a))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (=> (not (= (times$a ?v0 ?v1) zero$b)) (and (not (= ?v0 zero$b)) (not (= ?v1 zero$b)))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$)) (=> (not (= (times$ ?v0 ?v1) zero$)) (and (not (= ?v0 zero$)) (not (= ?v1 zero$)))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (not (= (fun_app$e (times$b ?v0) ?v1) zero$a)) (and (not (= ?v0 zero$a)) (not (= ?v1 zero$a)))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (=> (= (times$a ?v0 ?v1) zero$b) (or (= ?v0 zero$b) (= ?v1 zero$b))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (= (fun_app$e (times$b ?v0) ?v1) zero$a) (or (= ?v0 zero$a) (= ?v1 zero$a))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$) (?v3 Natural$)) (= (plus$b (times$a ?v0 ?v1) (plus$b (times$a ?v2 ?v1) ?v3)) (plus$b (times$a (plus$b ?v0 ?v2) ?v1) ?v3)) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$) (?v3 Enat$)) (= (fun_app$d (plus$ (times$ ?v0 ?v1)) (fun_app$d (plus$ (times$ ?v2 ?v1)) ?v3)) (fun_app$d (plus$ (times$ (fun_app$d (plus$ ?v0) ?v2) ?v1)) ?v3)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (= (fun_app$e (plus$a (fun_app$e (times$b ?v0) ?v1)) (fun_app$e (plus$a (fun_app$e (times$b ?v2) ?v1)) ?v3)) (fun_app$e (plus$a (fun_app$e (times$b (fun_app$e (plus$a ?v0) ?v2)) ?v1)) ?v3)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (times$a (plus$b ?v0 ?v1) ?v2) (plus$b (times$a ?v0 ?v2) (times$a ?v1 ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (= (times$ (fun_app$d (plus$ ?v0) ?v1) ?v2) (fun_app$d (plus$ (times$ ?v0 ?v2)) (times$ ?v1 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (times$b (fun_app$e (plus$a ?v0) ?v1)) ?v2) (fun_app$e (plus$a (fun_app$e (times$b ?v0) ?v2)) (fun_app$e (times$b ?v1) ?v2))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (times$a (plus$b ?v0 ?v1) ?v2) (plus$b (times$a ?v0 ?v2) (times$a ?v1 ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (= (times$ (fun_app$d (plus$ ?v0) ?v1) ?v2) (fun_app$d (plus$ (times$ ?v0 ?v2)) (times$ ?v1 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (times$b (fun_app$e (plus$a ?v0) ?v1)) ?v2) (fun_app$e (plus$a (fun_app$e (times$b ?v0) ?v2)) (fun_app$e (times$b ?v1) ?v2))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (times$a ?v0 (plus$b ?v1 ?v2)) (plus$b (times$a ?v0 ?v1) (times$a ?v0 ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (= (times$ ?v0 (fun_app$d (plus$ ?v1) ?v2)) (fun_app$d (plus$ (times$ ?v0 ?v1)) (times$ ?v0 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (times$b ?v0) (fun_app$e (plus$a ?v1) ?v2)) (fun_app$e (plus$a (fun_app$e (times$b ?v0) ?v1)) (fun_app$e (times$b ?v0) ?v2))) ))
(assert (forall ((?v0 Char$)) (! (= (size_char$ ?v0) zero$a) :pattern ((size_char$ ?v0)))))
(assert (= (size_natural$ zero$b) zero$a))
(assert (= (fun_app$j size_bool$ true) zero$a))
(assert (= (fun_app$j size_bool$ false) zero$a))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (= (fun_app$e (plus$a (fun_app$e (times$b ?v0) ?v1)) (fun_app$e (plus$a (fun_app$e (times$b ?v2) ?v1)) ?v3)) (fun_app$e (plus$a (fun_app$e (times$b (fun_app$e (plus$a ?v0) ?v2)) ?v1)) ?v3)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$e (times$b ?v0) ?v1) (fun_app$e (times$b ?v0) ?v2)) (or (= ?v0 zero$a) (= ?v1 ?v2))) ))
(assert (= size_bool$ (rec_bool$ zero$a zero$a)))
(assert (= size$d (rec_bool$ zero$a zero$a)))
(assert (= (size$b nibbleA$) zero$a))
(assert (forall ((?v0 Nat$) (?v1 A_llist$)) (= (= (fun_app$ (ldropn$ ?v0) ?v1) lNil$) (fun_app$k (less_eq$ (fun_app$f llength$ ?v1)) (enat$ ?v0))) ))
(assert (forall ((?v0 A_llist$) (?v1 Nat$)) (! (=> (fun_app$k (less_eq$ (fun_app$f llength$ ?v0)) (enat$ ?v1)) (= (fun_app$ (ldropn$ ?v1) ?v0) lNil$)) :pattern ((fun_app$ (ldropn$ ?v1) ?v0)))))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (less_eq$a (plus$b ?v0 ?v1) (plus$b ?v2 ?v1)) (less_eq$a ?v0 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$h (less_eq$b (fun_app$e (plus$a ?v0) ?v1)) (fun_app$e (plus$a ?v2) ?v1)) (fun_app$h (less_eq$b ?v0) ?v2)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (less_eq$a (plus$b ?v0 ?v1) (plus$b ?v0 ?v2)) (less_eq$a ?v1 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$h (less_eq$b (fun_app$e (plus$a ?v0) ?v1)) (fun_app$e (plus$a ?v0) ?v2)) (fun_app$h (less_eq$b ?v1) ?v2)) ))
(assert (forall ((?v0 Enat$)) (= (fun_app$k (less_eq$ ?v0) zero$) (= ?v0 zero$)) ))
(assert (forall ((?v0 Enat$)) (! (= (fun_app$k (less_eq$ ?v0) infinity$) true) :pattern ((less_eq$ ?v0)))))
(assert (forall ((?v0 Enat$)) (! (= (fun_app$k (less_eq$ infinity$) ?v0) (= ?v0 infinity$)) :pattern ((fun_app$k (less_eq$ infinity$) ?v0)))))
(assert (forall ((?v0 Enat$) (?v1 A_llist$)) (= (= (fun_app$ (ldrop$ ?v0) ?v1) lNil$) (fun_app$k (less_eq$ (fun_app$f llength$ ?v1)) ?v0)) ))
(assert (fun_app$h (less_eq$b zero$a) zero$a))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$h (less_eq$b ?v0) ?v1) (exists ((?v2 Nat$)) (= ?v1 (fun_app$e (plus$a ?v0) ?v2)) )) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$) (?v3 Natural$)) (=> (and (= ?v0 ?v1) (less_eq$a ?v2 ?v3)) (less_eq$a (plus$b ?v0 ?v2) (plus$b ?v1 ?v3))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$) (?v3 Enat$)) (=> (and (= ?v0 ?v1) (fun_app$k (less_eq$ ?v2) ?v3)) (fun_app$k (less_eq$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (= ?v0 ?v1) (fun_app$h (less_eq$b ?v2) ?v3)) (fun_app$h (less_eq$b (fun_app$e (plus$a ?v0) ?v2)) (fun_app$e (plus$a ?v1) ?v3))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$) (?v3 Natural$)) (=> (and (less_eq$a ?v0 ?v1) (= ?v2 ?v3)) (less_eq$a (plus$b ?v0 ?v2) (plus$b ?v1 ?v3))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$) (?v3 Enat$)) (=> (and (fun_app$k (less_eq$ ?v0) ?v1) (= ?v2 ?v3)) (fun_app$k (less_eq$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$h (less_eq$b ?v0) ?v1) (= ?v2 ?v3)) (fun_app$h (less_eq$b (fun_app$e (plus$a ?v0) ?v2)) (fun_app$e (plus$a ?v1) ?v3))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$) (?v3 Natural$)) (=> (and (less_eq$a ?v0 ?v1) (less_eq$a ?v2 ?v3)) (less_eq$a (plus$b ?v0 ?v2) (plus$b ?v1 ?v3))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$) (?v3 Enat$)) (=> (and (fun_app$k (less_eq$ ?v0) ?v1) (fun_app$k (less_eq$ ?v2) ?v3)) (fun_app$k (less_eq$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$h (less_eq$b ?v0) ?v1) (fun_app$h (less_eq$b ?v2) ?v3)) (fun_app$h (less_eq$b (fun_app$e (plus$a ?v0) ?v2)) (fun_app$e (plus$a ?v1) ?v3))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (=> (less_eq$a (plus$b ?v0 ?v1) (plus$b ?v2 ?v1)) (less_eq$a ?v0 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$h (less_eq$b (fun_app$e (plus$a ?v0) ?v1)) (fun_app$e (plus$a ?v2) ?v1)) (fun_app$h (less_eq$b ?v0) ?v2)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (=> (less_eq$a (plus$b ?v0 ?v1) (plus$b ?v0 ?v2)) (less_eq$a ?v1 ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$h (less_eq$b (fun_app$e (plus$a ?v0) ?v1)) (fun_app$e (plus$a ?v0) ?v2)) (fun_app$h (less_eq$b ?v1) ?v2)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$) (?v3 Natural$)) (=> (and (less_eq$a ?v0 ?v1) (less_eq$a ?v2 ?v3)) (less_eq$a (plus$b ?v0 ?v2) (plus$b ?v1 ?v3))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$) (?v3 Enat$)) (=> (and (fun_app$k (less_eq$ ?v0) ?v1) (fun_app$k (less_eq$ ?v2) ?v3)) (fun_app$k (less_eq$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$h (less_eq$b ?v0) ?v1) (fun_app$h (less_eq$b ?v2) ?v3)) (fun_app$h (less_eq$b (fun_app$e (plus$a ?v0) ?v2)) (fun_app$e (plus$a ?v1) ?v3))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (=> (less_eq$a ?v0 ?v1) (less_eq$a (plus$b ?v0 ?v2) (plus$b ?v1 ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (=> (fun_app$k (less_eq$ ?v0) ?v1) (fun_app$k (less_eq$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$h (less_eq$b ?v0) ?v1) (fun_app$h (less_eq$b (fun_app$e (plus$a ?v0) ?v2)) (fun_app$e (plus$a ?v1) ?v2))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (=> (less_eq$a ?v0 ?v1) (less_eq$a (plus$b ?v2 ?v0) (plus$b ?v2 ?v1))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (=> (fun_app$k (less_eq$ ?v0) ?v1) (fun_app$k (less_eq$ (fun_app$d (plus$ ?v2) ?v0)) (fun_app$d (plus$ ?v2) ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$h (less_eq$b ?v0) ?v1) (fun_app$h (less_eq$b (fun_app$e (plus$a ?v2) ?v0)) (fun_app$e (plus$a ?v2) ?v1))) ))
(assert (forall ((?v0 Enat$)) (fun_app$k (less_eq$ zero$) ?v0) ))
(assert (forall ((?v0 Enat$) (?v1 Nat$)) (=> (fun_app$k (less_eq$ ?v0) (enat$ ?v1)) (exists ((?v2 Nat$)) (= ?v0 (enat$ ?v2)) )) ))
(assert (forall ((?v0 Enat$)) (fun_app$k (less_eq$ ?v0) infinity$) ))
(assert (forall ((?v0 Natural_natural_bool_fun_fun$) (?v1 Natural$) (?v2 Natural$)) (=> (and (forall ((?v3 Natural$) (?v4 Natural$)) (=> (less_eq$a ?v3 ?v4) (fun_app$l (fun_app$m ?v0 ?v3) ?v4)) ) (=> (fun_app$l (fun_app$m ?v0 ?v1) ?v2) (fun_app$l (fun_app$m ?v0 ?v2) ?v1))) (fun_app$l (fun_app$m ?v0 ?v2) ?v1)) ))
(assert (forall ((?v0 Enat_enat_bool_fun_fun$) (?v1 Enat$) (?v2 Enat$)) (=> (and (forall ((?v3 Enat$) (?v4 Enat$)) (=> (fun_app$k (less_eq$ ?v3) ?v4) (fun_app$k (fun_app$n ?v0 ?v3) ?v4)) ) (=> (fun_app$k (fun_app$n ?v0 ?v1) ?v2) (fun_app$k (fun_app$n ?v0 ?v2) ?v1))) (fun_app$k (fun_app$n ?v0 ?v2) ?v1)) ))
(assert (forall ((?v0 Nat_nat_bool_fun_fun$) (?v1 Nat$) (?v2 Nat$)) (=> (and (forall ((?v3 Nat$) (?v4 Nat$)) (=> (fun_app$h (less_eq$b ?v3) ?v4) (fun_app$h (fun_app$i ?v0 ?v3) ?v4)) ) (=> (fun_app$h (fun_app$i ?v0 ?v1) ?v2) (fun_app$h (fun_app$i ?v0 ?v2) ?v1))) (fun_app$h (fun_app$i ?v0 ?v2) ?v1)) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$)) (fun_app$k (less_eq$ ?v0) (fun_app$d (plus$ ?v0) ?v1)) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$)) (fun_app$k (less_eq$ ?v0) (fun_app$d (plus$ ?v1) ?v0)) ))
(assert (forall ((?v0 Enat$) (?v1 A_llist$) (?v2 A_llist$) (?v3 Enat$)) (=> (and (= (fun_app$ (ltake$ ?v0) ?v1) (fun_app$ (ltake$ ?v0) ?v2)) (fun_app$k (less_eq$ ?v3) ?v0)) (= (fun_app$ (ltake$ ?v3) ?v1) (fun_app$ (ltake$ ?v3) ?v2))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (=> (or (and (less_eq$a zero$b ?v0) (less_eq$a ?v1 zero$b)) (and (less_eq$a ?v0 zero$b) (less_eq$a zero$b ?v1))) (less_eq$a (times$a ?v0 ?v1) zero$b)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (or (and (fun_app$h (less_eq$b zero$a) ?v0) (fun_app$h (less_eq$b ?v1) zero$a)) (and (fun_app$h (less_eq$b ?v0) zero$a) (fun_app$h (less_eq$b zero$a) ?v1))) (fun_app$h (less_eq$b (fun_app$e (times$b ?v0) ?v1)) zero$a)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$) (?v3 Natural$)) (=> (and (less_eq$a ?v0 ?v1) (and (less_eq$a ?v2 ?v3) (and (less_eq$a zero$b ?v0) (less_eq$a zero$b ?v2)))) (less_eq$a (times$a ?v0 ?v2) (times$a ?v1 ?v3))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$) (?v3 Enat$)) (=> (and (fun_app$k (less_eq$ ?v0) ?v1) (and (fun_app$k (less_eq$ ?v2) ?v3) (and (fun_app$k (less_eq$ zero$) ?v0) (fun_app$k (less_eq$ zero$) ?v2)))) (fun_app$k (less_eq$ (times$ ?v0 ?v2)) (times$ ?v1 ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$h (less_eq$b ?v0) ?v1) (and (fun_app$h (less_eq$b ?v2) ?v3) (and (fun_app$h (less_eq$b zero$a) ?v0) (fun_app$h (less_eq$b zero$a) ?v2)))) (fun_app$h (less_eq$b (fun_app$e (times$b ?v0) ?v2)) (fun_app$e (times$b ?v1) ?v3))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$) (?v3 Natural$)) (=> (and (less_eq$a ?v0 ?v1) (and (less_eq$a ?v2 ?v3) (and (less_eq$a zero$b ?v1) (less_eq$a zero$b ?v2)))) (less_eq$a (times$a ?v0 ?v2) (times$a ?v1 ?v3))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$) (?v3 Enat$)) (=> (and (fun_app$k (less_eq$ ?v0) ?v1) (and (fun_app$k (less_eq$ ?v2) ?v3) (and (fun_app$k (less_eq$ zero$) ?v1) (fun_app$k (less_eq$ zero$) ?v2)))) (fun_app$k (less_eq$ (times$ ?v0 ?v2)) (times$ ?v1 ?v3))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$h (less_eq$b ?v0) ?v1) (and (fun_app$h (less_eq$b ?v2) ?v3) (and (fun_app$h (less_eq$b zero$a) ?v1) (fun_app$h (less_eq$b zero$a) ?v2)))) (fun_app$h (less_eq$b (fun_app$e (times$b ?v0) ?v2)) (fun_app$e (times$b ?v1) ?v3))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (=> (and (fun_app$k (less_eq$ ?v0) ?v1) (fun_app$k (less_eq$ zero$) ?v2)) (fun_app$k (less_eq$ (times$ ?v2 ?v0)) (times$ ?v2 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$h (less_eq$b ?v0) ?v1) (fun_app$h (less_eq$b zero$a) ?v2)) (fun_app$h (less_eq$b (fun_app$e (times$b ?v2) ?v0)) (fun_app$e (times$b ?v2) ?v1))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (=> (and (less_eq$a ?v0 ?v1) (less_eq$a zero$b ?v2)) (less_eq$a (times$a ?v0 ?v2) (times$a ?v1 ?v2))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (=> (and (fun_app$k (less_eq$ ?v0) ?v1) (fun_app$k (less_eq$ zero$) ?v2)) (fun_app$k (less_eq$ (times$ ?v0 ?v2)) (times$ ?v1 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$h (less_eq$b ?v0) ?v1) (fun_app$h (less_eq$b zero$a) ?v2)) (fun_app$h (less_eq$b (fun_app$e (times$b ?v0) ?v2)) (fun_app$e (times$b ?v1) ?v2))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (=> (and (less_eq$a ?v0 ?v1) (less_eq$a zero$b ?v2)) (less_eq$a (times$a ?v2 ?v0) (times$a ?v2 ?v1))) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (=> (and (fun_app$k (less_eq$ ?v0) ?v1) (fun_app$k (less_eq$ zero$) ?v2)) (fun_app$k (less_eq$ (times$ ?v2 ?v0)) (times$ ?v2 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$h (less_eq$b ?v0) ?v1) (fun_app$h (less_eq$b zero$a) ?v2)) (fun_app$h (less_eq$b (fun_app$e (times$b ?v2) ?v0)) (fun_app$e (times$b ?v2) ?v1))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (=> (and (less_eq$a ?v0 zero$b) (less_eq$a zero$b ?v1)) (less_eq$a (times$a ?v0 ?v1) zero$b)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$h (less_eq$b ?v0) zero$a) (fun_app$h (less_eq$b zero$a) ?v1)) (fun_app$h (less_eq$b (fun_app$e (times$b ?v0) ?v1)) zero$a)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (=> (and (less_eq$a zero$b ?v0) (less_eq$a ?v1 zero$b)) (less_eq$a (times$a ?v1 ?v0) zero$b)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$h (less_eq$b zero$a) ?v0) (fun_app$h (less_eq$b ?v1) zero$a)) (fun_app$h (less_eq$b (fun_app$e (times$b ?v1) ?v0)) zero$a)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (=> (and (less_eq$a zero$b ?v0) (less_eq$a ?v1 zero$b)) (less_eq$a (times$a ?v0 ?v1) zero$b)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$h (less_eq$b zero$a) ?v0) (fun_app$h (less_eq$b ?v1) zero$a)) (fun_app$h (less_eq$b (fun_app$e (times$b ?v0) ?v1)) zero$a)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (=> (and (less_eq$a zero$b ?v0) (less_eq$a zero$b ?v1)) (less_eq$a zero$b (times$a ?v0 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$h (less_eq$b zero$a) ?v0) (fun_app$h (less_eq$b zero$a) ?v1)) (fun_app$h (less_eq$b zero$a) (fun_app$e (times$b ?v0) ?v1))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (=> (and (less_eq$a zero$b ?v0) (less_eq$a zero$b ?v1)) (less_eq$a zero$b (plus$b ?v0 ?v1))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$h (less_eq$b zero$a) ?v0) (fun_app$h (less_eq$b zero$a) ?v1)) (fun_app$h (less_eq$b zero$a) (fun_app$e (plus$a ?v0) ?v1))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (=> (and (less_eq$a zero$b ?v0) (less_eq$a zero$b ?v1)) (= (= (plus$b ?v0 ?v1) zero$b) (and (= ?v0 zero$b) (= ?v1 zero$b)))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$h (less_eq$b zero$a) ?v0) (fun_app$h (less_eq$b zero$a) ?v1)) (= (= (fun_app$e (plus$a ?v0) ?v1) zero$a) (and (= ?v0 zero$a) (= ?v1 zero$a)))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (=> (and (less_eq$a zero$b ?v0) (less_eq$a ?v1 ?v2)) (less_eq$a ?v1 (plus$b ?v0 ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$h (less_eq$b zero$a) ?v0) (fun_app$h (less_eq$b ?v1) ?v2)) (fun_app$h (less_eq$b ?v1) (fun_app$e (plus$a ?v0) ?v2))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (=> (and (less_eq$a zero$b ?v0) (less_eq$a ?v1 ?v2)) (less_eq$a ?v1 (plus$b ?v2 ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$h (less_eq$b zero$a) ?v0) (fun_app$h (less_eq$b ?v1) ?v2)) (fun_app$h (less_eq$b ?v1) (fun_app$e (plus$a ?v2) ?v0))) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (=> (and (less_eq$a ?v0 zero$b) (less_eq$a ?v1 zero$b)) (less_eq$a (plus$b ?v0 ?v1) zero$b)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$h (less_eq$b ?v0) zero$a) (fun_app$h (less_eq$b ?v1) zero$a)) (fun_app$h (less_eq$b (fun_app$e (plus$a ?v0) ?v1)) zero$a)) ))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$k (less_eq$ infinity$) (enat$ ?v0)) false) :pattern ((enat$ ?v0)))))
(assert (forall ((?v0 Nat$)) (=> (fun_app$k (less_eq$ infinity$) (enat$ ?v0)) false) ))
(assert (forall ((?v0 Enat$) (?v1 Enat$) (?v2 Enat$)) (= (fun_app$k (less_eq$ (fun_app$d (plus$ ?v0) ?v1)) (fun_app$d (plus$ ?v0) ?v2)) (or (= ?v0 infinity$) (fun_app$k (less_eq$ ?v1) ?v2))) ))
(assert (forall ((?v0 A_llist$) (?v1 Enat$)) (! (=> (fun_app$k (less_eq$ (fun_app$f llength$ ?v0)) ?v1) (= (fun_app$ (ltake$ ?v1) ?v0) ?v0)) :pattern ((fun_app$ (ltake$ ?v1) ?v0)))))
(assert (forall ((?v0 A_llist$) (?v1 Enat$)) (! (=> (fun_app$k (less_eq$ (fun_app$f llength$ ?v0)) ?v1) (= (fun_app$ (ldrop$ ?v1) ?v0) lNil$)) :pattern ((fun_app$ (ldrop$ ?v1) ?v0)))))
(assert (forall ((?v0 Enat$) (?v1 A_llist$) (?v2 A_llist$)) (=> (fun_app$k (less_eq$ ?v0) (fun_app$f llength$ ?v1)) (= (fun_app$ (ltake$ ?v0) (fun_app$ (lappend$ ?v1) ?v2)) (fun_app$ (ltake$ ?v0) ?v1))) ))
(assert (forall ((?v0 A_llist$) (?v1 Nat$) (?v2 A_llist$)) (=> (fun_app$k (less_eq$ (fun_app$f llength$ ?v0)) (enat$ ?v1)) (= (fun_app$ (ldropn$ ?v1) (fun_app$ (lappend$ ?v0) ?v2)) (fun_app$ (ldropn$ (fun_app$e (minus$ ?v1) (the_enat$ (fun_app$f llength$ ?v0)))) ?v2))) ))
(assert (forall ((?v0 Nat$) (?v1 A_llist$)) (= (lnull$ (fun_app$ (ldropn$ ?v0) ?v1)) (fun_app$k (less_eq$ (fun_app$f llength$ ?v1)) (enat$ ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 A_llist$) (?v2 Nat$)) (=> (fun_app$k (less_eq$ (enat$ ?v0)) (fun_app$f llength$ ?v1)) (fun_app$k (less_eq$ (enat$ (fun_app$e (minus$ ?v0) ?v2))) (fun_app$f llength$ (fun_app$ (ldropn$ ?v2) ?v1)))) ))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$h (less_eq$b ?v0) zero$a) (= ?v0 zero$a)) :pattern ((less_eq$b ?v0)))))
(assert (forall ((?v0 Nat$)) (fun_app$h (less_eq$b zero$a) ?v0) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$h (less_eq$b (fun_app$e (plus$a ?v0) ?v1)) (fun_app$e (plus$a ?v0) ?v2)) (fun_app$h (less_eq$b ?v1) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$h (less_eq$b ?v0) ?v1) (= (fun_app$e (minus$ ?v1) (fun_app$e (minus$ ?v1) ?v0)) ?v0)) ))
(assert (forall ((?v0 Natural$)) (= (fun_app$o (minus$a zero$b) ?v0) zero$b) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$e (minus$ zero$a) ?v0) zero$a) ))
(assert (forall ((?v0 Natural$)) (! (= (fun_app$o (minus$a ?v0) ?v0) zero$b) :pattern ((minus$a ?v0)))))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$e (minus$ ?v0) ?v0) zero$a) :pattern ((minus$ ?v0)))))
(assert (forall ((?v0 Natural$)) (= (fun_app$o (minus$a ?v0) zero$b) ?v0) ))
(assert (forall ((?v0 Nat$)) (= (fun_app$e (minus$ ?v0) zero$a) ?v0) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (= (fun_app$o (minus$a (plus$b ?v0 ?v1)) ?v0) ?v1) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$e (minus$ (fun_app$e (plus$a ?v0) ?v1)) ?v0) ?v1) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$)) (= (fun_app$o (minus$a (plus$b ?v0 ?v1)) ?v1) ?v0) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$e (minus$ (fun_app$e (plus$a ?v0) ?v1)) ?v1) ?v0) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (fun_app$o (minus$a (plus$b ?v0 ?v1)) (plus$b ?v0 ?v2)) (fun_app$o (minus$a ?v1) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (minus$ (fun_app$e (plus$a ?v0) ?v1)) (fun_app$e (plus$a ?v0) ?v2)) (fun_app$e (minus$ ?v1) ?v2)) ))
(assert (forall ((?v0 Natural$) (?v1 Natural$) (?v2 Natural$)) (= (fun_app$o (minus$a (plus$b ?v0 ?v1)) (plus$b ?v2 ?v1)) (fun_app$o (minus$a ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$e (minus$ (fun_app$e (plus$a ?v0) ?v1)) (fun_app$e (plus$a ?v2) ?v1)) (fun_app$e (minus$ ?v0) ?v2)) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (! (=> (fun_app$h (less_eq$b ?v0) ?v1) (= (fun_app$e (minus$ ?v0) ?v1) zero$a)) :pattern ((fun_app$e (minus$ ?v0) ?v1)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$)) (= (= (fun_app$e (minus$ ?v0) ?v1) zero$a) (fun_app$h (less_eq$b ?v0) ?v1)) ))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$e (minus$ zero$a) ?v0) zero$a) :pattern ((fun_app$e (minus$ zero$a) ?v0)))))
(assert (forall ((?v0 Nat$)) (! (= (fun_app$e (minus$ ?v0) ?v0) zero$a) :pattern ((minus$ ?v0)))))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$h (less_eq$b ?v0) ?v1) (= (fun_app$e (plus$a (fun_app$e (minus$ ?v1) ?v0)) ?v2) (fun_app$e (minus$ (fun_app$e (plus$a ?v1) ?v2)) ?v0))) ))
(assert (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$h (less_eq$b ?v0) ?v1) (= (fun_app$e (plus$a ?v2) (fun_app$e (minus$ ?v1) ?v0)) (fun_app$e (minus$ (fun_app$e (plus$a ?v2) ?v1)) ?v0))) ))
(check-sat)
(exit)

