unsat
(assume a0 (forall ((?v0 A_set$) (?v1 A$)) (= (fun_app$ (uu$ ?v0) ?v1) (member$ ?v1 ?v0))))
(assume a1 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 Nat$) (?v4 Nat$) (?v5 A$)) (= (fun_app$a (uua$ ?v0 ?v1 ?v2 ?v3 ?v4) ?v5) (ite (= ?v5 ?v1) (ite (member$ ?v2 (alphabet$ ?v0)) ?v3 zero$) (ite (= ?v5 ?v2) (ite (member$ ?v1 (alphabet$ ?v0)) ?v4 zero$) (fun_app$a (freq$ ?v0) ?v5))))))
(assume a2 (! (not (! (fun_app$b (! (less_eq$ (! (cost$ (! (swapFourSyms$ t$ a$ b$ c$ d$) :named @p_2)) :named @p_3)) :named @p_4) (! (cost$ t$) :named @p_1)) :named @p_5)) :named @p_6))
(assume a3 (! (consistent$ t$) :named @p_7))
(assume a4 (! (not (! (= c$ d$) :named @p_8)) :named @p_9))
(assume a5 (! (member$ c$ (! (alphabet$ t$) :named @p_10)) :named @p_11))
(assume a6 (! (member$ d$ @p_10) :named @p_12))
(assume a7 (! (= (! (depth$ t$ c$) :named @p_14) (! (height$ t$) :named @p_13)) :named @p_15))
(assume a8 (! (= (! (depth$ t$ d$) :named @p_16) @p_13) :named @p_17))
(assume a9 (! (fun_app$ (fun_app$c (minima$ t$) a$) b$) :named @p_18))
(assume a10 (! (not (and (! (not (! (= a$ d$) :named @p_21)) :named @p_22) (! (not (! (= b$ c$) :named @p_19)) :named @p_20))) :named @p_23))
(assume a11 (forall ((?v0 A$) (?v1 A_tree$) (?v2 A$) (?v3 A$) (?v4 A$)) (=> (and (member$ ?v0 (alphabet$ ?v1)) (and (member$ ?v2 (alphabet$ ?v1)) (and (member$ ?v3 (alphabet$ ?v1)) (member$ ?v4 (alphabet$ ?v1))))) (= (alphabet$ (swapFourSyms$ ?v1 ?v0 ?v2 ?v3 ?v4)) (alphabet$ ?v1)))))
(assume a12 (forall ((?v0 Nat$)) (fun_app$b (less_eq$ ?v0) ?v0)))
(assume a13 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (=> (consistent$ ?v0) (consistent$ (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4)))))
(assume a14 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (= ?v0 ?v1) (fun_app$b (less_eq$ ?v0) ?v1))))
(assume a15 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less_eq$ ?v1) ?v0)) (= ?v0 ?v1))))
(assume a16 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less_eq$ ?v1) ?v2)) (fun_app$b (less_eq$ ?v0) ?v2))))
(assume a17 (forall ((?v0 Nat$) (?v1 Nat$)) (or (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less_eq$ ?v1) ?v0))))
(assume a18 (forall ((?v0 Nat$) (?v1 Nat$)) (= (= ?v0 ?v1) (and (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less_eq$ ?v1) ?v0)))))
(assume a19 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (=> (fun_app$b (less_eq$ ?v0) ?v1) false) (=> (fun_app$b (less_eq$ ?v1) ?v0) false)) false)))
(assume a20 (forall ((?v0 A_tree$)) (=> (consistent$ ?v0) (exists ((?v1 A$)) (and (member$ ?v1 (alphabet$ ?v0)) (= (depth$ ?v0 ?v1) (height$ ?v0)))))))
(assume a21 (forall ((?v0 A_tree$)) (exists ((?v1 A$)) (member$ ?v1 (alphabet$ ?v0)))))
(assume a22 (forall ((?v0 A_tree$) (?v1 A$)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (height$ ?v0))))
(assume a23 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$b (less_eq$ ?v0) ?v1) (= (fun_app$b (less_eq$ ?v1) ?v0) (= ?v1 ?v0)))))
(assume a24 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less_eq$ ?v2) ?v0)) (fun_app$b (less_eq$ ?v2) ?v1))))
(assume a25 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less_eq$ ?v1) ?v0)) (= ?v1 ?v0))))
(assume a26 (forall ((?v0 Nat$) (?v1 Nat_nat_fun$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) (fun_app$d ?v1 ?v2)) (and (fun_app$b (less_eq$ ?v2) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$b (less_eq$ ?v4) ?v5) (fun_app$b (less_eq$ (fun_app$d ?v1 ?v4)) (fun_app$d ?v1 ?v5)))))) (fun_app$b (less_eq$ ?v0) (fun_app$d ?v1 ?v3)))))
(assume a27 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_nat_fun$) (?v3 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) ?v1) (and (fun_app$b (less_eq$ (fun_app$d ?v2 ?v1)) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$b (less_eq$ ?v4) ?v5) (fun_app$b (less_eq$ (fun_app$d ?v2 ?v4)) (fun_app$d ?v2 ?v5)))))) (fun_app$b (less_eq$ (fun_app$d ?v2 ?v0)) ?v3))))
(assume a28 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) ?v1) (= ?v1 ?v2)) (fun_app$b (less_eq$ ?v0) ?v2))))
(assume a29 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_nat_fun$) (?v3 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) ?v1) (and (= (fun_app$d ?v2 ?v1) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$b (less_eq$ ?v4) ?v5) (fun_app$b (less_eq$ (fun_app$d ?v2 ?v4)) (fun_app$d ?v2 ?v5)))))) (fun_app$b (less_eq$ (fun_app$d ?v2 ?v0)) ?v3))))
(assume a30 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (= ?v0 ?v1) (fun_app$b (less_eq$ ?v1) ?v2)) (fun_app$b (less_eq$ ?v0) ?v2))))
(assume a31 (forall ((?v0 Nat$) (?v1 Nat_nat_fun$) (?v2 Nat$) (?v3 Nat$)) (=> (and (= ?v0 (fun_app$d ?v1 ?v2)) (and (fun_app$b (less_eq$ ?v2) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$b (less_eq$ ?v4) ?v5) (fun_app$b (less_eq$ (fun_app$d ?v1 ?v4)) (fun_app$d ?v1 ?v5)))))) (fun_app$b (less_eq$ ?v0) (fun_app$d ?v1 ?v3)))))
(assume a32 (forall ((?v0 Nat_nat_bool_fun_fun$) (?v1 Nat$) (?v2 Nat$)) (=> (and (forall ((?v3 Nat$) (?v4 Nat$)) (=> (fun_app$b (less_eq$ ?v3) ?v4) (fun_app$b (fun_app$e ?v0 ?v3) ?v4))) (forall ((?v3 Nat$) (?v4 Nat$)) (=> (fun_app$b (fun_app$e ?v0 ?v4) ?v3) (fun_app$b (fun_app$e ?v0 ?v3) ?v4)))) (fun_app$b (fun_app$e ?v0 ?v1) ?v2))))
(assume a33 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$)) (=> (and (consistent$ ?v0) (and (not (= ?v1 ?v2)) (not (= ?v1 ?v3)))) (= (depth$ (fun_app$f (swapSyms$ ?v0 ?v2) ?v3) ?v1) (depth$ ?v0 ?v1)))))
(assume a34 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (member$ ?v3 (alphabet$ ?v0)) (member$ ?v4 (alphabet$ ?v0)))))) (= (freq$ (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4)) (freq$ ?v0)))))
(assume a35 (forall ((?v0 A_bool_fun$) (?v1 A_bool_fun$)) (=> (forall ((?v2 A$)) (= (fun_app$ ?v0 ?v2) (fun_app$ ?v1 ?v2))) (= (collect$ ?v0) (collect$ ?v1)))))
(assume a36 (forall ((?v0 A_set$)) (= (collect$ (uu$ ?v0)) ?v0)))
(assume a37 (forall ((?v0 A$) (?v1 A_bool_fun$)) (= (member$ ?v0 (collect$ ?v1)) (fun_app$ ?v1 ?v0))))
(assume a38 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (= (fun_app$ (fun_app$c (minima$ ?v0) ?v1) ?v2) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (not (= ?v1 ?v2)) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (forall ((?v3 A$)) (=> (and (member$ ?v3 (alphabet$ ?v0)) (and (not (= ?v3 ?v1)) (not (= ?v3 ?v2)))) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3))))))))))))
(assume a39 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 Nat$) (?v5 Nat$)) (=> (and (consistent$ ?v0) (and (not (= ?v1 ?v2)) (not (= ?v1 ?v3)))) (= (depth$ (fun_app$f (swapLeaves$ ?v0 ?v4 ?v2 ?v5) ?v3) ?v1) (depth$ ?v0 ?v1)))))
(assume a40 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (member$ ?v3 (alphabet$ ?v0)) (and (not (= ?v1 ?v2)) (not (= (sibling$ ?v0 ?v3) ?v3))))))) (= (sibling$ (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 (sibling$ ?v0 ?v3)) ?v1) ?v2))))
(assume a41 (forall ((?v0 A_tree$) (?v1 A$) (?v2 Nat$) (?v3 A$) (?v4 Nat$)) (=> (and (consistent$ ?v0) (not (member$ ?v1 (alphabet$ ?v0)))) (consistent$ (splitLeaf$ ?v0 ?v2 ?v3 ?v4 ?v1)))))
(assume a42 (forall ((?v0 A_tree$)) (= (optimum$ ?v0) (forall ((?v1 A_tree$)) (=> (and (consistent$ ?v1) (and (= (alphabet$ ?v0) (alphabet$ ?v1)) (= (freq$ ?v0) (freq$ ?v1)))) (fun_app$b (less_eq$ (cost$ ?v0)) (cost$ ?v1)))))))
(assume a43 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2)))))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0)))))
(assume a44 (forall ((?v0 A_tree$)) (=> (= (height$ ?v0) zero$) (= (cost$ ?v0) zero$))))
(assume a45 (forall ((?v0 Nat$)) (= (fun_app$b (less_eq$ ?v0) zero$) (= ?v0 zero$))))
(assume a46 (forall ((?v0 Nat$)) (fun_app$b (less_eq$ zero$) ?v0)))
(assume a47 (forall ((?v0 A$) (?v1 A_tree$)) (=> (not (member$ ?v0 (alphabet$ ?v1))) (= (sibling$ ?v1 ?v0) ?v0))))
(assume a48 (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$ ?v0) (= (sibling$ ?v0 (sibling$ ?v0 ?v1)) ?v1))))
(assume a49 (forall ((?v0 A$) (?v1 A_tree$) (?v2 Nat$) (?v3 Nat$)) (=> (not (member$ ?v0 (alphabet$ ?v1))) (= (fun_app$f (swapLeaves$ ?v1 ?v2 ?v0 ?v3) ?v0) ?v1))))
(assume a50 (forall ((?v0 A$) (?v1 A_tree$) (?v2 A$)) (=> (and (member$ ?v0 (alphabet$ ?v1)) (member$ ?v2 (alphabet$ ?v1))) (= (alphabet$ (fun_app$f (swapSyms$ ?v1 ?v0) ?v2)) (alphabet$ ?v1)))))
(assume a51 (forall ((?v0 A_tree$) (?v1 Nat$) (?v2 A$) (?v3 Nat$) (?v4 A$)) (= (height$ (fun_app$f (swapLeaves$ ?v0 ?v1 ?v2 ?v3) ?v4)) (height$ ?v0))))
(assume a52 (forall ((?v0 A$) (?v1 A_tree$) (?v2 Nat$) (?v3 Nat$) (?v4 A$)) (=> (not (member$ ?v0 (alphabet$ ?v1))) (= (splitLeaf$ ?v1 ?v2 ?v0 ?v3 ?v4) ?v1))))
(assume a53 (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$ ?v0) (= (fun_app$f (swapSyms$ ?v0 ?v1) ?v1) ?v0))))
(assume a54 (forall ((?v0 A$) (?v1 A_tree$)) (=> (not (member$ ?v0 (alphabet$ ?v1))) (= (fun_app$a (freq$ ?v1) ?v0) zero$))))
(assume a55 (forall ((?v0 A_tree$) (?v1 A$)) (=> (= (height$ ?v0) zero$) (= (sibling$ ?v0 ?v1) ?v1))))
(assume a56 (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$ ?v0) (= (depth$ ?v0 (sibling$ ?v0 ?v1)) (depth$ ?v0 ?v1)))))
(assume a57 (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$ ?v0) (= (fun_app$f (swapLeaves$ ?v0 (fun_app$a (freq$ ?v0) ?v1) ?v1 (fun_app$a (freq$ ?v0) ?v1)) ?v1) ?v0))))
(assume a58 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 Nat$) (?v4 Nat$)) (=> (and (consistent$ ?v0) (and (not (= (sibling$ ?v0 ?v1) ?v1)) (not (= ?v2 ?v1)))) (= (sibling$ (fun_app$f (swapLeaves$ ?v0 ?v3 ?v2 ?v4) (sibling$ ?v0 ?v1)) ?v2) ?v1))))
(assume a59 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (and (not (= (sibling$ ?v0 ?v1) ?v1)) (not (= ?v2 ?v1)))) (= (sibling$ (fun_app$f (swapSyms$ ?v0 ?v2) (sibling$ ?v0 ?v1)) ?v2) ?v1))))
(assume a60 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (and (not (= (sibling$ ?v0 ?v1) ?v2)) (and (not (= (sibling$ ?v0 ?v1) ?v1)) (not (= ?v2 ?v1))))) (= (sibling$ (fun_app$f (swapSyms$ ?v0 ?v2) ?v1) (sibling$ ?v0 ?v1)) ?v2))))
(assume a61 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)))) (= (freq$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2)) (freq$ ?v0)))))
(assume a62 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 Nat$) (?v4 Nat$)) (=> (and (consistent$ ?v0) (not (= ?v1 ?v2))) (= (freq$ (fun_app$f (swapLeaves$ ?v0 ?v3 ?v1 ?v4) ?v2)) (uua$ ?v0 ?v1 ?v2 ?v3 ?v4)))))
(assume a63 (forall ((?v0 Nat$)) (=> (and (=> (= ?v0 zero$) false) (=> (not (= ?v0 zero$)) false)) false)))
(assume a64 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (= (fun_app$f (swapSyms$ ?v0 ?v1) ?v2) (fun_app$f (swapLeaves$ ?v0 (fun_app$a (freq$ ?v0) ?v1) ?v1 (fun_app$a (freq$ ?v0) ?v2)) ?v2))))
(assume a65 (forall ((?v0 Nat$)) (= (fun_app$b (less_eq$ zero$) ?v0) true)))
(assume a66 (forall ((?v0 A_tree$) (?v1 A$)) (=> (not (= (sibling$ ?v0 ?v1) ?v1)) (member$ (sibling$ ?v0 ?v1) (alphabet$ ?v0)))))
(assume a67 (forall ((?v0 A$) (?v1 A_tree$)) (=> (member$ ?v0 (alphabet$ ?v1)) (member$ (sibling$ ?v1 ?v0) (alphabet$ ?v1)))))
(assume a68 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (= (sibling$ ?v0 ?v1) ?v2)) (= (sibling$ ?v0 ?v2) ?v1))))
(assume a69 (forall ((?v0 A_tree$) (?v1 Nat$) (?v2 A$) (?v3 Nat$) (?v4 A$)) (=> (consistent$ ?v0) (consistent$ (fun_app$f (swapLeaves$ ?v0 ?v1 ?v2 ?v3) ?v4)))))
(assume a70 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (consistent$ ?v0) (consistent$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2)))))
(assume a71 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (= (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4) (ite (= ?v1 ?v4) (fun_app$f (swapSyms$ ?v0 ?v2) ?v3) (ite (= ?v2 ?v3) (fun_app$f (swapSyms$ ?v0 ?v1) ?v4) (fun_app$f (swapSyms$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v3) ?v2) ?v4))))))
(assume a72 (forall ((?v0 A_tree$) (?v1 A$) (?v2 Nat$) (?v3 Nat$) (?v4 A$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (= (fun_app$a (freq$ ?v0) ?v1) (fun_app$d (plus$ ?v2) ?v3)))) (= (cost$ (splitLeaf$ ?v0 ?v2 ?v1 ?v3 ?v4)) (fun_app$d (plus$ (fun_app$d (plus$ (cost$ ?v0)) ?v2)) ?v3)))))
(assume a73 (forall ((?v0 A_tree$) (?v1 A$)) (=> (and (consistent$ ?v0) (and (= (depth$ ?v0 ?v1) (height$ ?v0)) (and (fun_app$b (less$ zero$) (height$ ?v0)) (member$ ?v1 (alphabet$ ?v0))))) (not (= (sibling$ ?v0 ?v1) ?v1)))))
(assume a74 (fun_app$b (less_eq$ zero$) zero$))
(assume a75 (forall ((?v0 A_tree$) (?v1 A_tree$)) (=> (and (fun_app$b (less$ zero$) (height$ ?v0)) (and (consistent$ ?v0) (= (alphabet$ ?v0) (alphabet$ ?v1)))) (fun_app$b (less$ zero$) (height$ ?v1)))))
(assume a76 (forall ((?v0 Nat$)) (= (fun_app$b (less_eq$ (of_nat$ ?v0)) zero$) (= ?v0 zero$))))
(assume a77 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)))) (= (fun_app$d (plus$ (fun_app$d (plus$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (fun_app$d (times$ (fun_app$a (freq$ ?v0) ?v1)) (depth$ ?v0 ?v1)))) (fun_app$d (times$ (fun_app$a (freq$ ?v0) ?v2)) (depth$ ?v0 ?v2))) (fun_app$d (plus$ (fun_app$d (plus$ (cost$ ?v0)) (fun_app$d (times$ (fun_app$a (freq$ ?v0) ?v1)) (depth$ ?v0 ?v2)))) (fun_app$d (times$ (fun_app$a (freq$ ?v0) ?v2)) (depth$ ?v0 ?v1)))))))
(assume a78 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$d (plus$ ?v0) ?v1) (fun_app$d (plus$ ?v2) ?v1)) (= ?v0 ?v2))))
(assume a79 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$d (plus$ ?v0) ?v1) (fun_app$d (plus$ ?v0) ?v2)) (= ?v1 ?v2))))
(assume a80 (forall ((?v0 Nat$) (?v1 Nat$)) (= (= (of_nat$ ?v0) (of_nat$ ?v1)) (= ?v0 ?v1))))
(assume a81 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$b (less_eq$ (fun_app$d (plus$ ?v0) ?v1)) (fun_app$d (plus$ ?v2) ?v1)) (fun_app$b (less_eq$ ?v0) ?v2))))
(assume a82 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$b (less_eq$ (fun_app$d (plus$ ?v0) ?v1)) (fun_app$d (plus$ ?v0) ?v2)) (fun_app$b (less_eq$ ?v1) ?v2))))
(assume a83 (forall ((?v0 Nat$)) (= (fun_app$d (plus$ zero$) ?v0) ?v0)))
(assume a84 (forall ((?v0 Nat$)) (= (fun_app$d (plus$ ?v0) zero$) ?v0)))
(assume a85 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v1)) (fun_app$d (plus$ ?v2) ?v1)) (fun_app$b (less$ ?v0) ?v2))))
(assume a86 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v1)) (fun_app$d (plus$ ?v0) ?v2)) (fun_app$b (less$ ?v1) ?v2))))
(assume a87 (forall ((?v0 Nat$)) (= (fun_app$b (less$ ?v0) zero$) false)))
(assume a88 (forall ((?v0 Nat$)) (= (not (fun_app$b (less$ zero$) ?v0)) (= ?v0 zero$))))
(assume a89 (forall ((?v0 Nat$)) (= (not (= ?v0 zero$)) (fun_app$b (less$ zero$) ?v0))))
(assume a90 (forall ((?v0 Nat$) (?v1 Nat$)) (= (= (fun_app$d (plus$ ?v0) ?v1) zero$) (and (= ?v0 zero$) (= ?v1 zero$)))))
(assume a91 (forall ((?v0 Nat$)) (= (fun_app$d (times$ ?v0) zero$) zero$)))
(assume a92 (forall ((?v0 Nat$) (?v1 Nat$)) (= (= (fun_app$d (times$ ?v0) ?v1) zero$) (or (= ?v0 zero$) (= ?v1 zero$)))))
(assume a93 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$d (times$ ?v0) ?v1) (fun_app$d (times$ ?v0) ?v2)) (or (= ?v1 ?v2) (= ?v0 zero$)))))
(assume a94 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (= (fun_app$d (times$ ?v0) ?v1) (fun_app$d (times$ ?v2) ?v1)) (or (= ?v0 ?v2) (= ?v1 zero$)))))
(assume a95 (= (of_nat$ zero$) zero$))
(assume a96 (forall ((?v0 Nat$)) (= (= zero$ (of_nat$ ?v0)) (= zero$ ?v0))))
(assume a97 (forall ((?v0 Nat$)) (= (= (of_nat$ ?v0) zero$) (= ?v0 zero$))))
(assume a98 (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$b (less$ (of_nat$ ?v0)) (of_nat$ ?v1)) (fun_app$b (less$ ?v0) ?v1))))
(assume a99 (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$b (less_eq$ (of_nat$ ?v0)) (of_nat$ ?v1)) (fun_app$b (less_eq$ ?v0) ?v1))))
(assume a100 (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$b (less$ zero$) (fun_app$d (plus$ ?v0) ?v1)) (or (fun_app$b (less$ zero$) ?v0) (fun_app$b (less$ zero$) ?v1)))))
(assume a101 (forall ((?v0 Nat$) (?v1 Nat$)) (= (of_nat$ (fun_app$d (plus$ ?v0) ?v1)) (fun_app$d (plus$ (of_nat$ ?v0)) (of_nat$ ?v1)))))
(assume a102 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$b (less$ (fun_app$d (times$ ?v0) ?v1)) (fun_app$d (times$ ?v2) ?v1)) (and (fun_app$b (less$ zero$) ?v1) (fun_app$b (less$ ?v0) ?v2)))))
(assume a103 (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$b (less$ zero$) (fun_app$d (times$ ?v0) ?v1)) (and (fun_app$b (less$ zero$) ?v0) (fun_app$b (less$ zero$) ?v1)))))
(assume a104 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$b (less_eq$ (fun_app$d (times$ ?v0) ?v1)) (fun_app$d (times$ ?v2) ?v1)) (=> (fun_app$b (less$ zero$) ?v1) (fun_app$b (less_eq$ ?v0) ?v2)))))
(assume a105 (forall ((?v0 Nat$)) (= (fun_app$b (less$ zero$) (of_nat$ ?v0)) (fun_app$b (less$ zero$) ?v0))))
(assume a106 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less$ zero$) ?v2)) (fun_app$b (less$ (fun_app$d (times$ ?v2) ?v0)) (fun_app$d (times$ ?v2) ?v1)))))
(assume a107 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less$ zero$) ?v2)) (fun_app$b (less$ (fun_app$d (times$ ?v0) ?v2)) (fun_app$d (times$ ?v1) ?v2)))))
(assume a108 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$b (less$ ?v0) ?v1) (exists ((?v2 Nat$)) (and (fun_app$b (less$ zero$) ?v2) (= (fun_app$d (plus$ ?v0) ?v2) ?v1))))))
(assume a109 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$b (less$ ?v0) zero$) (fun_app$b (less_eq$ ?v1) zero$)) (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v1)) zero$))))
(assume a110 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$b (less$ zero$) ?v0) (fun_app$b (less_eq$ ?v1) ?v2)) (fun_app$b (less$ ?v1) (fun_app$d (plus$ ?v0) ?v2)))))
(assume a111 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$b (less$ zero$) ?v0) (fun_app$b (less_eq$ zero$) ?v1)) (fun_app$b (less$ zero$) (fun_app$d (plus$ ?v0) ?v1)))))
(assume a112 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) zero$) (fun_app$b (less$ ?v1) zero$)) (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v1)) zero$))))
(assume a113 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$b (less_eq$ zero$) ?v0) (fun_app$b (less$ ?v1) ?v2)) (fun_app$b (less$ ?v1) (fun_app$d (plus$ ?v0) ?v2)))))
(assume a114 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$b (less_eq$ zero$) ?v0) (fun_app$b (less$ zero$) ?v1)) (fun_app$b (less$ zero$) (fun_app$d (plus$ ?v0) ?v1)))))
(assume a115 (forall ((?v0 Nat$)) (not (fun_app$b (less$ (of_nat$ ?v0)) zero$))))
(assume a116 (not (fun_app$b (less$ zero$) zero$)))
(assume a117 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$b (less$ zero$) ?v0) (fun_app$b (less$ zero$) ?v1)) (fun_app$b (less$ zero$) (fun_app$d (plus$ ?v0) ?v1)))))
(assume a118 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$b (less$ ?v0) zero$) (fun_app$b (less$ ?v1) zero$)) (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v1)) zero$))))
(assume a119 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less_eq$ ?v2) ?v3)) (fun_app$b (less_eq$ (fun_app$d (plus$ (fun_app$d (times$ ?v0) ?v3)) (fun_app$d (times$ ?v1) ?v2))) (fun_app$d (plus$ (fun_app$d (times$ ?v0) ?v2)) (fun_app$d (times$ ?v1) ?v3))))))
(assume a120 (forall ((?v0 Nat_nat_fun$) (?v1 Nat$) (?v2 Nat$)) (=> (forall ((?v3 Nat$) (?v4 Nat$)) (=> (fun_app$b (less$ ?v3) ?v4) (fun_app$b (less$ (fun_app$d ?v0 ?v3)) (fun_app$d ?v0 ?v4)))) (fun_app$b (less_eq$ (fun_app$d (plus$ (fun_app$d ?v0 ?v1)) ?v2)) (fun_app$d ?v0 (fun_app$d (plus$ ?v1) ?v2))))))
(assume a121 (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$b (less_eq$ ?v0) ?v1) (exists ((?v2 Nat$)) (= ?v1 (fun_app$d (plus$ ?v0) ?v2))))))
(assume a122 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (= ?v0 ?v1) (fun_app$b (less_eq$ ?v2) ?v3)) (fun_app$b (less_eq$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v3)))))
(assume a123 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) ?v1) (= ?v2 ?v3)) (fun_app$b (less_eq$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v3)))))
(assume a124 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less_eq$ ?v2) ?v3)) (fun_app$b (less_eq$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v3)))))
(assume a125 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$b (less_eq$ (fun_app$d (plus$ ?v0) ?v1)) (fun_app$d (plus$ ?v2) ?v1)) (fun_app$b (less_eq$ ?v0) ?v2))))
(assume a126 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$b (less_eq$ (fun_app$d (plus$ ?v0) ?v1)) (fun_app$d (plus$ ?v0) ?v2)) (fun_app$b (less_eq$ ?v1) ?v2))))
(assume a127 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less_eq$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v2)))))
(assume a128 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less_eq$ (fun_app$d (plus$ ?v2) ?v0)) (fun_app$d (plus$ ?v2) ?v1)))))
(assume a129 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$d (plus$ (fun_app$d (plus$ ?v0) ?v1)) ?v2) (fun_app$d (plus$ ?v0) (fun_app$d (plus$ ?v1) ?v2)))))
(assume a130 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$d (plus$ ?v0) (fun_app$d (plus$ ?v1) ?v2)) (fun_app$d (plus$ ?v1) (fun_app$d (plus$ ?v0) ?v2)))))
(assume a131 (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$d (plus$ ?v0) ?v1) (fun_app$d (plus$ ?v1) ?v0))))
(assume a132 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$d (times$ (fun_app$d (times$ ?v0) ?v1)) ?v2) (fun_app$d (times$ ?v0) (fun_app$d (times$ ?v1) ?v2)))))
(assume a133 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$d (times$ ?v0) (fun_app$d (times$ ?v1) ?v2)) (fun_app$d (times$ ?v1) (fun_app$d (times$ ?v0) ?v2)))))
(assume a134 (forall ((?v0 Nat$) (?v1 Nat$)) (= (fun_app$d (times$ ?v0) ?v1) (fun_app$d (times$ ?v1) ?v0))))
(assume a135 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (= (fun_app$d (plus$ ?v0) ?v1) (fun_app$d (plus$ ?v2) ?v1)) (= ?v0 ?v2))))
(assume a136 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (= (fun_app$d (plus$ ?v0) ?v1) (fun_app$d (plus$ ?v0) ?v2)) (= ?v1 ?v2))))
(assume a137 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (= ?v0 ?v1) (= ?v2 ?v3)) (= (fun_app$d (plus$ ?v0) ?v2) (fun_app$d (plus$ ?v1) ?v3)))))
(assume a138 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (= ?v0 ?v1) (fun_app$b (less$ ?v2) ?v3)) (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v3)))))
(assume a139 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (= ?v2 ?v3)) (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v3)))))
(assume a140 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less$ ?v2) ?v3)) (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v3)))))
(assume a141 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v1)) (fun_app$d (plus$ ?v2) ?v1)) (fun_app$b (less$ ?v0) ?v2))))
(assume a142 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v1)) (fun_app$d (plus$ ?v0) ?v2)) (fun_app$b (less$ ?v1) ?v2))))
(assume a143 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v2)))))
(assume a144 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less$ (fun_app$d (plus$ ?v2) ?v0)) (fun_app$d (plus$ ?v2) ?v1)))))
(assume a145 (forall ((?v0 Nat$)) (not (fun_app$b (less$ ?v0) ?v0))))
(assume a146 (forall ((?v0 Nat$) (?v1 Nat$)) (not (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v1)) ?v0))))
(assume a147 (forall ((?v0 Nat$) (?v1 Nat$)) (not (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v1)) ?v1))))
(assume a148 (forall ((?v0 Nat$)) (exists ((?v1 Nat$)) (fun_app$b (less$ ?v0) ?v1))))
(assume a149 (forall ((?v0 Nat$) (?v1 Nat$)) (or (fun_app$b (less$ ?v0) ?v1) (or (= ?v0 ?v1) (fun_app$b (less$ ?v1) ?v0)))))
(assume a150 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (not (fun_app$b (less$ ?v0) ?v1)) (= (not (fun_app$b (less$ ?v1) ?v0)) (= ?v1 ?v0)))))
(assume a151 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (not (= ?v0 ?v1)) (and (=> (fun_app$b (less$ ?v0) ?v1) false) (=> (fun_app$b (less$ ?v1) ?v0) false))) false)))
(assume a152 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less$ ?v2) ?v3)) (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v3)))))
(assume a153 (forall ((?v0 Nat$)) (=> (fun_app$b (less$ ?v0) ?v0) false)))
(assume a154 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$b (less$ ?v0) ?v1) (not (fun_app$b (less$ ?v1) ?v0)))))
(assume a155 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$b (less$ ?v0) ?v1) (not (= ?v1 ?v0)))))
(assume a156 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$b (less$ ?v0) ?v1) (not (= ?v0 ?v1)))))
(assume a157 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less$ ?v0) (fun_app$d (plus$ ?v1) ?v2)))))
(assume a158 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less$ ?v0) (fun_app$d (plus$ ?v2) ?v1)))))
(assume a159 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less$ (of_nat$ ?v0)) (of_nat$ ?v1)))))
(assume a160 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$b (less$ ?v0) ?v1) (= (not (fun_app$b (less$ ?v1) ?v0)) true))))
(assume a161 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Bool)) (=> (fun_app$b (less$ ?v0) ?v1) (= (=> (fun_app$b (less$ ?v1) ?v0) ?v2) true))))
(assume a162 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$b (less$ ?v0) ?v1) (= (= ?v0 ?v1) false))))
(assume a163 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$b (less$ ?v0) ?v1) (= (= ?v1 ?v0) false))))
(assume a164 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less_eq$ ?v2) ?v3)) (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v2)) (fun_app$d (plus$ ?v1) ?v3)))))
(assume a165 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less$ ?v1) ?v0)) false)))
(assume a166 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less$ ?v1) ?v2)) (fun_app$b (less$ ?v0) ?v2))))
(assume a167 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less$ ?v2) ?v0)) (fun_app$b (less$ ?v2) ?v1))))
(assume a168 (forall ((?v0 Nat$) (?v1 Nat_nat_fun$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$b (less$ ?v0) (fun_app$d ?v1 ?v2)) (and (fun_app$b (less$ ?v2) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$b (less$ ?v4) ?v5) (fun_app$b (less$ (fun_app$d ?v1 ?v4)) (fun_app$d ?v1 ?v5)))))) (fun_app$b (less$ ?v0) (fun_app$d ?v1 ?v3)))))
(assume a169 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_nat_fun$) (?v3 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (and (fun_app$b (less$ (fun_app$d ?v2 ?v1)) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$b (less$ ?v4) ?v5) (fun_app$b (less$ (fun_app$d ?v2 ?v4)) (fun_app$d ?v2 ?v5)))))) (fun_app$b (less$ (fun_app$d ?v2 ?v0)) ?v3))))
(assume a170 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (= ?v1 ?v2)) (fun_app$b (less$ ?v0) ?v2))))
(assume a171 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_nat_fun$) (?v3 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (and (= (fun_app$d ?v2 ?v1) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$b (less$ ?v4) ?v5) (fun_app$b (less$ (fun_app$d ?v2 ?v4)) (fun_app$d ?v2 ?v5)))))) (fun_app$b (less$ (fun_app$d ?v2 ?v0)) ?v3))))
(assume a172 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$) (?v3 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (= (fun_app$d (plus$ ?v2) ?v1) (fun_app$d (plus$ ?v0) ?v3))) (fun_app$b (less$ ?v2) ?v3))))
(assume a173 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (fun_app$b (less$ ?v0) ?v1) (=> (not false) (fun_app$b (less$ ?v1) ?v0))) false)))
(assume a174 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$b (less$ (of_nat$ ?v0)) (of_nat$ ?v1)) (fun_app$b (less$ ?v0) ?v1))))
(assume a175 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (fun_app$b (less$ (fun_app$d (plus$ ?v0) ?v1)) ?v2) (fun_app$b (less$ ?v0) ?v2))))
(assume a176 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (=> (and (= ?v0 ?v1) (fun_app$b (less$ ?v1) ?v2)) (fun_app$b (less$ ?v0) ?v2))))
(assume a177 (forall ((?v0 Nat$) (?v1 Nat_nat_fun$) (?v2 Nat$) (?v3 Nat$)) (=> (and (= ?v0 (fun_app$d ?v1 ?v2)) (and (fun_app$b (less$ ?v2) ?v3) (forall ((?v4 Nat$) (?v5 Nat$)) (=> (fun_app$b (less$ ?v4) ?v5) (fun_app$b (less$ (fun_app$d ?v1 ?v4)) (fun_app$d ?v1 ?v5)))))) (fun_app$b (less$ ?v0) (fun_app$d ?v1 ?v3)))))
(assume a178 (forall ((?v0 Nat_bool_fun$) (?v1 Nat$)) (=> (forall ((?v2 Nat$)) (=> (forall ((?v3 Nat$)) (=> (fun_app$b (less$ ?v3) ?v2) (fun_app$b ?v0 ?v3))) (fun_app$b ?v0 ?v2))) (fun_app$b ?v0 ?v1))))
(assume a179 (forall ((?v0 Nat_bool_fun$) (?v1 Nat$)) (=> (forall ((?v2 Nat$)) (=> (not (fun_app$b ?v0 ?v2)) (exists ((?v3 Nat$)) (and (fun_app$b (less$ ?v3) ?v2) (not (fun_app$b ?v0 ?v3)))))) (fun_app$b ?v0 ?v1))))
(assume a180 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat_nat_bool_fun_fun$)) (=> (and (=> (fun_app$b (less$ ?v0) ?v1) (fun_app$b (fun_app$e ?v2 ?v1) ?v0)) (and (=> (= ?v0 ?v1) (fun_app$b (fun_app$e ?v2 ?v1) ?v0)) (=> (fun_app$b (less$ ?v1) ?v0) (fun_app$b (fun_app$e ?v2 ?v1) ?v0)))) (fun_app$b (fun_app$e ?v2 ?v1) ?v0))))
(assume a181 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (=> (fun_app$b (less$ ?v0) ?v1) false) (and (=> (= ?v0 ?v1) false) (=> (fun_app$b (less$ ?v1) ?v0) false))) false)))
(assume a182 (forall ((?v0 Nat$) (?v1 Nat$)) (= (of_nat$ (fun_app$d (times$ ?v0) ?v1)) (fun_app$d (times$ (of_nat$ ?v0)) (of_nat$ ?v1)))))
(assume a183 (forall ((?v0 Nat$) (?v1 Nat$)) (= (not (fun_app$b (less$ ?v0) ?v1)) (or (fun_app$b (less$ ?v1) ?v0) (= ?v0 ?v1)))))
(assume a184 (forall ((?v0 Nat$) (?v1 Nat$)) (= (not (= ?v0 ?v1)) (or (fun_app$b (less$ ?v0) ?v1) (fun_app$b (less$ ?v1) ?v0)))))
(assume a185 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$d (times$ ?v0) (fun_app$d (plus$ ?v1) ?v2)) (fun_app$d (plus$ (fun_app$d (times$ ?v0) ?v1)) (fun_app$d (times$ ?v0) ?v2)))))
(assume a186 (forall ((?v0 Nat$) (?v1 Nat$) (?v2 Nat$)) (= (fun_app$d (times$ (fun_app$d (plus$ ?v0) ?v1)) ?v2) (fun_app$d (plus$ (fun_app$d (times$ ?v0) ?v2)) (fun_app$d (times$ ?v1) ?v2)))))
(assume a187 (forall ((?v0 Nat$) (?v1 Nat$)) (or (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less$ ?v1) ?v0))))
(assume a188 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (not (fun_app$b (less_eq$ ?v0) ?v1)) (fun_app$b (less$ ?v1) ?v0))))
(assume a189 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (not (fun_app$b (less$ ?v0) ?v1)) (fun_app$b (less_eq$ ?v1) ?v0))))
(assume a190 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (not (fun_app$b (less$ ?v0) ?v1)) (= (fun_app$b (less_eq$ ?v0) ?v1) (= ?v0 ?v1)))))
(assume a191 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (and (not (= ?v0 ?v1)) (fun_app$b (less_eq$ ?v0) ?v1)) (fun_app$b (less$ ?v0) ?v1))))
(assume a192 (forall ((?v0 Nat$) (?v1 Nat$)) (=> (fun_app$b (less_eq$ ?v0) ?v1) (not (fun_app$b (less$ ?v1) ?v0)))))
(step t0 (cl (! (not (! (and (! (fun_app$b (! (less_eq$ (fun_app$a (! (freq$ t$) :named @p_24) a$)) :named @p_28) (! (fun_app$a @p_24 d$) :named @p_25)) :named @p_29) (fun_app$b (! (less_eq$ (! (fun_app$a @p_24 b$) :named @p_26)) :named @p_27) (! (fun_app$a @p_24 d$) :named @p_25))) :named @p_30)) :named @p_241) @p_29) :rule and_pos :args (0))
(step t1 (cl @p_29 @p_241) :rule reordering :premises (t0))
(step t2 (cl (! (not (! (or (! (not @p_7) :named @p_124) (! (not (! (member$ a$ @p_10) :named @p_35)) :named @p_213) (! (not @p_12) :named @p_32) (! (not @p_29) :named @p_206) (! (not (! (fun_app$b (! (less_eq$ (depth$ t$ a$)) :named @p_210) @p_16) :named @p_211)) :named @p_212) (! (fun_app$b (! (less_eq$ (! (cost$ (! (fun_app$f (! (swapSyms$ t$ a$) :named @p_79) d$) :named @p_81)) :named @p_207)) :named @p_208) @p_1) :named @p_209)) :named @p_214)) :named @p_240) @p_124 @p_213 @p_32 @p_206 @p_212 @p_209) :rule or_pos)
(step t3 (cl @p_124 @p_32 @p_213 @p_206 @p_212 @p_209 @p_240) :rule reordering :premises (t2))
(step t4 (cl (! (not (! (and @p_35 (! (member$ b$ @p_10) :named @p_34) (not (= a$ b$)) (fun_app$b @p_28 @p_26) (forall ((?v3 A$)) (or (not (member$ ?v3 (alphabet$ t$))) (= a$ ?v3) (= b$ ?v3) (and (fun_app$b (less_eq$ (fun_app$a (freq$ t$) a$)) (fun_app$a (freq$ t$) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ t$) b$)) (fun_app$a (freq$ t$) ?v3)))))) :named @p_36)) :named @p_76) @p_35) :rule and_pos :args (0))
(step t5 (cl @p_35 @p_76) :rule reordering :premises (t4))
(step t6 (cl (! (not (! (= @p_18 @p_36) :named @p_37)) :named @p_75) (! (not @p_18) :named @p_74) @p_36) :rule equiv_pos2)
(step t7 (cl @p_74 @p_36 @p_75) :rule reordering :premises (t6))
(step t8 (cl (or (! (not (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (= (fun_app$ (fun_app$c (minima$ ?v0) ?v1) ?v2) (and (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)) (not (= ?v1 ?v2)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (forall ((?v3 A$)) (or (not (member$ ?v3 (alphabet$ ?v0))) (= ?v1 ?v3) (= ?v2 ?v3) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3))))))))) :named @p_73) @p_37)) :rule forall_inst :args (t$ a$ b$))
(step t9 (cl @p_73 @p_37) :rule or :premises (t8))
(step t10 (cl (not (! (= (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (= (fun_app$ (fun_app$c (minima$ ?v0) ?v1) ?v2) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (not (= ?v1 ?v2)) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (forall ((?v3 A$)) (=> (and (member$ ?v3 (alphabet$ ?v0)) (and (not (= ?v3 ?v1)) (not (= ?v3 ?v2)))) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3))))))))))) (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (= (fun_app$ (fun_app$c (minima$ ?v0) ?v1) ?v2) (and (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)) (not (= ?v1 ?v2)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (forall ((?v3 A$)) (or (not (member$ ?v3 (alphabet$ ?v0))) (= ?v1 ?v3) (= ?v2 ?v3) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3))))))))) :named @p_38)) (not (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (= (fun_app$ (fun_app$c (minima$ ?v0) ?v1) ?v2) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (not (= ?v1 ?v2)) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (forall ((?v3 A$)) (=> (and (member$ ?v3 (alphabet$ ?v0)) (and (not (= ?v3 ?v1)) (not (= ?v3 ?v2)))) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3)))))))))))) (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (= (fun_app$ (fun_app$c (minima$ ?v0) ?v1) ?v2) (and (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)) (not (= ?v1 ?v2)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (forall ((?v3 A$)) (or (not (member$ ?v3 (alphabet$ ?v0))) (= ?v1 ?v3) (= ?v2 ?v3) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3))))))))) :rule equiv_pos2)
(anchor :step t11 :args ((?v0 A_tree$) (?v1 A$) (?v2 A$) (:= (?v0 A_tree$) ?v0) (:= (?v1 A$) ?v1) (:= (?v2 A$) ?v2)))
(step t11.t0 (cl (= (! (fun_app$ (fun_app$c (minima$ ?v0) ?v1) ?v2) :named @p_51) @p_51)) :rule refl)
(step t11.t1 (cl (! (= (! (and (! (member$ ?v1 (! (alphabet$ ?v0) :named @p_47)) :named @p_49) (and (! (member$ ?v2 @p_47) :named @p_48) (and (! (not (= ?v1 ?v2)) :named @p_46) (and (! (fun_app$b (! (less_eq$ (fun_app$a (! (freq$ ?v0) :named @p_42) ?v1)) :named @p_44) (! (fun_app$a @p_42 ?v2) :named @p_43)) :named @p_45) (forall ((?v3 A$)) (=> (and (member$ ?v3 (alphabet$ ?v0)) (and (not (= ?v3 ?v1)) (not (= ?v3 ?v2)))) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3))))))))) :named @p_52) (! (and @p_49 @p_48 @p_46 @p_45 (forall ((?v3 A$)) (=> (and (member$ ?v3 (alphabet$ ?v0)) (and (not (= ?v3 ?v1)) (not (= ?v3 ?v2)))) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3)))))) :named @p_53)) :named @p_72)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_72 1 5))
(step t11.t2 (cl (= @p_49 @p_49)) :rule refl)
(step t11.t3 (cl (= @p_48 @p_48)) :rule refl)
(step t11.t4 (cl (= @p_46 @p_46)) :rule refl)
(step t11.t5 (cl (= @p_45 @p_45)) :rule refl)
(anchor :step t11.t6 :args ((?v3 A$) (:= (?v3 A$) ?v3)))
(step t11.t6.t0 (cl (! (= (! (and (! (member$ ?v3 @p_47) :named @p_61) (and (! (not (! (= ?v3 ?v1) :named @p_65)) :named @p_66) (! (not (! (= ?v3 ?v2) :named @p_63)) :named @p_64))) :named @p_67) (! (and @p_61 @p_66 @p_64) :named @p_68)) :named @p_71)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_71 1 5))
(step t11.t6.t1 (cl (= @p_61 @p_61)) :rule refl)
(step t11.t6.t2 (cl (! (= @p_65 (! (= ?v1 ?v3) :named @p_59)) :named @p_70)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_70 2 6))
(step t11.t6.t3 (cl (= @p_66 (! (not @p_59) :named @p_60))) :rule cong :premises (t11.t6.t2))
(step t11.t6.t4 (cl (! (= @p_63 (! (= ?v2 ?v3) :named @p_57)) :named @p_69)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_69 2 6))
(step t11.t6.t5 (cl (= @p_64 (! (not @p_57) :named @p_58))) :rule cong :premises (t11.t6.t4))
(step t11.t6.t6 (cl (= @p_68 (! (and @p_61 @p_60 @p_58) :named @p_62))) :rule cong :premises (t11.t6.t1 t11.t6.t3 t11.t6.t5))
(step t11.t6.t7 (cl (= @p_67 @p_62)) :rule trans :premises (t11.t6.t0 t11.t6.t6))
(step t11.t6.t8 (cl (= (! (and (fun_app$b @p_44 (! (fun_app$a @p_42 ?v3) :named @p_55)) (fun_app$b (less_eq$ @p_43) @p_55)) :named @p_56) @p_56)) :rule refl)
(step t11.t6.t9 (cl (= (=> @p_67 @p_56) (=> @p_62 @p_56))) :rule cong :premises (t11.t6.t7 t11.t6.t8))
(step t11.t6 (cl (= (forall ((?v3 A$)) (=> (and (member$ ?v3 (alphabet$ ?v0)) (and (not (= ?v3 ?v1)) (not (= ?v3 ?v2)))) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3))))) (forall ((?v3 A$)) (=> (and (member$ ?v3 (alphabet$ ?v0)) (not (= ?v1 ?v3)) (not (= ?v2 ?v3))) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3))))))) :rule bind)
(step t11.t7 (cl (! (= (forall ((?v3 A$)) (=> (and (member$ ?v3 (alphabet$ ?v0)) (not (= ?v1 ?v3)) (not (= ?v2 ?v3))) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3))))) (forall ((?v3 A$)) (or (not (member$ ?v3 (alphabet$ ?v0))) (= ?v1 ?v3) (= ?v2 ?v3) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3)))))) :named @p_54)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_54 13 6))
(step t11.t8 (cl (= (forall ((?v3 A$)) (=> (and (member$ ?v3 (alphabet$ ?v0)) (and (not (= ?v3 ?v1)) (not (= ?v3 ?v2)))) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3))))) (forall ((?v3 A$)) (or (not (member$ ?v3 (alphabet$ ?v0))) (= ?v1 ?v3) (= ?v2 ?v3) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3))))))) :rule trans :premises (t11.t6 t11.t7))
(step t11.t9 (cl (= @p_53 (! (and @p_49 @p_48 @p_46 @p_45 (forall ((?v3 A$)) (or (not (member$ ?v3 (alphabet$ ?v0))) (= ?v1 ?v3) (= ?v2 ?v3) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3)))))) :named @p_50))) :rule cong :premises (t11.t2 t11.t3 t11.t4 t11.t5 t11.t8))
(step t11.t10 (cl (= @p_52 @p_50)) :rule trans :premises (t11.t1 t11.t9))
(step t11.t11 (cl (= (= @p_51 @p_52) (= @p_51 @p_50))) :rule cong :premises (t11.t0 t11.t10))
(step t11 (cl @p_38) :rule bind)
(step t12 (cl (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (= (fun_app$ (fun_app$c (minima$ ?v0) ?v1) ?v2) (and (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)) (not (= ?v1 ?v2)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (forall ((?v3 A$)) (or (not (member$ ?v3 (alphabet$ ?v0))) (= ?v1 ?v3) (= ?v2 ?v3) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v2)) (fun_app$a (freq$ ?v0) ?v3))))))))) :rule resolution :premises (t10 t11 a38))
(step t13 (cl @p_37) :rule resolution :premises (t9 t12))
(step t14 (cl @p_36) :rule resolution :premises (t7 a9 t13))
(step t15 (cl @p_35) :rule resolution :premises (t5 t14))
(step t16 (cl (= (! (= @p_211 true) :named @p_237) @p_211)) :rule equiv_simplify)
(step t17 (cl (not @p_237) @p_211) :rule equiv1 :premises (t16))
(step t18 (cl (= @p_210 @p_210)) :rule refl)
(step t19 (cl (= @p_211 (! (fun_app$b @p_210 @p_13) :named @p_238))) :rule cong :premises (t18 a8))
(step t20 (cl (= (! (= @p_238 true) :named @p_239) @p_238)) :rule equiv_simplify)
(step t21 (cl @p_239 (not @p_238)) :rule equiv2 :premises (t20))
(step t22 (cl (or (! (not (forall ((?v0 A_tree$) (?v1 A$)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (height$ ?v0)))) :named @p_156) @p_238)) :rule forall_inst :args (t$ a$))
(step t23 (cl @p_156 @p_238) :rule or :premises (t22))
(step t24 (cl @p_238) :rule resolution :premises (t23 a22))
(step t25 (cl @p_239) :rule resolution :premises (t21 t24))
(step t26 (cl @p_237) :rule trans :premises (t19 t25))
(step t27 (cl @p_211) :rule resolution :premises (t17 t26))
(step t28 (cl (not (! (= (! (or (! (not @p_6) :named @p_174) (! (not (! (= @p_2 (! (ite @p_21 (! (fun_app$f (! (swapSyms$ t$ b$) :named @p_83) c$) :named @p_84) (! (ite @p_19 @p_81 (! (fun_app$f (swapSyms$ (fun_app$f @p_79 c$) b$) d$) :named @p_80)) :named @p_82)) :named @p_85)) :named @p_110)) :named @p_113) (! (not (! (= @p_85 @p_82) :named @p_87)) :named @p_227) (! (not (! (= @p_81 @p_82) :named @p_216)) :named @p_228) (! (not @p_209) :named @p_215)) :named @p_230) (! (or @p_5 @p_113 @p_227 @p_228 @p_215) :named @p_229)) :named @p_236)) (not @p_230) @p_229) :rule equiv_pos2)
(step t29 (cl (! (= @p_174 @p_5) :named @p_185)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_185 1 5))
(step t30 (cl (= @p_113 @p_113)) :rule refl)
(step t31 (cl (= @p_227 @p_227)) :rule refl)
(step t32 (cl (= @p_228 @p_228)) :rule refl)
(step t33 (cl (= @p_215 @p_215)) :rule refl)
(step t34 (cl @p_236) :rule cong :premises (t29 t30 t31 t32 t33))
(step t35 (cl (! (and @p_6 @p_110 @p_87 @p_216) :named @p_232) @p_174 @p_113 @p_227 @p_228) :rule and_neg)
(step t36 (cl (! (=> @p_232 @p_215) :named @p_234) @p_232) :rule implies_neg1)
(anchor :step t37)
(assume t37.a0 @p_6)
(assume t37.a1 @p_110)
(assume t37.a2 @p_87)
(assume t37.a3 @p_216)
(step t37.t0 (cl (= (! (= @p_209 false) :named @p_235) @p_215)) :rule equiv_simplify)
(step t37.t1 (cl (not @p_235) @p_215) :rule equiv1 :premises (t37.t0))
(step t37.t2 (cl (! (= @p_82 @p_81) :named @p_220)) :rule symm :premises (t37.a3))
(step t37.t3 (cl @p_216) :rule symm :premises (t37.t2))
(step t37.t4 (cl (! (= @p_82 @p_85) :named @p_98)) :rule symm :premises (t37.a2))
(step t37.t5 (cl (not (! (= (! (=> (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (= (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4) (ite (= ?v1 ?v4) (fun_app$f (swapSyms$ ?v0 ?v2) ?v3) (ite (= ?v2 ?v3) (fun_app$f (swapSyms$ ?v0 ?v1) ?v4) (fun_app$f (swapSyms$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v3) ?v2) ?v4))))) @p_110) :named @p_112) @p_112) :named @p_114)) (not @p_112) @p_112) :rule equiv_pos2)
(step t37.t6 (cl (= (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (= (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4) (ite (= ?v1 ?v4) (fun_app$f (swapSyms$ ?v0 ?v2) ?v3) (ite (= ?v2 ?v3) (fun_app$f (swapSyms$ ?v0 ?v1) ?v4) (fun_app$f (swapSyms$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v3) ?v2) ?v4))))) (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (= (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4) (ite (= ?v1 ?v4) (fun_app$f (swapSyms$ ?v0 ?v2) ?v3) (ite (= ?v2 ?v3) (fun_app$f (swapSyms$ ?v0 ?v1) ?v4) (fun_app$f (swapSyms$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v3) ?v2) ?v4))))))) :rule refl)
(step t37.t7 (cl (= @p_2 @p_2)) :rule refl)
(step t37.t8 (cl (= (! (= (! (= @p_85 @p_85) :named @p_93) true) :named @p_94) @p_93)) :rule equiv_simplify)
(step t37.t9 (cl (not @p_94) @p_93) :rule equiv1 :premises (t37.t8))
(step t37.t10 (cl (! (= @p_93 @p_93) :named @p_95)) :rule refl)
(step t37.t11 (cl @p_93) :rule refl)
(step t37.t12 (cl @p_93) :rule refl)
(step t37.t13 (cl @p_95) :rule cong :premises (t37.t11 t37.t12))
(step t37.t14 (cl @p_94) :rule hole :args ("TRUST_THEORY_REWRITE" @p_94 2 5))
(step t37.t15 (cl @p_94) :rule trans :premises (t37.t10 t37.t13 t37.t14))
(step t37.t16 (cl @p_93) :rule resolution :premises (t37.t9 t37.t15))
(step t37.t17 (cl (= @p_110 @p_110)) :rule cong :premises (t37.t7 t37.t16))
(step t37.t18 (cl @p_114) :rule cong :premises (t37.t6 t37.t17))
(step t37.t19 (cl @p_112 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (= (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4) (ite (= ?v1 ?v4) (fun_app$f (swapSyms$ ?v0 ?v2) ?v3) (ite (= ?v2 ?v3) (fun_app$f (swapSyms$ ?v0 ?v1) ?v4) (fun_app$f (swapSyms$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v3) ?v2) ?v4)))))) :rule implies_neg1)
(anchor :step t37.t20)
(assume t37.t20.a0 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (= (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4) (ite (= ?v1 ?v4) (fun_app$f (swapSyms$ ?v0 ?v2) ?v3) (ite (= ?v2 ?v3) (fun_app$f (swapSyms$ ?v0 ?v1) ?v4) (fun_app$f (swapSyms$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v3) ?v2) ?v4))))))
(step t37.t20.t0 (cl (or (! (not (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (= (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4) (ite (= ?v1 ?v4) (fun_app$f (swapSyms$ ?v0 ?v2) ?v3) (ite (= ?v2 ?v3) (fun_app$f (swapSyms$ ?v0 ?v1) ?v4) (fun_app$f (swapSyms$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v3) ?v2) ?v4)))))) :named @p_111) @p_110)) :rule forall_inst :args (t$ a$ b$ c$ d$))
(step t37.t20.t1 (cl @p_111 @p_110) :rule or :premises (t37.t20.t0))
(step t37.t20.t2 (cl @p_110) :rule resolution :premises (t37.t20.t1 t37.t20.a0))
(step t37.t20 (cl @p_111 @p_110) :rule subproof :discharge (t37.t20.a0))
(step t37.t21 (cl @p_112 @p_110) :rule resolution :premises (t37.t19 t37.t20))
(step t37.t22 (cl @p_112 @p_113) :rule implies_neg2)
(step t37.t23 (cl @p_112 @p_112) :rule resolution :premises (t37.t21 t37.t22))
(step t37.t24 (cl @p_112) :rule contraction :premises (t37.t23))
(step t37.t25 (cl @p_112) :rule resolution :premises (t37.t5 t37.t18 t37.t24))
(step t37.t26 (cl @p_111 @p_110) :rule implies :premises (t37.t25))
(step t37.t27 (cl @p_110) :rule resolution :premises (t37.t26 a71))
(step t37.t28 (cl (= @p_85 @p_2)) :rule symm :premises (t37.t27))
(step t37.t29 (cl (= @p_81 @p_2)) :rule trans :premises (t37.t3 t37.t4 t37.t28))
(step t37.t30 (cl (= @p_207 @p_3)) :rule cong :premises (t37.t29))
(step t37.t31 (cl (= @p_208 @p_4)) :rule cong :premises (t37.t30))
(step t37.t32 (cl (= @p_1 @p_1)) :rule refl)
(step t37.t33 (cl (= @p_209 @p_5)) :rule cong :premises (t37.t31 t37.t32))
(step t37.t34 (cl (= (! (= @p_5 false) :named @p_183) @p_6)) :rule equiv_simplify)
(step t37.t35 (cl @p_183 @p_174) :rule equiv2 :premises (t37.t34))
(step t37.t36 (cl (! (not @p_174) :named @p_178) @p_5) :rule not_not)
(step t37.t37 (cl @p_183 @p_5) :rule resolution :premises (t37.t35 t37.t36))
(step t37.t38 (cl @p_183) :rule resolution :premises (t37.t37 t37.a0))
(step t37.t39 (cl @p_235) :rule trans :premises (t37.t33 t37.t38))
(step t37.t40 (cl @p_215) :rule resolution :premises (t37.t1 t37.t39))
(step t37 (cl @p_174 @p_113 @p_227 @p_228 @p_215) :rule subproof :discharge (t37.a0 t37.a1 t37.a2 t37.a3))
(step t38 (cl (! (not @p_232) :named @p_233) @p_6) :rule and_pos :args (0))
(step t39 (cl @p_233 @p_110) :rule and_pos :args (1))
(step t40 (cl @p_233 @p_87) :rule and_pos :args (2))
(step t41 (cl @p_233 @p_216) :rule and_pos :args (3))
(step t42 (cl @p_215 @p_233 @p_233 @p_233 @p_233) :rule resolution :premises (t37 t38 t39 t40 t41))
(step t43 (cl @p_233 @p_233 @p_233 @p_233 @p_215) :rule reordering :premises (t42))
(step t44 (cl @p_233 @p_215) :rule contraction :premises (t43))
(step t45 (cl @p_234 @p_215) :rule resolution :premises (t36 t44))
(step t46 (cl @p_234 (! (not @p_215) :named @p_231)) :rule implies_neg2)
(step t47 (cl @p_234 @p_234) :rule resolution :premises (t45 t46))
(step t48 (cl @p_234) :rule contraction :premises (t47))
(step t49 (cl @p_233 @p_215) :rule implies :premises (t48))
(step t50 (cl @p_174 @p_113 @p_227 @p_228 @p_215) :rule resolution :premises (t35 t49))
(step t51 (cl @p_230 @p_178) :rule or_neg :args (0))
(step t52 (cl @p_230 (! (not @p_113) :named @p_177)) :rule or_neg :args (1))
(step t53 (cl @p_230 (not @p_227)) :rule or_neg :args (2))
(step t54 (cl @p_230 (not @p_228)) :rule or_neg :args (3))
(step t55 (cl @p_230 @p_231) :rule or_neg :args (4))
(step t56 (cl @p_230 @p_230 @p_230 @p_230 @p_230) :rule resolution :premises (t50 t51 t52 t53 t54 t55))
(step t57 (cl @p_230) :rule contraction :premises (t56))
(step t58 (cl @p_229) :rule resolution :premises (t28 t34 t57))
(step t59 (cl @p_5 @p_113 @p_227 @p_228 @p_215) :rule or :premises (t58))
(step t60 (cl (not @p_114) (not @p_112) @p_112) :rule equiv_pos2)
(step t61 (cl (= (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (= (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4) (ite (= ?v1 ?v4) (fun_app$f (swapSyms$ ?v0 ?v2) ?v3) (ite (= ?v2 ?v3) (fun_app$f (swapSyms$ ?v0 ?v1) ?v4) (fun_app$f (swapSyms$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v3) ?v2) ?v4))))) (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (= (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4) (ite (= ?v1 ?v4) (fun_app$f (swapSyms$ ?v0 ?v2) ?v3) (ite (= ?v2 ?v3) (fun_app$f (swapSyms$ ?v0 ?v1) ?v4) (fun_app$f (swapSyms$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v3) ?v2) ?v4))))))) :rule refl)
(step t62 (cl (= @p_2 @p_2)) :rule refl)
(step t63 (cl (= @p_94 @p_93)) :rule equiv_simplify)
(step t64 (cl (not @p_94) @p_93) :rule equiv1 :premises (t63))
(step t65 (cl @p_95) :rule refl)
(step t66 (cl @p_93) :rule refl)
(step t67 (cl @p_93) :rule refl)
(step t68 (cl @p_95) :rule cong :premises (t66 t67))
(step t69 (cl @p_94) :rule hole :args ("TRUST_THEORY_REWRITE" @p_94 2 5))
(step t70 (cl @p_94) :rule trans :premises (t65 t68 t69))
(step t71 (cl @p_93) :rule resolution :premises (t64 t70))
(step t72 (cl (= @p_110 @p_110)) :rule cong :premises (t62 t71))
(step t73 (cl @p_114) :rule cong :premises (t61 t72))
(step t74 (cl @p_112 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (= (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4) (ite (= ?v1 ?v4) (fun_app$f (swapSyms$ ?v0 ?v2) ?v3) (ite (= ?v2 ?v3) (fun_app$f (swapSyms$ ?v0 ?v1) ?v4) (fun_app$f (swapSyms$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v3) ?v2) ?v4)))))) :rule implies_neg1)
(anchor :step t75)
(assume t75.a0 (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$) (?v3 A$) (?v4 A$)) (= (swapFourSyms$ ?v0 ?v1 ?v2 ?v3 ?v4) (ite (= ?v1 ?v4) (fun_app$f (swapSyms$ ?v0 ?v2) ?v3) (ite (= ?v2 ?v3) (fun_app$f (swapSyms$ ?v0 ?v1) ?v4) (fun_app$f (swapSyms$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v3) ?v2) ?v4))))))
(step t75.t0 (cl (or @p_111 @p_110)) :rule forall_inst :args (t$ a$ b$ c$ d$))
(step t75.t1 (cl @p_111 @p_110) :rule or :premises (t75.t0))
(step t75.t2 (cl @p_110) :rule resolution :premises (t75.t1 t75.a0))
(step t75 (cl @p_111 @p_110) :rule subproof :discharge (t75.a0))
(step t76 (cl @p_112 @p_110) :rule resolution :premises (t74 t75))
(step t77 (cl @p_112 @p_113) :rule implies_neg2)
(step t78 (cl @p_112 @p_112) :rule resolution :premises (t76 t77))
(step t79 (cl @p_112) :rule contraction :premises (t78))
(step t80 (cl @p_112) :rule resolution :premises (t60 t73 t79))
(step t81 (cl @p_111 @p_110) :rule implies :premises (t80))
(step t82 (cl @p_110) :rule resolution :premises (t81 a71))
(step t83 (cl (not (! (= (! (ite @p_21 (! (= @p_85 @p_84) :named @p_89) @p_87) :named @p_90) (! (ite @p_21 (! (= @p_84 @p_85) :named @p_86) @p_87) :named @p_88)) :named @p_97)) (! (not @p_90) :named @p_96) @p_88) :rule equiv_pos2)
(step t84 (cl (= @p_21 @p_21)) :rule refl)
(step t85 (cl (! (= @p_89 @p_86) :named @p_104)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_104 2 6))
(step t86 (cl (! (= @p_87 @p_98) :named @p_103)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_103 2 6))
(step t87 (cl (= @p_90 (! (ite @p_21 @p_86 @p_98) :named @p_99))) :rule cong :premises (t84 t85 t86))
(step t88 (cl (= @p_86 @p_86)) :rule refl)
(step t89 (cl (= (! (= (! (= @p_82 @p_82) :named @p_92) true) :named @p_101) @p_92)) :rule equiv_simplify)
(step t90 (cl (not @p_101) @p_92) :rule equiv1 :premises (t89))
(step t91 (cl (! (= @p_92 @p_92) :named @p_102)) :rule refl)
(step t92 (cl @p_92) :rule refl)
(step t93 (cl @p_92) :rule refl)
(step t94 (cl @p_102) :rule cong :premises (t92 t93))
(step t95 (cl @p_101) :rule hole :args ("TRUST_THEORY_REWRITE" @p_101 2 5))
(step t96 (cl @p_101) :rule trans :premises (t91 t94 t95))
(step t97 (cl @p_92) :rule resolution :premises (t90 t96))
(step t98 (cl @p_93) :rule refl)
(step t99 (cl (= @p_98 @p_98)) :rule cong :premises (t97 t98))
(step t100 (cl (! (= @p_98 @p_87) :named @p_100)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_100 2 6))
(step t101 (cl @p_100) :rule trans :premises (t99 t100))
(step t102 (cl (= @p_99 @p_88)) :rule cong :premises (t84 t88 t101))
(step t103 (cl @p_97) :rule trans :premises (t87 t102))
(step t104 (cl (not (! (= @p_90 @p_90) :named @p_91)) @p_96 @p_90) :rule equiv_pos2)
(step t105 (cl (= @p_84 @p_84)) :rule refl)
(step t106 (cl (= @p_89 @p_89)) :rule cong :premises (t71 t105))
(step t107 (cl (= @p_87 @p_87)) :rule cong :premises (t71 t92))
(step t108 (cl @p_91) :rule cong :premises (t84 t106 t107))
(step t109 (cl @p_90) :rule hole)
(step t110 (cl @p_90) :rule resolution :premises (t104 t108 t109))
(step t111 (cl @p_88) :rule resolution :premises (t83 t103 t110))
(step t112 (cl @p_21 @p_87) :rule ite1 :premises (t111))
(step t113 (cl (not (! (= (! (or @p_174 @p_113 (! (not @p_86) :named @p_136) (! (not (! (fun_app$b (! (less_eq$ (! (cost$ @p_84) :named @p_141)) :named @p_157) @p_1) :named @p_158)) :named @p_172)) :named @p_175) (! (or @p_5 @p_113 @p_136 @p_172) :named @p_173)) :named @p_184)) (not @p_175) @p_173) :rule equiv_pos2)
(step t114 (cl (= @p_136 @p_136)) :rule refl)
(step t115 (cl (= @p_172 @p_172)) :rule refl)
(step t116 (cl @p_184) :rule cong :premises (t29 t30 t114 t115))
(step t117 (cl (! (and @p_6 @p_110 @p_86) :named @p_179) @p_174 @p_113 @p_136) :rule and_neg)
(step t118 (cl (! (=> @p_179 @p_172) :named @p_181) @p_179) :rule implies_neg1)
(anchor :step t119)
(assume t119.a0 @p_6)
(assume t119.a1 @p_110)
(assume t119.a2 @p_86)
(step t119.t0 (cl (= (! (= @p_158 false) :named @p_182) @p_172)) :rule equiv_simplify)
(step t119.t1 (cl (not @p_182) @p_172) :rule equiv1 :premises (t119.t0))
(step t119.t2 (cl @p_89) :rule symm :premises (t119.a2))
(step t119.t3 (cl @p_86) :rule symm :premises (t119.t2))
(step t119.t4 (cl (= @p_85 @p_2)) :rule symm :premises (t82))
(step t119.t5 (cl (= @p_84 @p_2)) :rule trans :premises (t119.t3 t119.t4))
(step t119.t6 (cl (= @p_141 @p_3)) :rule cong :premises (t119.t5))
(step t119.t7 (cl (= @p_157 @p_4)) :rule cong :premises (t119.t6))
(step t119.t8 (cl (= @p_1 @p_1)) :rule refl)
(step t119.t9 (cl (= @p_158 @p_5)) :rule cong :premises (t119.t7 t119.t8))
(step t119.t10 (cl (= @p_183 @p_6)) :rule equiv_simplify)
(step t119.t11 (cl @p_183 @p_174) :rule equiv2 :premises (t119.t10))
(step t119.t12 (cl @p_178 @p_5) :rule not_not)
(step t119.t13 (cl @p_183 @p_5) :rule resolution :premises (t119.t11 t119.t12))
(step t119.t14 (cl @p_183) :rule resolution :premises (t119.t13 t119.a0))
(step t119.t15 (cl @p_182) :rule trans :premises (t119.t9 t119.t14))
(step t119.t16 (cl @p_172) :rule resolution :premises (t119.t1 t119.t15))
(step t119 (cl @p_174 @p_113 @p_136 @p_172) :rule subproof :discharge (t119.a0 t119.a1 t119.a2))
(step t120 (cl (! (not @p_179) :named @p_180) @p_6) :rule and_pos :args (0))
(step t121 (cl @p_180 @p_110) :rule and_pos :args (1))
(step t122 (cl @p_180 @p_86) :rule and_pos :args (2))
(step t123 (cl @p_172 @p_180 @p_180 @p_180) :rule resolution :premises (t119 t120 t121 t122))
(step t124 (cl @p_180 @p_180 @p_180 @p_172) :rule reordering :premises (t123))
(step t125 (cl @p_180 @p_172) :rule contraction :premises (t124))
(step t126 (cl @p_181 @p_172) :rule resolution :premises (t118 t125))
(step t127 (cl @p_181 (! (not @p_172) :named @p_176)) :rule implies_neg2)
(step t128 (cl @p_181 @p_181) :rule resolution :premises (t126 t127))
(step t129 (cl @p_181) :rule contraction :premises (t128))
(step t130 (cl @p_180 @p_172) :rule implies :premises (t129))
(step t131 (cl @p_174 @p_113 @p_136 @p_172) :rule resolution :premises (t117 t130))
(step t132 (cl @p_175 @p_178) :rule or_neg :args (0))
(step t133 (cl @p_175 @p_177) :rule or_neg :args (1))
(step t134 (cl @p_175 (not @p_136)) :rule or_neg :args (2))
(step t135 (cl @p_175 @p_176) :rule or_neg :args (3))
(step t136 (cl @p_175 @p_175 @p_175 @p_175) :rule resolution :premises (t131 t132 t133 t134 t135))
(step t137 (cl @p_175) :rule contraction :premises (t136))
(step t138 (cl @p_173) :rule resolution :premises (t113 t116 t137))
(step t139 (cl @p_5 @p_113 @p_136 @p_172) :rule or :premises (t138))
(step t140 (cl (! (not (! (or @p_124 (! (not @p_34) :named @p_161) (! (not @p_11) :named @p_147) (! (not (! (fun_app$b @p_27 (! (fun_app$a @p_24 c$) :named @p_144)) :named @p_145)) :named @p_160) (! (not (! (fun_app$b (! (less_eq$ (depth$ t$ b$)) :named @p_151) @p_14) :named @p_152)) :named @p_159) @p_158) :named @p_162)) :named @p_171) @p_124 @p_161 @p_147 @p_160 @p_159 @p_158) :rule or_pos)
(step t141 (cl @p_124 @p_147 @p_161 @p_160 @p_159 @p_158 @p_171) :rule reordering :premises (t140))
(step t142 (cl (or (! (not (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (or (not (consistent$ ?v0)) (not (member$ ?v1 (alphabet$ ?v0))) (not (member$ ?v2 (alphabet$ ?v0))) (not (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2))) (not (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0))))) :named @p_170) @p_162)) :rule forall_inst :args (t$ b$ c$))
(step t143 (cl @p_170 @p_162) :rule or :premises (t142))
(step t144 (cl (not (! (= (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2)))))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0)))) (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (or (not (consistent$ ?v0)) (not (member$ ?v1 (alphabet$ ?v0))) (not (member$ ?v2 (alphabet$ ?v0))) (not (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2))) (not (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0))))) :named @p_163)) (not (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2)))))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0))))) (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (or (not (consistent$ ?v0)) (not (member$ ?v1 (alphabet$ ?v0))) (not (member$ ?v2 (alphabet$ ?v0))) (not (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2))) (not (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0))))) :rule equiv_pos2)
(anchor :step t145 :args ((?v0 A_tree$) (?v1 A$) (?v2 A$) (:= (?v0 A_tree$) ?v0) (:= (?v1 A$) ?v1) (:= (?v2 A$) ?v2)))
(step t145.t0 (cl (! (= (! (and (! (consistent$ ?v0) :named @p_131) (and @p_49 (and @p_48 (and @p_45 (! (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2)) :named @p_166))))) :named @p_168) (! (and @p_131 @p_49 @p_48 @p_45 @p_166) :named @p_167)) :named @p_169)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_169 1 5))
(step t145.t1 (cl (= (! (fun_app$b (less_eq$ (cost$ (fun_app$f (! (swapSyms$ ?v0 ?v1) :named @p_128) ?v2))) (cost$ ?v0)) :named @p_165) @p_165)) :rule refl)
(step t145.t2 (cl (= (=> @p_168 @p_165) (=> @p_167 @p_165))) :rule cong :premises (t145.t0 t145.t1))
(step t145 (cl (= (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2)))))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0)))) (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0)))))) :rule bind)
(step t146 (cl (! (= (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0)))) (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (or (not (consistent$ ?v0)) (not (member$ ?v1 (alphabet$ ?v0))) (not (member$ ?v2 (alphabet$ ?v0))) (not (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2))) (not (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0))))) :named @p_164)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_164 13 6))
(step t147 (cl @p_163) :rule trans :premises (t145 t146))
(step t148 (cl (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (or (not (consistent$ ?v0)) (not (member$ ?v1 (alphabet$ ?v0))) (not (member$ ?v2 (alphabet$ ?v0))) (not (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2))) (not (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0))))) :rule resolution :premises (t144 t147 a43))
(step t149 (cl @p_162) :rule resolution :premises (t143 t148))
(step t150 (cl (= (! (= @p_152 true) :named @p_153) @p_152)) :rule equiv_simplify)
(step t151 (cl (not @p_153) @p_152) :rule equiv1 :premises (t150))
(step t152 (cl (= @p_151 @p_151)) :rule refl)
(step t153 (cl (= @p_152 (! (fun_app$b @p_151 @p_13) :named @p_154))) :rule cong :premises (t152 a7))
(step t154 (cl (= (! (= @p_154 true) :named @p_155) @p_154)) :rule equiv_simplify)
(step t155 (cl @p_155 (not @p_154)) :rule equiv2 :premises (t154))
(step t156 (cl (or @p_156 @p_154)) :rule forall_inst :args (t$ b$))
(step t157 (cl @p_156 @p_154) :rule or :premises (t156))
(step t158 (cl @p_154) :rule resolution :premises (t157 a22))
(step t159 (cl @p_155) :rule resolution :premises (t155 t158))
(step t160 (cl @p_153) :rule trans :premises (t153 t159))
(step t161 (cl @p_152) :rule resolution :premises (t151 t160))
(step t162 (cl @p_76 @p_34) :rule and_pos :args (1))
(step t163 (cl @p_34 @p_76) :rule reordering :premises (t162))
(step t164 (cl @p_34) :rule resolution :premises (t163 t14))
(step t165 (cl (! (not (! (and (fun_app$b @p_28 @p_144) @p_145) :named @p_146)) :named @p_150) @p_145) :rule and_pos :args (1))
(step t166 (cl @p_145 @p_150) :rule reordering :premises (t165))
(step t167 (cl (! (not (! (or @p_147 (! (= a$ c$) :named @p_105) @p_19 @p_146) :named @p_148)) :named @p_149) @p_147 @p_105 @p_19 @p_146) :rule or_pos)
(step t168 (cl @p_19 @p_147 @p_105 @p_146 @p_149) :rule reordering :premises (t167))
(step t169 (cl (or (! (not (forall ((?v3 A$)) (or (not (member$ ?v3 (alphabet$ t$))) (= a$ ?v3) (= b$ ?v3) (and (fun_app$b (less_eq$ (fun_app$a (freq$ t$) a$)) (fun_app$a (freq$ t$) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ t$) b$)) (fun_app$a (freq$ t$) ?v3)))))) :named @p_77) @p_148)) :rule forall_inst :args (c$))
(step t170 (cl @p_77 @p_148) :rule or :premises (t169))
(step t171 (cl @p_76 (forall ((?v3 A$)) (or (not (member$ ?v3 (alphabet$ t$))) (= a$ ?v3) (= b$ ?v3) (and (fun_app$b (less_eq$ (fun_app$a (freq$ t$) a$)) (fun_app$a (freq$ t$) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ t$) b$)) (fun_app$a (freq$ t$) ?v3)))))) :rule and_pos :args (4))
(step t172 (cl (forall ((?v3 A$)) (or (not (member$ ?v3 (alphabet$ t$))) (= a$ ?v3) (= b$ ?v3) (and (fun_app$b (less_eq$ (fun_app$a (freq$ t$) a$)) (fun_app$a (freq$ t$) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ t$) b$)) (fun_app$a (freq$ t$) ?v3))))) @p_76) :rule reordering :premises (t171))
(step t173 (cl (forall ((?v3 A$)) (or (not (member$ ?v3 (alphabet$ t$))) (= a$ ?v3) (= b$ ?v3) (and (fun_app$b (less_eq$ (fun_app$a (freq$ t$) a$)) (fun_app$a (freq$ t$) ?v3)) (fun_app$b (less_eq$ (fun_app$a (freq$ t$) b$)) (fun_app$a (freq$ t$) ?v3)))))) :rule resolution :premises (t172 t14))
(step t174 (cl @p_148) :rule resolution :premises (t170 t173))
(step t175 (cl (! (and (! (= t$ (! (fun_app$f @p_83 b$) :named @p_122)) :named @p_123) @p_19 @p_86 @p_110) :named @p_138) (! (not @p_123) :named @p_137) @p_20 @p_136 @p_113) :rule and_neg)
(step t176 (cl (! (=> @p_138 (! (= @p_3 @p_1) :named @p_115)) :named @p_140) @p_138) :rule implies_neg1)
(anchor :step t177)
(assume t177.a0 @p_123)
(assume t177.a1 @p_19)
(assume t177.a2 @p_86)
(assume t177.a3 @p_110)
(step t177.t0 (cl @p_89) :rule symm :premises (t177.a2))
(step t177.t1 (cl (= @p_2 @p_84)) :rule trans :premises (t82 t177.t0))
(step t177.t2 (cl (= @p_3 @p_141)) :rule cong :premises (t177.t1))
(step t177.t3 (cl (= @p_83 @p_83)) :rule refl)
(step t177.t4 (cl (! (= c$ b$) :named @p_142)) :rule symm :premises (t177.a1))
(step t177.t5 (cl (= @p_84 @p_122)) :rule cong :premises (t177.t3 t177.t4))
(step t177.t6 (cl (! (not (! (or @p_124 @p_123) :named @p_125)) :named @p_135) @p_124 @p_123) :rule or_pos)
(step t177.t7 (cl @p_124 @p_123 @p_135) :rule reordering :premises (t177.t6))
(step t177.t8 (cl (or (! (not (forall ((?v0 A_tree$) (?v1 A$)) (or (not (consistent$ ?v0)) (= ?v0 (fun_app$f (swapSyms$ ?v0 ?v1) ?v1))))) :named @p_134) @p_125)) :rule forall_inst :args (t$ b$))
(step t177.t9 (cl @p_134 @p_125) :rule or :premises (t177.t8))
(step t177.t10 (cl (not (! (= (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$ ?v0) (= (fun_app$f (swapSyms$ ?v0 ?v1) ?v1) ?v0))) (forall ((?v0 A_tree$) (?v1 A$)) (or (not (consistent$ ?v0)) (= ?v0 (fun_app$f (swapSyms$ ?v0 ?v1) ?v1))))) :named @p_126)) (not (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$ ?v0) (= (fun_app$f (swapSyms$ ?v0 ?v1) ?v1) ?v0)))) (forall ((?v0 A_tree$) (?v1 A$)) (or (not (consistent$ ?v0)) (= ?v0 (fun_app$f (swapSyms$ ?v0 ?v1) ?v1))))) :rule equiv_pos2)
(anchor :step t177.t11 :args ((?v0 A_tree$) (?v1 A$) (:= (?v0 A_tree$) ?v0) (:= (?v1 A$) ?v1)))
(step t177.t11.t0 (cl (= @p_131 @p_131)) :rule refl)
(step t177.t11.t1 (cl (! (= (! (= (! (fun_app$f @p_128 ?v1) :named @p_129) ?v0) :named @p_132) (! (= ?v0 @p_129) :named @p_130)) :named @p_133)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_133 2 6))
(step t177.t11.t2 (cl (= (=> @p_131 @p_132) (=> @p_131 @p_130))) :rule cong :premises (t177.t11.t0 t177.t11.t1))
(step t177.t11 (cl (= (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$ ?v0) (= (fun_app$f (swapSyms$ ?v0 ?v1) ?v1) ?v0))) (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$ ?v0) (= ?v0 (fun_app$f (swapSyms$ ?v0 ?v1) ?v1)))))) :rule bind)
(step t177.t12 (cl (! (= (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$ ?v0) (= ?v0 (fun_app$f (swapSyms$ ?v0 ?v1) ?v1)))) (forall ((?v0 A_tree$) (?v1 A$)) (or (not (consistent$ ?v0)) (= ?v0 (fun_app$f (swapSyms$ ?v0 ?v1) ?v1))))) :named @p_127)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_127 13 6))
(step t177.t13 (cl @p_126) :rule trans :premises (t177.t11 t177.t12))
(step t177.t14 (cl (forall ((?v0 A_tree$) (?v1 A$)) (or (not (consistent$ ?v0)) (= ?v0 (fun_app$f (swapSyms$ ?v0 ?v1) ?v1))))) :rule resolution :premises (t177.t10 t177.t13 a53))
(step t177.t15 (cl @p_125) :rule resolution :premises (t177.t9 t177.t14))
(step t177.t16 (cl @p_123) :rule resolution :premises (t177.t7 a3 t177.t15))
(step t177.t17 (cl (= @p_122 t$)) :rule symm :premises (t177.t16))
(step t177.t18 (cl (= @p_84 t$)) :rule trans :premises (t177.t5 t177.t17))
(step t177.t19 (cl (= @p_141 @p_1)) :rule cong :premises (t177.t18))
(step t177.t20 (cl @p_115) :rule trans :premises (t177.t2 t177.t19))
(step t177 (cl @p_137 @p_20 @p_136 @p_113 @p_115) :rule subproof :discharge (t177.a0 t177.a1 t177.a2 t177.a3))
(step t178 (cl (! (not @p_138) :named @p_139) @p_123) :rule and_pos :args (0))
(step t179 (cl @p_139 @p_19) :rule and_pos :args (1))
(step t180 (cl @p_139 @p_86) :rule and_pos :args (2))
(step t181 (cl @p_139 @p_110) :rule and_pos :args (3))
(step t182 (cl @p_115 @p_139 @p_139 @p_139 @p_139) :rule resolution :premises (t177 t178 t179 t180 t181))
(step t183 (cl @p_139 @p_139 @p_139 @p_139 @p_115) :rule reordering :premises (t182))
(step t184 (cl @p_139 @p_115) :rule contraction :premises (t183))
(step t185 (cl @p_140 @p_115) :rule resolution :premises (t176 t184))
(step t186 (cl @p_140 (! (not @p_115) :named @p_116)) :rule implies_neg2)
(step t187 (cl @p_140 @p_140) :rule resolution :premises (t185 t186))
(step t188 (cl @p_140) :rule contraction :premises (t187))
(step t189 (cl @p_139 @p_115) :rule implies :premises (t188))
(step t190 (cl @p_137 @p_20 @p_136 @p_113 @p_115) :rule resolution :premises (t175 t189))
(step t191 (cl @p_20 @p_115 @p_113 @p_136 @p_137) :rule reordering :premises (t190))
(step t192 (cl @p_135 @p_124 @p_123) :rule or_pos)
(step t193 (cl @p_124 @p_123 @p_135) :rule reordering :premises (t192))
(step t194 (cl (or @p_134 @p_125)) :rule forall_inst :args (t$ b$))
(step t195 (cl @p_134 @p_125) :rule or :premises (t194))
(step t196 (cl (not @p_126) (not (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$ ?v0) (= (fun_app$f (swapSyms$ ?v0 ?v1) ?v1) ?v0)))) (forall ((?v0 A_tree$) (?v1 A$)) (or (not (consistent$ ?v0)) (= ?v0 (fun_app$f (swapSyms$ ?v0 ?v1) ?v1))))) :rule equiv_pos2)
(anchor :step t197 :args ((?v0 A_tree$) (?v1 A$) (:= (?v0 A_tree$) ?v0) (:= (?v1 A$) ?v1)))
(step t197.t0 (cl (= @p_131 @p_131)) :rule refl)
(step t197.t1 (cl @p_133) :rule hole :args ("TRUST_THEORY_REWRITE" @p_133 2 6))
(step t197.t2 (cl (= (=> @p_131 @p_132) (=> @p_131 @p_130))) :rule cong :premises (t197.t0 t197.t1))
(step t197 (cl (= (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$ ?v0) (= (fun_app$f (swapSyms$ ?v0 ?v1) ?v1) ?v0))) (forall ((?v0 A_tree$) (?v1 A$)) (=> (consistent$ ?v0) (= ?v0 (fun_app$f (swapSyms$ ?v0 ?v1) ?v1)))))) :rule bind)
(step t198 (cl @p_127) :rule hole :args ("TRUST_THEORY_REWRITE" @p_127 13 6))
(step t199 (cl @p_126) :rule trans :premises (t197 t198))
(step t200 (cl (forall ((?v0 A_tree$) (?v1 A$)) (or (not (consistent$ ?v0)) (= ?v0 (fun_app$f (swapSyms$ ?v0 ?v1) ?v1))))) :rule resolution :premises (t196 t199 a53))
(step t201 (cl @p_125) :rule resolution :premises (t195 t200))
(step t202 (cl @p_123) :rule resolution :premises (t193 a3 t201))
(step t203 (cl (! (not (! (= @p_115 (! (and @p_5 (fun_app$b (less_eq$ @p_1) @p_3)) :named @p_117)) :named @p_118)) :named @p_121) @p_116 @p_117) :rule equiv_pos2)
(step t204 (cl @p_117 @p_116 @p_121) :rule reordering :premises (t203))
(step t205 (cl (! (not @p_117) :named @p_120) @p_5) :rule and_pos :args (0))
(step t206 (cl @p_5 @p_120) :rule reordering :premises (t205))
(step t207 (cl @p_120) :rule resolution :premises (t206 a2))
(step t208 (cl (or (! (not (forall ((?v0 Nat$) (?v1 Nat$)) (= (= ?v0 ?v1) (and (fun_app$b (less_eq$ ?v0) ?v1) (fun_app$b (less_eq$ ?v1) ?v0))))) :named @p_119) @p_118)) :rule forall_inst :args (@p_3 @p_1))
(step t209 (cl @p_119 @p_118) :rule or :premises (t208))
(step t210 (cl @p_118) :rule resolution :premises (t209 a18))
(step t211 (cl @p_116) :rule resolution :premises (t204 t207 t210))
(step t212 (cl (! (and @p_21 @p_105) :named @p_107) @p_22 (! (not @p_105) :named @p_106)) :rule and_neg)
(step t213 (cl (! (=> @p_107 @p_8) :named @p_109) @p_107) :rule implies_neg1)
(anchor :step t214)
(assume t214.a0 @p_21)
(assume t214.a1 @p_105)
(step t214.t0 (cl (= c$ a$)) :rule symm :premises (t214.a1))
(step t214.t1 (cl (= d$ a$)) :rule symm :premises (t214.a0))
(step t214.t2 (cl @p_21) :rule symm :premises (t214.t1))
(step t214.t3 (cl @p_8) :rule trans :premises (t214.t0 t214.t2))
(step t214 (cl @p_22 @p_106 @p_8) :rule subproof :discharge (t214.a0 t214.a1))
(step t215 (cl (! (not @p_107) :named @p_108) @p_21) :rule and_pos :args (0))
(step t216 (cl @p_108 @p_105) :rule and_pos :args (1))
(step t217 (cl @p_8 @p_108 @p_108) :rule resolution :premises (t214 t215 t216))
(step t218 (cl @p_108 @p_108 @p_8) :rule reordering :premises (t217))
(step t219 (cl @p_108 @p_8) :rule contraction :premises (t218))
(step t220 (cl @p_109 @p_8) :rule resolution :premises (t213 t219))
(step t221 (cl @p_109 @p_9) :rule implies_neg2)
(step t222 (cl @p_109 @p_109) :rule resolution :premises (t220 t221))
(step t223 (cl @p_109) :rule contraction :premises (t222))
(step t224 (cl @p_108 @p_8) :rule implies :premises (t223))
(step t225 (cl @p_22 @p_106 @p_8) :rule resolution :premises (t212 t224))
(step t226 (cl @p_8 @p_22 @p_106) :rule reordering :premises (t225))
(step t227 (cl @p_22 @p_86) :rule ite2 :premises (t111))
(step t228 (cl @p_22) :rule resolution :premises (t139 t82 a2 t141 t149 t161 t164 a5 a3 t166 t168 t174 a5 t191 t202 t211 t82 t226 a4 t227))
(step t229 (cl @p_87) :rule resolution :premises (t112 t228))
(step t230 (cl (not (! (= (! (ite @p_19 @p_220 (! (= @p_82 @p_80) :named @p_219)) :named @p_221) (! (ite @p_19 @p_216 (! (= @p_80 @p_82) :named @p_217)) :named @p_218)) :named @p_224)) (! (not @p_221) :named @p_223) @p_218) :rule equiv_pos2)
(step t231 (cl (= @p_19 @p_19)) :rule refl)
(step t232 (cl (! (= @p_220 @p_216) :named @p_226)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_226 2 6))
(step t233 (cl (! (= @p_219 @p_217) :named @p_225)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_225 2 6))
(step t234 (cl @p_224) :rule cong :premises (t231 t232 t233))
(step t235 (cl (not (! (= @p_221 @p_221) :named @p_222)) @p_223 @p_221) :rule equiv_pos2)
(step t236 (cl (= @p_81 @p_81)) :rule refl)
(step t237 (cl (= @p_220 @p_220)) :rule cong :premises (t97 t236))
(step t238 (cl (= @p_80 @p_80)) :rule refl)
(step t239 (cl (= @p_219 @p_219)) :rule cong :premises (t97 t238))
(step t240 (cl @p_222) :rule cong :premises (t231 t237 t239))
(step t241 (cl @p_221) :rule hole)
(step t242 (cl @p_221) :rule resolution :premises (t235 t240 t241))
(step t243 (cl @p_218) :rule resolution :premises (t230 t234 t242))
(step t244 (cl @p_20 @p_216) :rule ite2 :premises (t243))
(step t245 (cl (not (! (= (! (or (! (not @p_22) :named @p_188) (! (not @p_20) :named @p_187)) :named @p_189) (! (or @p_21 @p_19) :named @p_186)) :named @p_190)) (not @p_189) @p_186) :rule equiv_pos2)
(step t246 (cl (! (= @p_188 @p_21) :named @p_192)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_192 1 5))
(step t247 (cl (! (= @p_187 @p_19) :named @p_191)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_191 1 5))
(step t248 (cl @p_190) :rule cong :premises (t246 t247))
(step t249 (cl @p_188 @p_187) :rule not_and :premises (a10))
(step t250 (cl @p_189 (not @p_188)) :rule or_neg :args (0))
(step t251 (cl @p_189 (not @p_187)) :rule or_neg :args (1))
(step t252 (cl @p_189 @p_189) :rule resolution :premises (t249 t250 t251))
(step t253 (cl @p_189) :rule contraction :premises (t252))
(step t254 (cl @p_186) :rule resolution :premises (t245 t248 t253))
(step t255 (cl @p_21 @p_19) :rule or :premises (t254))
(step t256 (cl @p_19) :rule resolution :premises (t255 t228))
(step t257 (cl @p_216) :rule resolution :premises (t244 t256))
(step t258 (cl @p_215) :rule resolution :premises (t59 a2 t82 t229 t257))
(step t259 (cl (or @p_170 @p_214)) :rule forall_inst :args (t$ a$ d$))
(step t260 (cl @p_170 @p_214) :rule or :premises (t259))
(step t261 (cl @p_214) :rule resolution :premises (t260 t148))
(step t262 (cl @p_206) :rule resolution :premises (t3 a3 a6 t15 t27 t258 t261))
(step t263 (cl (! (not (! (or @p_32 @p_21 (! (= b$ d$) :named @p_31) @p_30) :named @p_33)) :named @p_205) @p_32 @p_21 @p_31 @p_30) :rule or_pos)
(step t264 (cl @p_21 @p_32 @p_31 @p_30 @p_205) :rule reordering :premises (t263))
(step t265 (cl (not (! (= (! (or @p_20 (! (not @p_9) :named @p_194) (! (not @p_31) :named @p_78)) :named @p_195) (! (or @p_20 @p_8 @p_78) :named @p_193)) :named @p_203)) (not @p_195) @p_193) :rule equiv_pos2)
(step t266 (cl (= @p_20 @p_20)) :rule refl)
(step t267 (cl (! (= @p_194 @p_8) :named @p_204)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_204 1 5))
(step t268 (cl (= @p_78 @p_78)) :rule refl)
(step t269 (cl @p_203) :rule cong :premises (t266 t267 t268))
(step t270 (cl (! (and @p_19 @p_9) :named @p_198) @p_20 @p_194) :rule and_neg)
(step t271 (cl (! (=> @p_198 @p_78) :named @p_200) @p_198) :rule implies_neg1)
(anchor :step t272)
(assume t272.a0 @p_19)
(assume t272.a1 @p_9)
(step t272.t0 (cl (= (! (= @p_31 false) :named @p_201) @p_78)) :rule equiv_simplify)
(step t272.t1 (cl (not @p_201) @p_78) :rule equiv1 :premises (t272.t0))
(step t272.t2 (cl @p_142) :rule symm :premises (t272.a0))
(step t272.t3 (cl @p_19) :rule symm :premises (t272.t2))
(step t272.t4 (cl (= d$ d$)) :rule refl)
(step t272.t5 (cl (= @p_31 @p_8)) :rule cong :premises (t272.t3 t272.t4))
(step t272.t6 (cl (= (! (= @p_8 false) :named @p_202) @p_9)) :rule equiv_simplify)
(step t272.t7 (cl @p_202 @p_194) :rule equiv2 :premises (t272.t6))
(step t272.t8 (cl (! (not @p_194) :named @p_197) @p_8) :rule not_not)
(step t272.t9 (cl @p_202 @p_8) :rule resolution :premises (t272.t7 t272.t8))
(step t272.t10 (cl @p_202) :rule resolution :premises (t272.t9 t272.a1))
(step t272.t11 (cl @p_201) :rule trans :premises (t272.t5 t272.t10))
(step t272.t12 (cl @p_78) :rule resolution :premises (t272.t1 t272.t11))
(step t272 (cl @p_20 @p_194 @p_78) :rule subproof :discharge (t272.a0 t272.a1))
(step t273 (cl (! (not @p_198) :named @p_199) @p_19) :rule and_pos :args (0))
(step t274 (cl @p_199 @p_9) :rule and_pos :args (1))
(step t275 (cl @p_78 @p_199 @p_199) :rule resolution :premises (t272 t273 t274))
(step t276 (cl @p_199 @p_199 @p_78) :rule reordering :premises (t275))
(step t277 (cl @p_199 @p_78) :rule contraction :premises (t276))
(step t278 (cl @p_200 @p_78) :rule resolution :premises (t271 t277))
(step t279 (cl @p_200 (! (not @p_78) :named @p_196)) :rule implies_neg2)
(step t280 (cl @p_200 @p_200) :rule resolution :premises (t278 t279))
(step t281 (cl @p_200) :rule contraction :premises (t280))
(step t282 (cl @p_199 @p_78) :rule implies :premises (t281))
(step t283 (cl @p_20 @p_194 @p_78) :rule resolution :premises (t270 t282))
(step t284 (cl @p_195 @p_187) :rule or_neg :args (0))
(step t285 (cl @p_195 @p_197) :rule or_neg :args (1))
(step t286 (cl @p_195 @p_196) :rule or_neg :args (2))
(step t287 (cl @p_195 @p_195 @p_195) :rule resolution :premises (t283 t284 t285 t286))
(step t288 (cl @p_195) :rule contraction :premises (t287))
(step t289 (cl @p_193) :rule resolution :premises (t265 t269 t288))
(step t290 (cl @p_20 @p_8 @p_78) :rule or :premises (t289))
(step t291 (cl @p_8 @p_20 @p_78) :rule reordering :premises (t290))
(step t292 (cl @p_78) :rule resolution :premises (t291 a4 t256))
(step t293 (cl (or @p_77 @p_33)) :rule forall_inst :args (d$))
(step t294 (cl @p_77 @p_33) :rule or :premises (t293))
(step t295 (cl @p_33) :rule resolution :premises (t294 t173))
(step t296 (cl @p_30) :rule resolution :premises (t264 t228 a6 t292 t295))
(step t297 (cl) :rule resolution :premises (t1 t262 t296))
