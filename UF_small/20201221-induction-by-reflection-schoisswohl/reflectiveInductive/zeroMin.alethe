unsat
(define-fun @quantifiers_skolemize_1 () nat (choice ((x nat)) (not (leq zero x))))
(define-fun @quantifiers_skolemize_15 () nat (choice ((x0 nat)) (not (or (not (models (push_nat empty v0_nat x0) (leqR zeroR (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (leqR zeroR (inj_nat v0_nat)))))))
(assume a0 (forall ((x nat)) (leq x x)))
(assume a1 (forall ((x nat) (y nat)) (=> (leq x y) (leq x (s y)))))
(assume a2 (forall ((env env) (v var_nat) (x nat)) (= (evalV_nat (push_nat env v x) v) x)))
(assume a3 (forall ((env env) (v var_nat) (w var_nat) (x nat)) (=> (not (= v w)) (= (evalV_nat (push_nat env w x) v) (evalV_nat env v)))))
(assume a4 (forall ((env env) (v var_nat)) (= (eval_nat env (inj_nat v)) (evalV_nat env v))))
(assume a5 (forall ((env env)) (= (eval_nat env zeroR) zero)))
(assume a6 (forall ((env env) (t0 term_nat)) (= (eval_nat env (sR t0)) (s (eval_nat env t0)))))
(assume a7 (forall ((env env) (x term_nat) (y term_nat)) (= (models env (eq_nat x y)) (= (eval_nat env x) (eval_nat env y)))))
(assume a8 (forall ((env env) (t0 term_nat) (t1 term_nat)) (= (models env (leqR t0 t1)) (leq (eval_nat env t0) (eval_nat env t1)))))
(assume a9 (forall ((env env)) (= (models env falseR) false)))
(assume a10 (forall ((env env) (phi form)) (= (models env (notR phi)) (not (models env phi)))))
(assume a11 (forall ((env env) (phi form) (psi form)) (= (models env (orR phi psi)) (or (models env phi) (models env psi)))))
(assume a12 (forall ((env env) (phi form) (v var_nat)) (= (models env (forallR_nat v phi)) (forall ((x nat)) (models (push_nat env v x) phi)))))
(assume a13 (forall ((phi form)) (=> (and (=> true (models (push_nat empty v0_nat zero) phi)) (forall ((x0 nat)) (=> (models (push_nat empty v0_nat x0) phi) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))))
(assume a14 (forall ((x0 nat)) (not (= zero (s x0)))))
(assume a15 (forall ((x0 nat) (x1 nat)) (=> (= (s x0) (s x1)) (= x0 x1))))
(assume a16 (! (not (forall ((x nat)) (leq zero x))) :named @p_1))
(step t0 (cl (not (! (= (! (or (! (not (! (not (! (leq zero @quantifiers_skolemize_1) :named @p_2)) :named @p_3)) :named @p_136) (! (not (! (= zero (! (eval_nat (! (push_nat empty v0_nat @quantifiers_skolemize_1) :named @p_5) zeroR) :named @p_6)) :named @p_7)) :named @p_131) (! (not (! (= @quantifiers_skolemize_1 (! (evalV_nat @p_5 v0_nat) :named @p_13)) :named @p_14)) :named @p_133) (! (not (! (= @p_13 (! (eval_nat (! (push_nat empty v0_nat @quantifiers_skolemize_1) :named @p_5) (! (inj_nat v0_nat) :named @p_20)) :named @p_21)) :named @p_130)) :named @p_134) (! (not (! (leq @p_6 @p_21) :named @p_22)) :named @p_132)) :named @p_137) (! (or @p_2 @p_131 @p_133 @p_134 @p_132) :named @p_135)) :named @p_146)) (not @p_137) @p_135) :rule equiv_pos2)
(step t1 (cl (! (= @p_136 @p_2) :named @p_147)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_147 1 5))
(step t2 (cl (= @p_131 @p_131)) :rule refl)
(step t3 (cl (= @p_133 @p_133)) :rule refl)
(step t4 (cl (= @p_134 @p_134)) :rule refl)
(step t5 (cl (= @p_132 @p_132)) :rule refl)
(step t6 (cl @p_146) :rule cong :premises (t1 t2 t3 t4 t5))
(step t7 (cl (! (=> (! (and @p_3 @p_7 @p_14 @p_130 @p_22) :named @p_139) false) :named @p_141) @p_139) :rule implies_neg1)
(anchor :step t8)
(assume t8.a0 @p_3)
(assume t8.a1 @p_7)
(assume t8.a2 @p_14)
(assume t8.a3 @p_130)
(assume t8.a4 @p_22)
(step t8.t0 (cl (not (! (= (! (= true false) :named @p_142) false) :named @p_145)) (not @p_142) false) :rule equiv_pos2)
(step t8.t1 (cl @p_145) :rule hole :args ("TRUST_THEORY_REWRITE" @p_145 1 5))
(step t8.t2 (cl (= (! (= @p_22 true) :named @p_144) @p_22)) :rule equiv_simplify)
(step t8.t3 (cl @p_144 @p_132) :rule equiv2 :premises (t8.t2))
(step t8.t4 (cl @p_144) :rule resolution :premises (t8.t3 t8.a4))
(step t8.t5 (cl (= true @p_22)) :rule symm :premises (t8.t4))
(step t8.t6 (cl (or (! (not (forall ((env env)) (= zero (eval_nat env zeroR)))) :named @p_12) @p_7)) :rule forall_inst :args (@p_5))
(step t8.t7 (cl @p_12 @p_7) :rule or :premises (t8.t6))
(step t8.t8 (cl (not (! (= (forall ((env env)) (= (eval_nat env zeroR) zero)) (forall ((env env)) (= zero (eval_nat env zeroR)))) :named @p_8)) (not (forall ((env env)) (= (eval_nat env zeroR) zero))) (forall ((env env)) (= zero (eval_nat env zeroR)))) :rule equiv_pos2)
(anchor :step t8.t9 :args ((env env) (:= (env env) env)))
(step t8.t9.t0 (cl (! (= (= (! (eval_nat env zeroR) :named @p_10) zero) (= zero @p_10)) :named @p_11)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_11 2 6))
(step t8.t9 (cl @p_8) :rule bind)
(step t8.t10 (cl (forall ((env env)) (= zero (eval_nat env zeroR)))) :rule resolution :premises (t8.t8 t8.t9 a5))
(step t8.t11 (cl @p_7) :rule resolution :premises (t8.t7 t8.t10))
(step t8.t12 (cl (= @p_6 zero)) :rule symm :premises (t8.t11))
(step t8.t13 (cl (or (! (not (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :named @p_82) @p_130)) :rule forall_inst :args (@p_5 v0_nat))
(step t8.t14 (cl @p_82 @p_130) :rule or :premises (t8.t13))
(step t8.t15 (cl (not (! (= (forall ((env env) (v var_nat)) (= (eval_nat env (inj_nat v)) (evalV_nat env v))) (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :named @p_78)) (not (forall ((env env) (v var_nat)) (= (eval_nat env (inj_nat v)) (evalV_nat env v)))) (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule equiv_pos2)
(anchor :step t8.t16 :args ((env env) (v var_nat) (:= (env env) env) (:= (v var_nat) v)))
(step t8.t16.t0 (cl (! (= (= (! (eval_nat env (inj_nat v)) :named @p_79) (! (evalV_nat env v) :named @p_80)) (= @p_80 @p_79)) :named @p_81)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_81 2 6))
(step t8.t16 (cl @p_78) :rule bind)
(step t8.t17 (cl (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule resolution :premises (t8.t15 t8.t16 a4))
(step t8.t18 (cl @p_130) :rule resolution :premises (t8.t14 t8.t17))
(step t8.t19 (cl (= @p_21 @p_13)) :rule symm :premises (t8.t18))
(step t8.t20 (cl (or (! (not (forall ((env env) (v var_nat) (x nat)) (= x (evalV_nat (push_nat env v x) v)))) :named @p_19) @p_14)) :rule forall_inst :args (empty v0_nat @quantifiers_skolemize_1))
(step t8.t21 (cl @p_19 @p_14) :rule or :premises (t8.t20))
(step t8.t22 (cl (not (! (= (forall ((env env) (v var_nat) (x nat)) (= (evalV_nat (push_nat env v x) v) x)) (forall ((env env) (v var_nat) (x nat)) (= x (evalV_nat (push_nat env v x) v)))) :named @p_15)) (not (forall ((env env) (v var_nat) (x nat)) (= (evalV_nat (push_nat env v x) v) x))) (forall ((env env) (v var_nat) (x nat)) (= x (evalV_nat (push_nat env v x) v)))) :rule equiv_pos2)
(anchor :step t8.t23 :args ((env env) (v var_nat) (x nat) (:= (env env) env) (:= (v var_nat) v) (:= (x nat) x)))
(step t8.t23.t0 (cl (! (= (= (! (evalV_nat (push_nat env v x) v) :named @p_17) x) (= x @p_17)) :named @p_18)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_18 2 6))
(step t8.t23 (cl @p_15) :rule bind)
(step t8.t24 (cl (forall ((env env) (v var_nat) (x nat)) (= x (evalV_nat (push_nat env v x) v)))) :rule resolution :premises (t8.t22 t8.t23 a2))
(step t8.t25 (cl @p_14) :rule resolution :premises (t8.t21 t8.t24))
(step t8.t26 (cl (= @p_13 @quantifiers_skolemize_1)) :rule symm :premises (t8.t25))
(step t8.t27 (cl (= @p_21 @quantifiers_skolemize_1)) :rule trans :premises (t8.t19 t8.t26))
(step t8.t28 (cl (= @p_22 @p_2)) :rule cong :premises (t8.t12 t8.t27))
(step t8.t29 (cl (= (! (= @p_2 false) :named @p_143) @p_3)) :rule equiv_simplify)
(step t8.t30 (cl @p_143 @p_136) :rule equiv2 :premises (t8.t29))
(step t8.t31 (cl (! (not @p_136) :named @p_138) @p_2) :rule not_not)
(step t8.t32 (cl @p_143 @p_2) :rule resolution :premises (t8.t30 t8.t31))
(step t8.t33 (cl (not (! (= @p_1 @p_3) :named @p_4)) (not @p_1) @p_3) :rule equiv_pos2)
(anchor :step t8.t34 :args ((:= (x nat) @quantifiers_skolemize_1)))
(step t8.t34.t0 (cl (= (leq zero x) @p_2)) :rule refl)
(step t8.t34 (cl (= (forall ((x nat)) (leq zero x)) @p_2)) :rule sko_forall)
(step t8.t35 (cl @p_4) :rule cong :premises (t8.t34))
(step t8.t36 (cl @p_3) :rule resolution :premises (t8.t33 t8.t35 a16))
(step t8.t37 (cl @p_143) :rule resolution :premises (t8.t32 t8.t36))
(step t8.t38 (cl @p_142) :rule trans :premises (t8.t5 t8.t28 t8.t37))
(step t8.t39 (cl false) :rule resolution :premises (t8.t0 t8.t1 t8.t38))
(step t8 (cl @p_136 @p_131 @p_133 @p_134 @p_132 false) :rule subproof :discharge (t8.a0 t8.a1 t8.a2 t8.a3 t8.a4))
(step t9 (cl (! (not @p_139) :named @p_140) @p_3) :rule and_pos :args (0))
(step t10 (cl @p_140 @p_7) :rule and_pos :args (1))
(step t11 (cl @p_140 @p_14) :rule and_pos :args (2))
(step t12 (cl @p_140 @p_130) :rule and_pos :args (3))
(step t13 (cl @p_140 @p_22) :rule and_pos :args (4))
(step t14 (cl false @p_140 @p_140 @p_140 @p_140 @p_140) :rule resolution :premises (t8 t9 t10 t11 t12 t13))
(step t15 (cl @p_140 @p_140 @p_140 @p_140 @p_140 false) :rule reordering :premises (t14))
(step t16 (cl @p_140 false) :rule contraction :premises (t15))
(step t17 (cl @p_141 false) :rule resolution :premises (t7 t16))
(step t18 (cl @p_141 (not false)) :rule implies_neg2)
(step t19 (cl @p_141 @p_141) :rule resolution :premises (t17 t18))
(step t20 (cl @p_141) :rule contraction :premises (t19))
(step t21 (cl (= @p_141 @p_140)) :rule implies_simplify)
(step t22 (cl (not @p_141) @p_140) :rule equiv1 :premises (t21))
(step t23 (cl @p_140) :rule resolution :premises (t20 t22))
(step t24 (cl @p_136 @p_131 @p_133 @p_134 @p_132) :rule not_and :premises (t23))
(step t25 (cl @p_137 @p_138) :rule or_neg :args (0))
(step t26 (cl @p_137 (not @p_131)) :rule or_neg :args (1))
(step t27 (cl @p_137 (not @p_133)) :rule or_neg :args (2))
(step t28 (cl @p_137 (not @p_134)) :rule or_neg :args (3))
(step t29 (cl @p_137 (not @p_132)) :rule or_neg :args (4))
(step t30 (cl @p_137 @p_137 @p_137 @p_137 @p_137) :rule resolution :premises (t24 t25 t26 t27 t28 t29))
(step t31 (cl @p_137) :rule contraction :premises (t30))
(step t32 (cl @p_135) :rule resolution :premises (t0 t6 t31))
(step t33 (cl @p_2 @p_131 @p_133 @p_134 @p_132) :rule or :premises (t32))
(step t34 (cl @p_2 @p_131 @p_132 @p_133 @p_134) :rule reordering :premises (t33))
(step t35 (cl (or @p_82 @p_130)) :rule forall_inst :args (@p_5 v0_nat))
(step t36 (cl @p_82 @p_130) :rule or :premises (t35))
(step t37 (cl (not @p_78) (not (forall ((env env) (v var_nat)) (= (eval_nat env (inj_nat v)) (evalV_nat env v)))) (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule equiv_pos2)
(anchor :step t38 :args ((env env) (v var_nat) (:= (env env) env) (:= (v var_nat) v)))
(step t38.t0 (cl @p_81) :rule hole :args ("TRUST_THEORY_REWRITE" @p_81 2 6))
(step t38 (cl @p_78) :rule bind)
(step t39 (cl (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule resolution :premises (t37 t38 a4))
(step t40 (cl @p_130) :rule resolution :premises (t36 t39))
(step t41 (cl (! (not (! (= (! (models @p_5 (! (leqR zeroR @p_20) :named @p_23)) :named @p_24) @p_22) :named @p_25)) :named @p_129) (! (not @p_24) :named @p_128) @p_22) :rule equiv_pos2)
(step t42 (cl @p_128 @p_22 @p_129) :rule reordering :premises (t41))
(step t43 (cl (! (not (! (or (! (not (! (models (! (push_nat empty v0_nat zero) :named @p_28) @p_23) :named @p_29)) :named @p_30) (! (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) (leqR zeroR (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (leqR zeroR (inj_nat v0_nat)))))) :named @p_27) @p_24) :named @p_31)) :named @p_127) @p_30 @p_27 @p_24) :rule or_pos)
(step t44 (cl @p_30 @p_27 @p_24 @p_127) :rule reordering :premises (t43))
(step t45 (cl (! (not (! (= @p_29 (! (leq (! (eval_nat @p_28 zeroR) :named @p_114) (! (eval_nat @p_28 @p_20) :named @p_113)) :named @p_115)) :named @p_116)) :named @p_126) @p_29 (! (not @p_115) :named @p_125)) :rule equiv_pos1)
(step t46 (cl @p_29 @p_125 @p_126) :rule reordering :premises (t45))
(step t47 (cl (= (! (= @p_115 true) :named @p_117) @p_115)) :rule equiv_simplify)
(step t48 (cl (not @p_117) @p_115) :rule equiv1 :premises (t47))
(step t49 (cl (or @p_12 (! (= zero @p_114) :named @p_124))) :rule forall_inst :args (@p_28))
(step t50 (cl @p_12 @p_124) :rule or :premises (t49))
(step t51 (cl (not @p_8) (not (forall ((env env)) (= (eval_nat env zeroR) zero))) (forall ((env env)) (= zero (eval_nat env zeroR)))) :rule equiv_pos2)
(anchor :step t52 :args ((env env) (:= (env env) env)))
(step t52.t0 (cl @p_11) :rule hole :args ("TRUST_THEORY_REWRITE" @p_11 2 6))
(step t52 (cl @p_8) :rule bind)
(step t53 (cl (forall ((env env)) (= zero (eval_nat env zeroR)))) :rule resolution :premises (t51 t52 a5))
(step t54 (cl @p_124) :rule resolution :premises (t50 t53))
(step t55 (cl (= @p_114 zero)) :rule symm :premises (t54))
(step t56 (cl (or @p_82 (! (= (! (evalV_nat @p_28 v0_nat) :named @p_121) @p_113) :named @p_123))) :rule forall_inst :args (@p_28 v0_nat))
(step t57 (cl @p_82 @p_123) :rule or :premises (t56))
(step t58 (cl @p_123) :rule resolution :premises (t57 t39))
(step t59 (cl (= @p_113 @p_121)) :rule symm :premises (t58))
(step t60 (cl (or @p_19 (! (= zero @p_121) :named @p_122))) :rule forall_inst :args (empty v0_nat zero))
(step t61 (cl @p_19 @p_122) :rule or :premises (t60))
(step t62 (cl (not @p_15) (not (forall ((env env) (v var_nat) (x nat)) (= (evalV_nat (push_nat env v x) v) x))) (forall ((env env) (v var_nat) (x nat)) (= x (evalV_nat (push_nat env v x) v)))) :rule equiv_pos2)
(anchor :step t63 :args ((env env) (v var_nat) (x nat) (:= (env env) env) (:= (v var_nat) v) (:= (x nat) x)))
(step t63.t0 (cl @p_18) :rule hole :args ("TRUST_THEORY_REWRITE" @p_18 2 6))
(step t63 (cl @p_15) :rule bind)
(step t64 (cl (forall ((env env) (v var_nat) (x nat)) (= x (evalV_nat (push_nat env v x) v)))) :rule resolution :premises (t62 t63 a2))
(step t65 (cl @p_122) :rule resolution :premises (t61 t64))
(step t66 (cl (= @p_121 zero)) :rule symm :premises (t65))
(step t67 (cl (= @p_113 zero)) :rule trans :premises (t59 t66))
(step t68 (cl (= @p_115 (! (leq zero zero) :named @p_118))) :rule cong :premises (t55 t67))
(step t69 (cl (= (! (= @p_118 true) :named @p_119) @p_118)) :rule equiv_simplify)
(step t70 (cl @p_119 (not @p_118)) :rule equiv2 :premises (t69))
(step t71 (cl (or (! (not (forall ((x nat)) (leq x x))) :named @p_120) @p_118)) :rule forall_inst :args (zero))
(step t72 (cl @p_120 @p_118) :rule or :premises (t71))
(step t73 (cl @p_118) :rule resolution :premises (t72 a0))
(step t74 (cl @p_119) :rule resolution :premises (t70 t73))
(step t75 (cl @p_117) :rule trans :premises (t68 t74))
(step t76 (cl @p_115) :rule resolution :premises (t48 t75))
(step t77 (cl (or (! (not (forall ((env env) (t0 term_nat) (t1 term_nat)) (= (models env (leqR t0 t1)) (leq (eval_nat env t0) (eval_nat env t1))))) :named @p_26) @p_116)) :rule forall_inst :args (@p_28 zeroR @p_20))
(step t78 (cl @p_26 @p_116) :rule or :premises (t77))
(step t79 (cl @p_116) :rule resolution :premises (t78 a8))
(step t80 (cl @p_29) :rule resolution :premises (t46 t76 t79))
(step t81 (cl (not (! (= (! (or (! (not @p_27) :named @p_106) (! (not (! (or (! (not (! (models (! (push_nat empty v0_nat @quantifiers_skolemize_15) :named @p_45) @p_23) :named @p_46)) :named @p_47) (! (models (! (push_nat empty v0_nat (! (s @quantifiers_skolemize_15) :named @p_42)) :named @p_43) @p_23) :named @p_44)) :named @p_48)) :named @p_52)) :named @p_107) (! (or (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) (leqR zeroR (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (leqR zeroR (inj_nat v0_nat))))) @p_52) :named @p_105)) :named @p_111)) (not @p_107) @p_105) :rule equiv_pos2)
(step t82 (cl (! (= @p_106 (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) (leqR zeroR (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (leqR zeroR (inj_nat v0_nat)))))) :named @p_112)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_112 1 5))
(step t83 (cl (= @p_52 @p_52)) :rule refl)
(step t84 (cl @p_111) :rule cong :premises (t82 t83))
(step t85 (cl (! (=> @p_27 @p_52) :named @p_109) @p_27) :rule implies_neg1)
(anchor :step t86)
(assume t86.a0 @p_27)
(step t86.t0 (cl (not (! (= @p_27 @p_52) :named @p_110)) @p_106 @p_52) :rule equiv_pos2)
(anchor :step t86.t1 :args ((:= (x0 nat) @quantifiers_skolemize_15)))
(step t86.t1.t0 (cl (= (or (not (models (push_nat empty v0_nat x0) @p_23)) (models (push_nat empty v0_nat (s x0)) @p_23)) @p_48)) :rule refl)
(step t86.t1 (cl (= (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) (leqR zeroR (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (leqR zeroR (inj_nat v0_nat))))) @p_48)) :rule sko_forall)
(step t86.t2 (cl @p_110) :rule cong :premises (t86.t1))
(step t86.t3 (cl @p_52) :rule resolution :premises (t86.t0 t86.t2 t86.a0))
(step t86 (cl @p_106 @p_52) :rule subproof :discharge (t86.a0))
(step t87 (cl @p_109 @p_52) :rule resolution :premises (t85 t86))
(step t88 (cl @p_109 (! (not @p_52) :named @p_108)) :rule implies_neg2)
(step t89 (cl @p_109 @p_109) :rule resolution :premises (t87 t88))
(step t90 (cl @p_109) :rule contraction :premises (t89))
(step t91 (cl @p_106 @p_52) :rule implies :premises (t90))
(step t92 (cl @p_107 (not @p_106)) :rule or_neg :args (0))
(step t93 (cl @p_107 @p_108) :rule or_neg :args (1))
(step t94 (cl @p_107 @p_107) :rule resolution :premises (t91 t92 t93))
(step t95 (cl @p_107) :rule contraction :premises (t94))
(step t96 (cl @p_105) :rule resolution :premises (t81 t84 t95))
(step t97 (cl (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) (leqR zeroR (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (leqR zeroR (inj_nat v0_nat))))) @p_52) :rule or :premises (t96))
(step t98 (cl (not (! (= (! (or (! (not (! (not (! (leq (! (eval_nat @p_43 zeroR) :named @p_61) (! (eval_nat @p_43 @p_20) :named @p_60)) :named @p_62)) :named @p_64)) :named @p_94) (! (not (! (= zero @p_61) :named @p_84)) :named @p_90) (! (not (! (= zero (! (eval_nat @p_45 zeroR) :named @p_56)) :named @p_85)) :named @p_91) (! (not (! (= (! (evalV_nat @p_43 v0_nat) :named @p_75) (! (eval_nat @p_43 @p_20) :named @p_60)) :named @p_83)) :named @p_89) (! (not (! (= @p_42 @p_75) :named @p_76)) :named @p_87) (! (not (! (= @quantifiers_skolemize_15 (! (evalV_nat @p_45 v0_nat) :named @p_73)) :named @p_74)) :named @p_86) (! (not (! (= @p_73 (! (eval_nat @p_45 @p_20) :named @p_55)) :named @p_77)) :named @p_88) (! (not (! (leq @p_56 (! (s @p_55) :named @p_66)) :named @p_67)) :named @p_92)) :named @p_95) (! (or @p_62 @p_90 @p_91 @p_89 @p_87 @p_86 @p_88 @p_92) :named @p_93)) :named @p_103)) (not @p_95) @p_93) :rule equiv_pos2)
(step t99 (cl (! (= @p_94 @p_62) :named @p_104)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_104 1 5))
(step t100 (cl (= @p_90 @p_90)) :rule refl)
(step t101 (cl (= @p_91 @p_91)) :rule refl)
(step t102 (cl (= @p_89 @p_89)) :rule refl)
(step t103 (cl (= @p_87 @p_87)) :rule refl)
(step t104 (cl (= @p_86 @p_86)) :rule refl)
(step t105 (cl (= @p_88 @p_88)) :rule refl)
(step t106 (cl (= @p_92 @p_92)) :rule refl)
(step t107 (cl @p_103) :rule cong :premises (t99 t100 t101 t102 t103 t104 t105 t106))
(step t108 (cl (! (and @p_64 @p_84 @p_85 @p_83 @p_76 @p_74 @p_77) :named @p_98) @p_94 @p_90 @p_91 @p_89 @p_87 @p_86 @p_88) :rule and_neg)
(step t109 (cl (! (=> @p_98 @p_92) :named @p_100) @p_98) :rule implies_neg1)
(anchor :step t110)
(assume t110.a0 @p_64)
(assume t110.a1 @p_84)
(assume t110.a2 @p_85)
(assume t110.a3 @p_83)
(assume t110.a4 @p_76)
(assume t110.a5 @p_74)
(assume t110.a6 @p_77)
(step t110.t0 (cl (= (! (= @p_67 false) :named @p_101) @p_92)) :rule equiv_simplify)
(step t110.t1 (cl (not @p_101) @p_92) :rule equiv1 :premises (t110.t0))
(step t110.t2 (cl (or @p_12 @p_85)) :rule forall_inst :args (@p_45))
(step t110.t3 (cl @p_12 @p_85) :rule or :premises (t110.t2))
(step t110.t4 (cl @p_85) :rule resolution :premises (t110.t3 t53))
(step t110.t5 (cl (= @p_56 zero)) :rule symm :premises (t110.t4))
(step t110.t6 (cl (or @p_12 @p_84)) :rule forall_inst :args (@p_43))
(step t110.t7 (cl @p_12 @p_84) :rule or :premises (t110.t6))
(step t110.t8 (cl @p_84) :rule resolution :premises (t110.t7 t53))
(step t110.t9 (cl (= @p_56 @p_61)) :rule trans :premises (t110.t5 t110.t8))
(step t110.t10 (cl (or @p_82 @p_77)) :rule forall_inst :args (@p_45 v0_nat))
(step t110.t11 (cl @p_82 @p_77) :rule or :premises (t110.t10))
(step t110.t12 (cl @p_77) :rule resolution :premises (t110.t11 t39))
(step t110.t13 (cl (= @p_55 @p_73)) :rule symm :premises (t110.t12))
(step t110.t14 (cl (or @p_19 @p_74)) :rule forall_inst :args (empty v0_nat @quantifiers_skolemize_15))
(step t110.t15 (cl @p_19 @p_74) :rule or :premises (t110.t14))
(step t110.t16 (cl @p_74) :rule resolution :premises (t110.t15 t64))
(step t110.t17 (cl (= @p_73 @quantifiers_skolemize_15)) :rule symm :premises (t110.t16))
(step t110.t18 (cl (= @p_55 @quantifiers_skolemize_15)) :rule trans :premises (t110.t13 t110.t17))
(step t110.t19 (cl (= @p_66 @p_42)) :rule cong :premises (t110.t18))
(step t110.t20 (cl (or @p_19 @p_76)) :rule forall_inst :args (empty v0_nat @p_42))
(step t110.t21 (cl @p_19 @p_76) :rule or :premises (t110.t20))
(step t110.t22 (cl @p_76) :rule resolution :premises (t110.t21 t64))
(step t110.t23 (cl (or @p_82 @p_83)) :rule forall_inst :args (@p_43 v0_nat))
(step t110.t24 (cl @p_82 @p_83) :rule or :premises (t110.t23))
(step t110.t25 (cl @p_83) :rule resolution :premises (t110.t24 t39))
(step t110.t26 (cl (= @p_66 @p_60)) :rule trans :premises (t110.t19 t110.t22 t110.t25))
(step t110.t27 (cl (= @p_67 @p_62)) :rule cong :premises (t110.t9 t110.t26))
(step t110.t28 (cl (= (! (= @p_62 false) :named @p_102) @p_64)) :rule equiv_simplify)
(step t110.t29 (cl @p_102 @p_94) :rule equiv2 :premises (t110.t28))
(step t110.t30 (cl (! (not @p_94) :named @p_97) @p_62) :rule not_not)
(step t110.t31 (cl @p_102 @p_62) :rule resolution :premises (t110.t29 t110.t30))
(step t110.t32 (cl @p_102) :rule resolution :premises (t110.t31 t110.a0))
(step t110.t33 (cl @p_101) :rule trans :premises (t110.t27 t110.t32))
(step t110.t34 (cl @p_92) :rule resolution :premises (t110.t1 t110.t33))
(step t110 (cl @p_94 @p_90 @p_91 @p_89 @p_87 @p_86 @p_88 @p_92) :rule subproof :discharge (t110.a0 t110.a1 t110.a2 t110.a3 t110.a4 t110.a5 t110.a6))
(step t111 (cl (! (not @p_98) :named @p_99) @p_64) :rule and_pos :args (0))
(step t112 (cl @p_99 @p_84) :rule and_pos :args (1))
(step t113 (cl @p_99 @p_85) :rule and_pos :args (2))
(step t114 (cl @p_99 @p_83) :rule and_pos :args (3))
(step t115 (cl @p_99 @p_76) :rule and_pos :args (4))
(step t116 (cl @p_99 @p_74) :rule and_pos :args (5))
(step t117 (cl @p_99 @p_77) :rule and_pos :args (6))
(step t118 (cl @p_92 @p_99 @p_99 @p_99 @p_99 @p_99 @p_99 @p_99) :rule resolution :premises (t110 t111 t112 t113 t114 t115 t116 t117))
(step t119 (cl @p_99 @p_99 @p_99 @p_99 @p_99 @p_99 @p_99 @p_92) :rule reordering :premises (t118))
(step t120 (cl @p_99 @p_92) :rule contraction :premises (t119))
(step t121 (cl @p_100 @p_92) :rule resolution :premises (t109 t120))
(step t122 (cl @p_100 (! (not @p_92) :named @p_96)) :rule implies_neg2)
(step t123 (cl @p_100 @p_100) :rule resolution :premises (t121 t122))
(step t124 (cl @p_100) :rule contraction :premises (t123))
(step t125 (cl @p_99 @p_92) :rule implies :premises (t124))
(step t126 (cl @p_94 @p_90 @p_91 @p_89 @p_87 @p_86 @p_88 @p_92) :rule resolution :premises (t108 t125))
(step t127 (cl @p_95 @p_97) :rule or_neg :args (0))
(step t128 (cl @p_95 (not @p_90)) :rule or_neg :args (1))
(step t129 (cl @p_95 (not @p_91)) :rule or_neg :args (2))
(step t130 (cl @p_95 (not @p_89)) :rule or_neg :args (3))
(step t131 (cl @p_95 (not @p_87)) :rule or_neg :args (4))
(step t132 (cl @p_95 (not @p_86)) :rule or_neg :args (5))
(step t133 (cl @p_95 (not @p_88)) :rule or_neg :args (6))
(step t134 (cl @p_95 @p_96) :rule or_neg :args (7))
(step t135 (cl @p_95 @p_95 @p_95 @p_95 @p_95 @p_95 @p_95 @p_95) :rule resolution :premises (t126 t127 t128 t129 t130 t131 t132 t133 t134))
(step t136 (cl @p_95) :rule contraction :premises (t135))
(step t137 (cl @p_93) :rule resolution :premises (t98 t107 t136))
(step t138 (cl @p_62 @p_90 @p_91 @p_89 @p_87 @p_86 @p_88 @p_92) :rule or :premises (t137))
(step t139 (cl @p_62 @p_86 @p_87 @p_88 @p_89 @p_90 @p_91 @p_92) :rule reordering :premises (t138))
(step t140 (cl (or @p_12 @p_85)) :rule forall_inst :args (@p_45))
(step t141 (cl @p_12 @p_85) :rule or :premises (t140))
(step t142 (cl @p_85) :rule resolution :premises (t141 t53))
(step t143 (cl (or @p_12 @p_84)) :rule forall_inst :args (@p_43))
(step t144 (cl @p_12 @p_84) :rule or :premises (t143))
(step t145 (cl @p_84) :rule resolution :premises (t144 t53))
(step t146 (cl (or @p_82 @p_83)) :rule forall_inst :args (@p_43 v0_nat))
(step t147 (cl @p_82 @p_83) :rule or :premises (t146))
(step t148 (cl @p_83) :rule resolution :premises (t147 t39))
(step t149 (cl (or @p_82 @p_77)) :rule forall_inst :args (@p_45 v0_nat))
(step t150 (cl @p_82 @p_77) :rule or :premises (t149))
(step t151 (cl @p_77) :rule resolution :premises (t150 t39))
(step t152 (cl (or @p_19 @p_76)) :rule forall_inst :args (empty v0_nat @p_42))
(step t153 (cl @p_19 @p_76) :rule or :premises (t152))
(step t154 (cl @p_76) :rule resolution :premises (t153 t64))
(step t155 (cl (or @p_19 @p_74)) :rule forall_inst :args (empty v0_nat @quantifiers_skolemize_15))
(step t156 (cl @p_19 @p_74) :rule or :premises (t155))
(step t157 (cl @p_74) :rule resolution :premises (t156 t64))
(step t158 (cl (! (not (! (or (! (not (! (leq @p_56 @p_55) :named @p_57)) :named @p_68) @p_67) :named @p_69)) :named @p_72) @p_68 @p_67) :rule or_pos)
(step t159 (cl @p_68 @p_67 @p_72) :rule reordering :premises (t158))
(step t160 (cl (or (! (not (forall ((x nat) (y nat)) (or (not (leq x y)) (leq x (s y))))) :named @p_71) @p_69)) :rule forall_inst :args (@p_56 @p_55))
(step t161 (cl @p_71 @p_69) :rule or :premises (t160))
(step t162 (cl (not (! (= (forall ((x nat) (y nat)) (=> (leq x y) (leq x (s y)))) (forall ((x nat) (y nat)) (or (not (leq x y)) (leq x (s y))))) :named @p_70)) (not (forall ((x nat) (y nat)) (=> (leq x y) (leq x (s y))))) (forall ((x nat) (y nat)) (or (not (leq x y)) (leq x (s y))))) :rule equiv_pos2)
(step t163 (cl @p_70) :rule hole :args ("TRUST_THEORY_REWRITE" @p_70 13 6))
(step t164 (cl (forall ((x nat) (y nat)) (or (not (leq x y)) (leq x (s y))))) :rule resolution :premises (t162 t163 a1))
(step t165 (cl @p_69) :rule resolution :premises (t161 t164))
(step t166 (cl (! (not (! (= @p_44 @p_62) :named @p_63)) :named @p_65) @p_44 @p_64) :rule equiv_pos1)
(step t167 (cl @p_44 @p_64 @p_65) :rule reordering :premises (t166))
(step t168 (cl (or @p_26 @p_63)) :rule forall_inst :args (@p_43 zeroR @p_20))
(step t169 (cl @p_26 @p_63) :rule or :premises (t168))
(step t170 (cl @p_63) :rule resolution :premises (t169 a8))
(step t171 (cl (! (not (! (= @p_46 @p_57) :named @p_58)) :named @p_59) @p_47 @p_57) :rule equiv_pos2)
(step t172 (cl @p_47 @p_57 @p_59) :rule reordering :premises (t171))
(step t173 (cl (or @p_26 @p_58)) :rule forall_inst :args (@p_45 zeroR @p_20))
(step t174 (cl @p_26 @p_58) :rule or :premises (t173))
(step t175 (cl @p_58) :rule resolution :premises (t174 a8))
(step t176 (cl @p_48 (not @p_44)) :rule or_neg :args (1))
(step t177 (cl (not (! (= (! (or @p_48 (! (not @p_47) :named @p_50)) :named @p_51) (! (or @p_48 @p_46) :named @p_49)) :named @p_53)) (not @p_51) @p_49) :rule equiv_pos2)
(step t178 (cl (= @p_48 @p_48)) :rule refl)
(step t179 (cl (! (= @p_50 @p_46) :named @p_54)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_54 1 5))
(step t180 (cl @p_53) :rule cong :premises (t178 t179))
(step t181 (cl @p_48 @p_50) :rule or_neg :args (0))
(step t182 (cl @p_51 @p_52) :rule or_neg :args (0))
(step t183 (cl @p_51 (not @p_50)) :rule or_neg :args (1))
(step t184 (cl @p_51 @p_51) :rule resolution :premises (t181 t182 t183))
(step t185 (cl @p_51) :rule contraction :premises (t184))
(step t186 (cl @p_49) :rule resolution :premises (t177 t180 t185))
(step t187 (cl @p_48 @p_46) :rule or :premises (t186))
(step t188 (cl @p_46 @p_48) :rule reordering :premises (t187))
(step t189 (cl @p_48) :rule resolution :premises (t139 t142 t145 t148 t151 t154 t157 t159 t165 t167 t170 t172 t175 t176 t188))
(step t190 (cl (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) (leqR zeroR (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (leqR zeroR (inj_nat v0_nat)))))) :rule resolution :premises (t97 t189))
(step t191 (cl (or (! (not (forall ((phi form) (BOUND_VARIABLE_530 nat)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (models (push_nat empty v0_nat BOUND_VARIABLE_530) phi)))) :named @p_41) @p_31)) :rule forall_inst :args (@p_23 @quantifiers_skolemize_1))
(step t192 (cl @p_41 @p_31) :rule or :premises (t191))
(step t193 (cl (not (! (= (forall ((phi form)) (=> (and (=> true (models (push_nat empty v0_nat zero) phi)) (forall ((x0 nat)) (=> (models (push_nat empty v0_nat x0) phi) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))) (forall ((phi form) (BOUND_VARIABLE_530 nat)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (models (push_nat empty v0_nat BOUND_VARIABLE_530) phi)))) :named @p_32)) (not (forall ((phi form)) (=> (and (=> true (models (push_nat empty v0_nat zero) phi)) (forall ((x0 nat)) (=> (models (push_nat empty v0_nat x0) phi) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi))))) (forall ((phi form) (BOUND_VARIABLE_530 nat)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (models (push_nat empty v0_nat BOUND_VARIABLE_530) phi)))) :rule equiv_pos2)
(anchor :step t194 :args ((phi form) (:= (phi form) phi)))
(step t194.t0 (cl (! (= (! (=> true (! (models @p_28 phi) :named @p_35)) :named @p_37) (! (models @p_28 phi) :named @p_35)) :named @p_40)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_40 1 5))
(step t194.t1 (cl (! (= (forall ((x0 nat)) (=> (models (push_nat empty v0_nat x0) phi) (models (push_nat empty v0_nat (s x0)) phi))) (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) :named @p_39)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_39 13 6))
(step t194.t2 (cl (= (! (and @p_37 (forall ((x0 nat)) (=> (models (push_nat empty v0_nat x0) phi) (models (push_nat empty v0_nat (s x0)) phi)))) :named @p_38) (! (and @p_35 (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) :named @p_36))) :rule cong :premises (t194.t0 t194.t1))
(step t194.t3 (cl (= (forall ((x nat)) (models (push_nat empty v0_nat x) phi)) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))) :rule refl)
(step t194.t4 (cl (= (=> @p_38 (forall ((x nat)) (models (push_nat empty v0_nat x) phi))) (=> @p_36 (forall ((x nat)) (models (push_nat empty v0_nat x) phi))))) :rule cong :premises (t194.t2 t194.t3))
(step t194 (cl (= (forall ((phi form)) (=> (and (=> true (models (push_nat empty v0_nat zero) phi)) (forall ((x0 nat)) (=> (models (push_nat empty v0_nat x0) phi) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))) (forall ((phi form)) (=> (and (models (push_nat empty v0_nat zero) phi) (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))))) :rule bind)
(step t195 (cl (! (= (forall ((phi form)) (=> (and (models (push_nat empty v0_nat zero) phi) (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))) (forall ((phi form)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi))))) :named @p_34)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_34 13 6))
(step t196 (cl (! (= (forall ((phi form)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))) (forall ((phi form) (BOUND_VARIABLE_530 nat)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (models (push_nat empty v0_nat BOUND_VARIABLE_530) phi)))) :named @p_33)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_33 13 6))
(step t197 (cl (= (forall ((phi form)) (=> (and (models (push_nat empty v0_nat zero) phi) (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))) (forall ((phi form) (BOUND_VARIABLE_530 nat)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (models (push_nat empty v0_nat BOUND_VARIABLE_530) phi))))) :rule trans :premises (t195 t196))
(step t198 (cl @p_32) :rule trans :premises (t194 t197))
(step t199 (cl (forall ((phi form) (BOUND_VARIABLE_530 nat)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (models (push_nat empty v0_nat BOUND_VARIABLE_530) phi)))) :rule resolution :premises (t193 t198 a13))
(step t200 (cl @p_31) :rule resolution :premises (t192 t199))
(step t201 (cl @p_24) :rule resolution :premises (t44 t80 t190 t200))
(step t202 (cl (or @p_26 @p_25)) :rule forall_inst :args (@p_5 zeroR @p_20))
(step t203 (cl @p_26 @p_25) :rule or :premises (t202))
(step t204 (cl @p_25) :rule resolution :premises (t203 a8))
(step t205 (cl @p_22) :rule resolution :premises (t42 t201 t204))
(step t206 (cl (or @p_19 @p_14)) :rule forall_inst :args (empty v0_nat @quantifiers_skolemize_1))
(step t207 (cl @p_19 @p_14) :rule or :premises (t206))
(step t208 (cl @p_14) :rule resolution :premises (t207 t64))
(step t209 (cl (or @p_12 @p_7)) :rule forall_inst :args (@p_5))
(step t210 (cl @p_12 @p_7) :rule or :premises (t209))
(step t211 (cl @p_7) :rule resolution :premises (t210 t53))
(step t212 (cl (not @p_4) (not @p_1) @p_3) :rule equiv_pos2)
(anchor :step t213 :args ((:= (x nat) @quantifiers_skolemize_1)))
(step t213.t0 (cl (= (leq zero x) @p_2)) :rule refl)
(step t213 (cl (= (forall ((x nat)) (leq zero x)) @p_2)) :rule sko_forall)
(step t214 (cl @p_4) :rule cong :premises (t213))
(step t215 (cl @p_3) :rule resolution :premises (t212 t214 a16))
(step t216 (cl) :rule resolution :premises (t34 t40 t205 t208 t211 t215))
