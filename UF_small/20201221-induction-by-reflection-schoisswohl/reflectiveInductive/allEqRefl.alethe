unsat
(define-fun @quantifiers_skolemize_1 () nat (choice ((x nat)) (not (equal x x x))))
(define-fun @quantifiers_skolemize_7 () nat (choice ((x0 nat)) (not (or (not (models (push_nat empty v0_nat x0) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat)))))))
(assume a0 (! (= (! (equal zero zero zero) :named @p_1) true) :named @p_2))
(assume a1 (forall ((y nat) (z nat)) (= (equal zero (s y) z) false)))
(assume a2 (forall ((y nat) (z nat)) (= (equal zero y (s z)) false)))
(assume a3 (forall ((x nat) (z nat)) (= (equal (s x) zero z) false)))
(assume a4 (forall ((x nat) (y nat)) (= (equal (s x) y zero) false)))
(assume a5 (forall ((x nat) (y nat) (z nat)) (= (equal (s x) (s y) (s z)) (equal x y z))))
(assume a6 (forall ((env env) (v var_nat) (x nat)) (= (evalV_nat (push_nat env v x) v) x)))
(assume a7 (forall ((env env) (v var_nat) (w var_nat) (x nat)) (=> (not (= v w)) (= (evalV_nat (push_nat env w x) v) (evalV_nat env v)))))
(assume a8 (forall ((env env) (v var_nat)) (= (eval_nat env (inj_nat v)) (evalV_nat env v))))
(assume a9 (forall ((env env)) (= (eval_nat env zeroR) zero)))
(assume a10 (forall ((env env) (t0 term_nat)) (= (eval_nat env (sR t0)) (s (eval_nat env t0)))))
(assume a11 (forall ((env env) (x term_nat) (y term_nat)) (= (models env (eq_nat x y)) (= (eval_nat env x) (eval_nat env y)))))
(assume a12 (forall ((env env) (t0 term_nat) (t1 term_nat) (t2 term_nat)) (= (models env (equalR t0 t1 t2)) (equal (eval_nat env t0) (eval_nat env t1) (eval_nat env t2)))))
(assume a13 (forall ((env env)) (= (models env falseR) false)))
(assume a14 (forall ((env env) (phi form)) (= (models env (notR phi)) (not (models env phi)))))
(assume a15 (forall ((env env) (phi form) (psi form)) (= (models env (orR phi psi)) (or (models env phi) (models env psi)))))
(assume a16 (forall ((env env) (phi form) (v var_nat)) (= (models env (forallR_nat v phi)) (forall ((x nat)) (models (push_nat env v x) phi)))))
(assume a17 (forall ((phi form)) (=> (and (=> true (models (push_nat empty v0_nat zero) phi)) (forall ((x0 nat)) (=> (models (push_nat empty v0_nat x0) phi) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))))
(assume a18 (forall ((x0 nat)) (not (= zero (s x0)))))
(assume a19 (forall ((x0 nat) (x1 nat)) (=> (= (s x0) (s x1)) (= x0 x1))))
(assume a20 (! (not (forall ((x nat)) (equal x x x))) :named @p_3))
(step t0 (cl (not (! (= (! (or (! (not (! (not (! (equal @quantifiers_skolemize_1 @quantifiers_skolemize_1 @quantifiers_skolemize_1) :named @p_4)) :named @p_5)) :named @p_129) (! (not (! (= @quantifiers_skolemize_1 (! (evalV_nat (! (push_nat empty v0_nat @quantifiers_skolemize_1) :named @p_8) v0_nat) :named @p_117)) :named @p_124)) :named @p_127) (! (not (! (= (! (eval_nat (! (push_nat empty v0_nat @quantifiers_skolemize_1) :named @p_8) (! (inj_nat v0_nat) :named @p_7)) :named @p_9) (! (evalV_nat (! (push_nat empty v0_nat @quantifiers_skolemize_1) :named @p_8) v0_nat) :named @p_117)) :named @p_118)) :named @p_126) (! (not (! (equal @p_9 @p_9 @p_9) :named @p_10)) :named @p_125)) :named @p_130) (! (or @p_4 @p_127 @p_126 @p_125) :named @p_128)) :named @p_139)) (not @p_130) @p_128) :rule equiv_pos2)
(step t1 (cl (! (= @p_129 @p_4) :named @p_140)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_140 1 5))
(step t2 (cl (= @p_127 @p_127)) :rule refl)
(step t3 (cl (= @p_126 @p_126)) :rule refl)
(step t4 (cl (= @p_125 @p_125)) :rule refl)
(step t5 (cl @p_139) :rule cong :premises (t1 t2 t3 t4))
(step t6 (cl (! (=> (! (and @p_5 @p_124 @p_118 @p_10) :named @p_132) false) :named @p_134) @p_132) :rule implies_neg1)
(anchor :step t7)
(assume t7.a0 @p_5)
(assume t7.a1 @p_124)
(assume t7.a2 @p_118)
(assume t7.a3 @p_10)
(step t7.t0 (cl (not (! (= (! (= true false) :named @p_135) false) :named @p_138)) (not @p_135) false) :rule equiv_pos2)
(step t7.t1 (cl @p_138) :rule hole :args ("TRUST_THEORY_REWRITE" @p_138 1 5))
(step t7.t2 (cl (= (! (= @p_10 true) :named @p_137) @p_10)) :rule equiv_simplify)
(step t7.t3 (cl @p_137 @p_125) :rule equiv2 :premises (t7.t2))
(step t7.t4 (cl @p_137) :rule resolution :premises (t7.t3 t7.a3))
(step t7.t5 (cl (= true @p_10)) :rule symm :premises (t7.t4))
(step t7.t6 (cl (not (! (= (! (=> (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v)))) (! (= @p_117 @p_9) :named @p_120)) :named @p_121) (! (=> (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v)))) @p_118) :named @p_119)) :named @p_122)) (not @p_121) @p_119) :rule equiv_pos2)
(step t7.t7 (cl (= (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v)))) (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v)))))) :rule refl)
(step t7.t8 (cl (! (= @p_120 @p_118) :named @p_123)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_123 2 6))
(step t7.t9 (cl @p_122) :rule cong :premises (t7.t7 t7.t8))
(step t7.t10 (cl @p_121 (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule implies_neg1)
(anchor :step t7.t11)
(assume t7.t11.a0 (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v)))))
(step t7.t11.t0 (cl (or (! (not (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :named @p_78) @p_120)) :rule forall_inst :args (@p_8 v0_nat))
(step t7.t11.t1 (cl @p_78 @p_120) :rule or :premises (t7.t11.t0))
(step t7.t11.t2 (cl (not (! (= (forall ((env env) (v var_nat)) (= (eval_nat env (inj_nat v)) (evalV_nat env v))) (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :named @p_74)) (not (forall ((env env) (v var_nat)) (= (eval_nat env (inj_nat v)) (evalV_nat env v)))) (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule equiv_pos2)
(anchor :step t7.t11.t3 :args ((env env) (v var_nat) (:= (env env) env) (:= (v var_nat) v)))
(step t7.t11.t3.t0 (cl (! (= (= (! (eval_nat env (inj_nat v)) :named @p_75) (! (evalV_nat env v) :named @p_76)) (= @p_76 @p_75)) :named @p_77)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_77 2 6))
(step t7.t11.t3 (cl @p_74) :rule bind)
(step t7.t11.t4 (cl (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule resolution :premises (t7.t11.t2 t7.t11.t3 a8))
(step t7.t11.t5 (cl @p_120) :rule resolution :premises (t7.t11.t1 t7.t11.t4))
(step t7.t11 (cl @p_78 @p_120) :rule subproof :discharge (t7.t11.a0))
(step t7.t12 (cl @p_121 @p_120) :rule resolution :premises (t7.t10 t7.t11))
(step t7.t13 (cl @p_121 (not @p_120)) :rule implies_neg2)
(step t7.t14 (cl @p_121 @p_121) :rule resolution :premises (t7.t12 t7.t13))
(step t7.t15 (cl @p_121) :rule contraction :premises (t7.t14))
(step t7.t16 (cl @p_119) :rule resolution :premises (t7.t6 t7.t9 t7.t15))
(step t7.t17 (cl @p_78 @p_118) :rule implies :premises (t7.t16))
(step t7.t18 (cl (not @p_74) (not (forall ((env env) (v var_nat)) (= (eval_nat env (inj_nat v)) (evalV_nat env v)))) (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule equiv_pos2)
(anchor :step t7.t19 :args ((env env) (v var_nat) (:= (env env) env) (:= (v var_nat) v)))
(step t7.t19.t0 (cl @p_77) :rule hole :args ("TRUST_THEORY_REWRITE" @p_77 2 6))
(step t7.t19 (cl @p_74) :rule bind)
(step t7.t20 (cl (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule resolution :premises (t7.t18 t7.t19 a8))
(step t7.t21 (cl @p_118) :rule resolution :premises (t7.t17 t7.t20))
(step t7.t22 (cl (or (! (not (forall ((env env) (v var_nat) (x nat)) (= x (evalV_nat (push_nat env v x) v)))) :named @p_70) @p_124)) :rule forall_inst :args (empty v0_nat @quantifiers_skolemize_1))
(step t7.t23 (cl @p_70 @p_124) :rule or :premises (t7.t22))
(step t7.t24 (cl (not (! (= (forall ((env env) (v var_nat) (x nat)) (= (evalV_nat (push_nat env v x) v) x)) (forall ((env env) (v var_nat) (x nat)) (= x (evalV_nat (push_nat env v x) v)))) :named @p_65)) (not (forall ((env env) (v var_nat) (x nat)) (= (evalV_nat (push_nat env v x) v) x))) (forall ((env env) (v var_nat) (x nat)) (= x (evalV_nat (push_nat env v x) v)))) :rule equiv_pos2)
(anchor :step t7.t25 :args ((env env) (v var_nat) (x nat) (:= (env env) env) (:= (v var_nat) v) (:= (x nat) x)))
(step t7.t25.t0 (cl (! (= (= (! (evalV_nat (push_nat env v x) v) :named @p_68) x) (= x @p_68)) :named @p_69)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_69 2 6))
(step t7.t25 (cl @p_65) :rule bind)
(step t7.t26 (cl (forall ((env env) (v var_nat) (x nat)) (= x (evalV_nat (push_nat env v x) v)))) :rule resolution :premises (t7.t24 t7.t25 a6))
(step t7.t27 (cl @p_124) :rule resolution :premises (t7.t23 t7.t26))
(step t7.t28 (cl (= @p_117 @quantifiers_skolemize_1)) :rule symm :premises (t7.t27))
(step t7.t29 (cl (= @p_9 @quantifiers_skolemize_1)) :rule trans :premises (t7.t21 t7.t28))
(step t7.t30 (cl (= @p_10 @p_4)) :rule cong :premises (t7.t29 t7.t29 t7.t29))
(step t7.t31 (cl (= (! (= @p_4 false) :named @p_136) @p_5)) :rule equiv_simplify)
(step t7.t32 (cl @p_136 @p_129) :rule equiv2 :premises (t7.t31))
(step t7.t33 (cl (! (not @p_129) :named @p_131) @p_4) :rule not_not)
(step t7.t34 (cl @p_136 @p_4) :rule resolution :premises (t7.t32 t7.t33))
(step t7.t35 (cl (not (! (= @p_3 @p_5) :named @p_6)) (not @p_3) @p_5) :rule equiv_pos2)
(anchor :step t7.t36 :args ((:= (x nat) @quantifiers_skolemize_1)))
(step t7.t36.t0 (cl (= (equal x x x) @p_4)) :rule refl)
(step t7.t36 (cl (= (forall ((x nat)) (equal x x x)) @p_4)) :rule sko_forall)
(step t7.t37 (cl @p_6) :rule cong :premises (t7.t36))
(step t7.t38 (cl @p_5) :rule resolution :premises (t7.t35 t7.t37 a20))
(step t7.t39 (cl @p_136) :rule resolution :premises (t7.t34 t7.t38))
(step t7.t40 (cl @p_135) :rule trans :premises (t7.t5 t7.t30 t7.t39))
(step t7.t41 (cl false) :rule resolution :premises (t7.t0 t7.t1 t7.t40))
(step t7 (cl @p_129 @p_127 @p_126 @p_125 false) :rule subproof :discharge (t7.a0 t7.a1 t7.a2 t7.a3))
(step t8 (cl (! (not @p_132) :named @p_133) @p_5) :rule and_pos :args (0))
(step t9 (cl @p_133 @p_124) :rule and_pos :args (1))
(step t10 (cl @p_133 @p_118) :rule and_pos :args (2))
(step t11 (cl @p_133 @p_10) :rule and_pos :args (3))
(step t12 (cl false @p_133 @p_133 @p_133 @p_133) :rule resolution :premises (t7 t8 t9 t10 t11))
(step t13 (cl @p_133 @p_133 @p_133 @p_133 false) :rule reordering :premises (t12))
(step t14 (cl @p_133 false) :rule contraction :premises (t13))
(step t15 (cl @p_134 false) :rule resolution :premises (t6 t14))
(step t16 (cl @p_134 (not false)) :rule implies_neg2)
(step t17 (cl @p_134 @p_134) :rule resolution :premises (t15 t16))
(step t18 (cl @p_134) :rule contraction :premises (t17))
(step t19 (cl (= @p_134 @p_133)) :rule implies_simplify)
(step t20 (cl (not @p_134) @p_133) :rule equiv1 :premises (t19))
(step t21 (cl @p_133) :rule resolution :premises (t18 t20))
(step t22 (cl @p_129 @p_127 @p_126 @p_125) :rule not_and :premises (t21))
(step t23 (cl @p_130 @p_131) :rule or_neg :args (0))
(step t24 (cl @p_130 (not @p_127)) :rule or_neg :args (1))
(step t25 (cl @p_130 (not @p_126)) :rule or_neg :args (2))
(step t26 (cl @p_130 (not @p_125)) :rule or_neg :args (3))
(step t27 (cl @p_130 @p_130 @p_130 @p_130) :rule resolution :premises (t22 t23 t24 t25 t26))
(step t28 (cl @p_130) :rule contraction :premises (t27))
(step t29 (cl @p_128) :rule resolution :premises (t0 t5 t28))
(step t30 (cl @p_4 @p_127 @p_126 @p_125) :rule or :premises (t29))
(step t31 (cl @p_4 @p_125 @p_126 @p_127) :rule reordering :premises (t30))
(step t32 (cl (or @p_70 @p_124)) :rule forall_inst :args (empty v0_nat @quantifiers_skolemize_1))
(step t33 (cl @p_70 @p_124) :rule or :premises (t32))
(step t34 (cl (not @p_65) (not (forall ((env env) (v var_nat) (x nat)) (= (evalV_nat (push_nat env v x) v) x))) (forall ((env env) (v var_nat) (x nat)) (= x (evalV_nat (push_nat env v x) v)))) :rule equiv_pos2)
(anchor :step t35 :args ((env env) (v var_nat) (x nat) (:= (env env) env) (:= (v var_nat) v) (:= (x nat) x)))
(step t35.t0 (cl @p_69) :rule hole :args ("TRUST_THEORY_REWRITE" @p_69 2 6))
(step t35 (cl @p_65) :rule bind)
(step t36 (cl (forall ((env env) (v var_nat) (x nat)) (= x (evalV_nat (push_nat env v x) v)))) :rule resolution :premises (t34 t35 a6))
(step t37 (cl @p_124) :rule resolution :premises (t33 t36))
(step t38 (cl (not @p_122) (not @p_121) @p_119) :rule equiv_pos2)
(step t39 (cl (= (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v)))) (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v)))))) :rule refl)
(step t40 (cl @p_123) :rule hole :args ("TRUST_THEORY_REWRITE" @p_123 2 6))
(step t41 (cl @p_122) :rule cong :premises (t39 t40))
(step t42 (cl @p_121 (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule implies_neg1)
(anchor :step t43)
(assume t43.a0 (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v)))))
(step t43.t0 (cl (or @p_78 @p_120)) :rule forall_inst :args (@p_8 v0_nat))
(step t43.t1 (cl @p_78 @p_120) :rule or :premises (t43.t0))
(step t43.t2 (cl (not @p_74) (not (forall ((env env) (v var_nat)) (= (eval_nat env (inj_nat v)) (evalV_nat env v)))) (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule equiv_pos2)
(anchor :step t43.t3 :args ((env env) (v var_nat) (:= (env env) env) (:= (v var_nat) v)))
(step t43.t3.t0 (cl @p_77) :rule hole :args ("TRUST_THEORY_REWRITE" @p_77 2 6))
(step t43.t3 (cl @p_74) :rule bind)
(step t43.t4 (cl (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule resolution :premises (t43.t2 t43.t3 a8))
(step t43.t5 (cl @p_120) :rule resolution :premises (t43.t1 t43.t4))
(step t43 (cl @p_78 @p_120) :rule subproof :discharge (t43.a0))
(step t44 (cl @p_121 @p_120) :rule resolution :premises (t42 t43))
(step t45 (cl @p_121 (not @p_120)) :rule implies_neg2)
(step t46 (cl @p_121 @p_121) :rule resolution :premises (t44 t45))
(step t47 (cl @p_121) :rule contraction :premises (t46))
(step t48 (cl @p_119) :rule resolution :premises (t38 t41 t47))
(step t49 (cl @p_78 @p_118) :rule implies :premises (t48))
(step t50 (cl (not @p_74) (not (forall ((env env) (v var_nat)) (= (eval_nat env (inj_nat v)) (evalV_nat env v)))) (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule equiv_pos2)
(anchor :step t51 :args ((env env) (v var_nat) (:= (env env) env) (:= (v var_nat) v)))
(step t51.t0 (cl @p_77) :rule hole :args ("TRUST_THEORY_REWRITE" @p_77 2 6))
(step t51 (cl @p_74) :rule bind)
(step t52 (cl (forall ((env env) (v var_nat)) (= (evalV_nat env v) (eval_nat env (inj_nat v))))) :rule resolution :premises (t50 t51 a8))
(step t53 (cl @p_118) :rule resolution :premises (t49 t52))
(step t54 (cl (! (not (! (= (! (models @p_8 (! (equalR @p_7 @p_7 @p_7) :named @p_11)) :named @p_12) @p_10) :named @p_13)) :named @p_116) (! (not @p_12) :named @p_115) @p_10) :rule equiv_pos2)
(step t55 (cl @p_115 @p_10 @p_116) :rule reordering :premises (t54))
(step t56 (cl (! (not (! (or (! (not (! (models (! (push_nat empty v0_nat zero) :named @p_16) @p_11) :named @p_17)) :named @p_18) (! (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat)))))) :named @p_15) @p_12) :named @p_19)) :named @p_114) @p_18 @p_15 @p_12) :rule or_pos)
(step t57 (cl @p_18 @p_15 @p_12 @p_114) :rule reordering :premises (t56))
(step t58 (cl (! (not (! (= @p_17 (! (equal (! (eval_nat @p_16 @p_7) :named @p_105) @p_105 @p_105) :named @p_106)) :named @p_107)) :named @p_113) @p_17 (! (not @p_106) :named @p_112)) :rule equiv_pos1)
(step t59 (cl @p_17 @p_112 @p_113) :rule reordering :premises (t58))
(step t60 (cl (= (! (= @p_106 true) :named @p_108) @p_106)) :rule equiv_simplify)
(step t61 (cl (not @p_108) @p_106) :rule equiv1 :premises (t60))
(step t62 (cl (or @p_78 (! (= (! (evalV_nat @p_16 v0_nat) :named @p_109) @p_105) :named @p_111))) :rule forall_inst :args (@p_16 v0_nat))
(step t63 (cl @p_78 @p_111) :rule or :premises (t62))
(step t64 (cl @p_111) :rule resolution :premises (t63 t52))
(step t65 (cl (= @p_105 @p_109)) :rule symm :premises (t64))
(step t66 (cl (or @p_70 (! (= zero @p_109) :named @p_110))) :rule forall_inst :args (empty v0_nat zero))
(step t67 (cl @p_70 @p_110) :rule or :premises (t66))
(step t68 (cl @p_110) :rule resolution :premises (t67 t36))
(step t69 (cl (= @p_109 zero)) :rule symm :premises (t68))
(step t70 (cl (= @p_105 zero)) :rule trans :premises (t65 t69))
(step t71 (cl (= @p_106 @p_1)) :rule cong :premises (t70 t70 t70))
(step t72 (cl @p_108) :rule trans :premises (t71 a0))
(step t73 (cl @p_106) :rule resolution :premises (t61 t72))
(step t74 (cl (or (! (not (forall ((env env) (t0 term_nat) (t1 term_nat) (t2 term_nat)) (= (models env (equalR t0 t1 t2)) (equal (eval_nat env t0) (eval_nat env t1) (eval_nat env t2))))) :named @p_14) @p_107)) :rule forall_inst :args (@p_16 @p_7 @p_7 @p_7))
(step t75 (cl @p_14 @p_107) :rule or :premises (t74))
(step t76 (cl @p_107) :rule resolution :premises (t75 a12))
(step t77 (cl @p_17) :rule resolution :premises (t59 t73 t76))
(step t78 (cl (not (! (= (! (or (! (not @p_15) :named @p_98) (! (not (! (or (! (not (! (models (! (push_nat empty v0_nat @quantifiers_skolemize_7) :named @p_33) @p_11) :named @p_34)) :named @p_35) (! (models (! (push_nat empty v0_nat (! (s @quantifiers_skolemize_7) :named @p_30)) :named @p_31) @p_11) :named @p_32)) :named @p_36)) :named @p_40)) :named @p_99) (! (or (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat))))) @p_40) :named @p_97)) :named @p_103)) (not @p_99) @p_97) :rule equiv_pos2)
(step t79 (cl (! (= @p_98 (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat)))))) :named @p_104)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_104 1 5))
(step t80 (cl (= @p_40 @p_40)) :rule refl)
(step t81 (cl @p_103) :rule cong :premises (t79 t80))
(step t82 (cl (! (=> @p_15 @p_40) :named @p_101) @p_15) :rule implies_neg1)
(anchor :step t83)
(assume t83.a0 @p_15)
(step t83.t0 (cl (not (! (= @p_15 @p_40) :named @p_102)) @p_98 @p_40) :rule equiv_pos2)
(anchor :step t83.t1 :args ((:= (x0 nat) @quantifiers_skolemize_7)))
(step t83.t1.t0 (cl (= (or (not (models (push_nat empty v0_nat x0) @p_11)) (models (push_nat empty v0_nat (s x0)) @p_11)) @p_36)) :rule refl)
(step t83.t1 (cl (= (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat))))) @p_36)) :rule sko_forall)
(step t83.t2 (cl @p_102) :rule cong :premises (t83.t1))
(step t83.t3 (cl @p_40) :rule resolution :premises (t83.t0 t83.t2 t83.a0))
(step t83 (cl @p_98 @p_40) :rule subproof :discharge (t83.a0))
(step t84 (cl @p_101 @p_40) :rule resolution :premises (t82 t83))
(step t85 (cl @p_101 (! (not @p_40) :named @p_100)) :rule implies_neg2)
(step t86 (cl @p_101 @p_101) :rule resolution :premises (t84 t85))
(step t87 (cl @p_101) :rule contraction :premises (t86))
(step t88 (cl @p_98 @p_40) :rule implies :premises (t87))
(step t89 (cl @p_99 (not @p_98)) :rule or_neg :args (0))
(step t90 (cl @p_99 @p_100) :rule or_neg :args (1))
(step t91 (cl @p_99 @p_99) :rule resolution :premises (t88 t89 t90))
(step t92 (cl @p_99) :rule contraction :premises (t91))
(step t93 (cl @p_97) :rule resolution :premises (t78 t81 t92))
(step t94 (cl (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat))))) @p_40) :rule or :premises (t93))
(step t95 (cl (not (! (= (! (or (! (not (! (not (! (equal (! (eval_nat @p_31 @p_7) :named @p_47) @p_47 @p_47) :named @p_48)) :named @p_50)) :named @p_86) (! (not (! (= (! (evalV_nat @p_31 v0_nat) :named @p_71) @p_47) :named @p_79)) :named @p_83) (! (not (! (= @p_30 @p_71) :named @p_72)) :named @p_81) (! (not (! (= @quantifiers_skolemize_7 (! (evalV_nat @p_33 v0_nat) :named @p_63)) :named @p_64)) :named @p_80) (! (not (! (= @p_63 (! (eval_nat @p_33 @p_7) :named @p_43)) :named @p_73)) :named @p_82) (! (not (! (equal (! (s @p_43) :named @p_52) @p_52 @p_52) :named @p_53)) :named @p_84)) :named @p_87) (! (or @p_48 @p_83 @p_81 @p_80 @p_82 @p_84) :named @p_85)) :named @p_95)) (not @p_87) @p_85) :rule equiv_pos2)
(step t96 (cl (! (= @p_86 @p_48) :named @p_96)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_96 1 5))
(step t97 (cl (= @p_83 @p_83)) :rule refl)
(step t98 (cl (= @p_81 @p_81)) :rule refl)
(step t99 (cl (= @p_80 @p_80)) :rule refl)
(step t100 (cl (= @p_82 @p_82)) :rule refl)
(step t101 (cl (= @p_84 @p_84)) :rule refl)
(step t102 (cl @p_95) :rule cong :premises (t96 t97 t98 t99 t100 t101))
(step t103 (cl (! (and @p_50 @p_79 @p_72 @p_64 @p_73) :named @p_90) @p_86 @p_83 @p_81 @p_80 @p_82) :rule and_neg)
(step t104 (cl (! (=> @p_90 @p_84) :named @p_92) @p_90) :rule implies_neg1)
(anchor :step t105)
(assume t105.a0 @p_50)
(assume t105.a1 @p_79)
(assume t105.a2 @p_72)
(assume t105.a3 @p_64)
(assume t105.a4 @p_73)
(step t105.t0 (cl (= (! (= @p_53 false) :named @p_93) @p_84)) :rule equiv_simplify)
(step t105.t1 (cl (not @p_93) @p_84) :rule equiv1 :premises (t105.t0))
(step t105.t2 (cl (or @p_78 @p_73)) :rule forall_inst :args (@p_33 v0_nat))
(step t105.t3 (cl @p_78 @p_73) :rule or :premises (t105.t2))
(step t105.t4 (cl @p_73) :rule resolution :premises (t105.t3 t52))
(step t105.t5 (cl (= @p_43 @p_63)) :rule symm :premises (t105.t4))
(step t105.t6 (cl (or @p_70 @p_64)) :rule forall_inst :args (empty v0_nat @quantifiers_skolemize_7))
(step t105.t7 (cl @p_70 @p_64) :rule or :premises (t105.t6))
(step t105.t8 (cl @p_64) :rule resolution :premises (t105.t7 t36))
(step t105.t9 (cl (= @p_63 @quantifiers_skolemize_7)) :rule symm :premises (t105.t8))
(step t105.t10 (cl (= @p_43 @quantifiers_skolemize_7)) :rule trans :premises (t105.t5 t105.t9))
(step t105.t11 (cl (= @p_52 @p_30)) :rule cong :premises (t105.t10))
(step t105.t12 (cl (or @p_70 @p_72)) :rule forall_inst :args (empty v0_nat @p_30))
(step t105.t13 (cl @p_70 @p_72) :rule or :premises (t105.t12))
(step t105.t14 (cl @p_72) :rule resolution :premises (t105.t13 t36))
(step t105.t15 (cl (or @p_78 @p_79)) :rule forall_inst :args (@p_31 v0_nat))
(step t105.t16 (cl @p_78 @p_79) :rule or :premises (t105.t15))
(step t105.t17 (cl @p_79) :rule resolution :premises (t105.t16 t52))
(step t105.t18 (cl (= @p_52 @p_47)) :rule trans :premises (t105.t11 t105.t14 t105.t17))
(step t105.t19 (cl (= @p_53 @p_48)) :rule cong :premises (t105.t18 t105.t18 t105.t18))
(step t105.t20 (cl (= (! (= @p_48 false) :named @p_94) @p_50)) :rule equiv_simplify)
(step t105.t21 (cl @p_94 @p_86) :rule equiv2 :premises (t105.t20))
(step t105.t22 (cl (! (not @p_86) :named @p_89) @p_48) :rule not_not)
(step t105.t23 (cl @p_94 @p_48) :rule resolution :premises (t105.t21 t105.t22))
(step t105.t24 (cl @p_94) :rule resolution :premises (t105.t23 t105.a0))
(step t105.t25 (cl @p_93) :rule trans :premises (t105.t19 t105.t24))
(step t105.t26 (cl @p_84) :rule resolution :premises (t105.t1 t105.t25))
(step t105 (cl @p_86 @p_83 @p_81 @p_80 @p_82 @p_84) :rule subproof :discharge (t105.a0 t105.a1 t105.a2 t105.a3 t105.a4))
(step t106 (cl (! (not @p_90) :named @p_91) @p_50) :rule and_pos :args (0))
(step t107 (cl @p_91 @p_79) :rule and_pos :args (1))
(step t108 (cl @p_91 @p_72) :rule and_pos :args (2))
(step t109 (cl @p_91 @p_64) :rule and_pos :args (3))
(step t110 (cl @p_91 @p_73) :rule and_pos :args (4))
(step t111 (cl @p_84 @p_91 @p_91 @p_91 @p_91 @p_91) :rule resolution :premises (t105 t106 t107 t108 t109 t110))
(step t112 (cl @p_91 @p_91 @p_91 @p_91 @p_91 @p_84) :rule reordering :premises (t111))
(step t113 (cl @p_91 @p_84) :rule contraction :premises (t112))
(step t114 (cl @p_92 @p_84) :rule resolution :premises (t104 t113))
(step t115 (cl @p_92 (! (not @p_84) :named @p_88)) :rule implies_neg2)
(step t116 (cl @p_92 @p_92) :rule resolution :premises (t114 t115))
(step t117 (cl @p_92) :rule contraction :premises (t116))
(step t118 (cl @p_91 @p_84) :rule implies :premises (t117))
(step t119 (cl @p_86 @p_83 @p_81 @p_80 @p_82 @p_84) :rule resolution :premises (t103 t118))
(step t120 (cl @p_87 @p_89) :rule or_neg :args (0))
(step t121 (cl @p_87 (not @p_83)) :rule or_neg :args (1))
(step t122 (cl @p_87 (not @p_81)) :rule or_neg :args (2))
(step t123 (cl @p_87 (not @p_80)) :rule or_neg :args (3))
(step t124 (cl @p_87 (not @p_82)) :rule or_neg :args (4))
(step t125 (cl @p_87 @p_88) :rule or_neg :args (5))
(step t126 (cl @p_87 @p_87 @p_87 @p_87 @p_87 @p_87) :rule resolution :premises (t119 t120 t121 t122 t123 t124 t125))
(step t127 (cl @p_87) :rule contraction :premises (t126))
(step t128 (cl @p_85) :rule resolution :premises (t95 t102 t127))
(step t129 (cl @p_48 @p_83 @p_81 @p_80 @p_82 @p_84) :rule or :premises (t128))
(step t130 (cl @p_48 @p_80 @p_81 @p_82 @p_83 @p_84) :rule reordering :premises (t129))
(step t131 (cl (or @p_78 @p_79)) :rule forall_inst :args (@p_31 v0_nat))
(step t132 (cl @p_78 @p_79) :rule or :premises (t131))
(step t133 (cl @p_79) :rule resolution :premises (t132 t52))
(step t134 (cl (or @p_78 @p_73)) :rule forall_inst :args (@p_33 v0_nat))
(step t135 (cl @p_78 @p_73) :rule or :premises (t134))
(step t136 (cl @p_73) :rule resolution :premises (t135 t52))
(step t137 (cl (or @p_70 @p_72)) :rule forall_inst :args (empty v0_nat @p_30))
(step t138 (cl @p_70 @p_72) :rule or :premises (t137))
(step t139 (cl @p_72) :rule resolution :premises (t138 t36))
(step t140 (cl (or @p_70 @p_64)) :rule forall_inst :args (empty v0_nat @quantifiers_skolemize_7))
(step t141 (cl @p_70 @p_64) :rule or :premises (t140))
(step t142 (cl @p_64) :rule resolution :premises (t141 t36))
(step t143 (cl (! (not (! (= (! (equal @p_43 @p_43 @p_43) :named @p_44) @p_53) :named @p_54)) :named @p_62) (! (not @p_44) :named @p_61) @p_53) :rule equiv_pos2)
(step t144 (cl @p_61 @p_53 @p_62) :rule reordering :premises (t143))
(step t145 (cl (not (! (= (! (=> (forall ((x nat) (y nat) (z nat)) (= (equal (s x) (s y) (s z)) (equal x y z))) (! (= @p_53 @p_44) :named @p_57)) :named @p_58) (! (=> (forall ((x nat) (y nat) (z nat)) (= (equal (s x) (s y) (s z)) (equal x y z))) @p_54) :named @p_56)) :named @p_59)) (not @p_58) @p_56) :rule equiv_pos2)
(step t146 (cl (= (forall ((x nat) (y nat) (z nat)) (= (equal (s x) (s y) (s z)) (equal x y z))) (forall ((x nat) (y nat) (z nat)) (= (equal (s x) (s y) (s z)) (equal x y z))))) :rule refl)
(step t147 (cl (! (= @p_57 @p_54) :named @p_60)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_60 1 5))
(step t148 (cl @p_59) :rule cong :premises (t146 t147))
(step t149 (cl @p_58 (forall ((x nat) (y nat) (z nat)) (= (equal (s x) (s y) (s z)) (equal x y z)))) :rule implies_neg1)
(anchor :step t150)
(assume t150.a0 (forall ((x nat) (y nat) (z nat)) (= (equal (s x) (s y) (s z)) (equal x y z))))
(step t150.t0 (cl (or (! (not (forall ((x nat) (y nat) (z nat)) (= (equal (s x) (s y) (s z)) (equal x y z)))) :named @p_55) @p_57)) :rule forall_inst :args (@p_43 @p_43 @p_43))
(step t150.t1 (cl @p_55 @p_57) :rule or :premises (t150.t0))
(step t150.t2 (cl @p_57) :rule resolution :premises (t150.t1 t150.a0))
(step t150 (cl @p_55 @p_57) :rule subproof :discharge (t150.a0))
(step t151 (cl @p_58 @p_57) :rule resolution :premises (t149 t150))
(step t152 (cl @p_58 (not @p_57)) :rule implies_neg2)
(step t153 (cl @p_58 @p_58) :rule resolution :premises (t151 t152))
(step t154 (cl @p_58) :rule contraction :premises (t153))
(step t155 (cl @p_56) :rule resolution :premises (t145 t148 t154))
(step t156 (cl @p_55 @p_54) :rule implies :premises (t155))
(step t157 (cl @p_54) :rule resolution :premises (t156 a5))
(step t158 (cl (! (not (! (= @p_32 @p_48) :named @p_49)) :named @p_51) @p_32 @p_50) :rule equiv_pos1)
(step t159 (cl @p_32 @p_50 @p_51) :rule reordering :premises (t158))
(step t160 (cl (or @p_14 @p_49)) :rule forall_inst :args (@p_31 @p_7 @p_7 @p_7))
(step t161 (cl @p_14 @p_49) :rule or :premises (t160))
(step t162 (cl @p_49) :rule resolution :premises (t161 a12))
(step t163 (cl (! (not (! (= @p_34 @p_44) :named @p_45)) :named @p_46) @p_35 @p_44) :rule equiv_pos2)
(step t164 (cl @p_35 @p_44 @p_46) :rule reordering :premises (t163))
(step t165 (cl (or @p_14 @p_45)) :rule forall_inst :args (@p_33 @p_7 @p_7 @p_7))
(step t166 (cl @p_14 @p_45) :rule or :premises (t165))
(step t167 (cl @p_45) :rule resolution :premises (t166 a12))
(step t168 (cl @p_36 (not @p_32)) :rule or_neg :args (1))
(step t169 (cl (not (! (= (! (or @p_36 (! (not @p_35) :named @p_38)) :named @p_39) (! (or @p_36 @p_34) :named @p_37)) :named @p_41)) (not @p_39) @p_37) :rule equiv_pos2)
(step t170 (cl (= @p_36 @p_36)) :rule refl)
(step t171 (cl (! (= @p_38 @p_34) :named @p_42)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_42 1 5))
(step t172 (cl @p_41) :rule cong :premises (t170 t171))
(step t173 (cl @p_36 @p_38) :rule or_neg :args (0))
(step t174 (cl @p_39 @p_40) :rule or_neg :args (0))
(step t175 (cl @p_39 (not @p_38)) :rule or_neg :args (1))
(step t176 (cl @p_39 @p_39) :rule resolution :premises (t173 t174 t175))
(step t177 (cl @p_39) :rule contraction :premises (t176))
(step t178 (cl @p_37) :rule resolution :premises (t169 t172 t177))
(step t179 (cl @p_36 @p_34) :rule or :premises (t178))
(step t180 (cl @p_34 @p_36) :rule reordering :premises (t179))
(step t181 (cl @p_36) :rule resolution :premises (t130 t133 t136 t139 t142 t144 t157 t159 t162 t164 t167 t168 t180))
(step t182 (cl (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat)))) (models (push_nat empty v0_nat (s x0)) (equalR (inj_nat v0_nat) (inj_nat v0_nat) (inj_nat v0_nat)))))) :rule resolution :premises (t94 t181))
(step t183 (cl (or (! (not (forall ((phi form) (BOUND_VARIABLE_560 nat)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (models (push_nat empty v0_nat BOUND_VARIABLE_560) phi)))) :named @p_29) @p_19)) :rule forall_inst :args (@p_11 @quantifiers_skolemize_1))
(step t184 (cl @p_29 @p_19) :rule or :premises (t183))
(step t185 (cl (not (! (= (forall ((phi form)) (=> (and (=> true (models (push_nat empty v0_nat zero) phi)) (forall ((x0 nat)) (=> (models (push_nat empty v0_nat x0) phi) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))) (forall ((phi form) (BOUND_VARIABLE_560 nat)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (models (push_nat empty v0_nat BOUND_VARIABLE_560) phi)))) :named @p_20)) (not (forall ((phi form)) (=> (and (=> true (models (push_nat empty v0_nat zero) phi)) (forall ((x0 nat)) (=> (models (push_nat empty v0_nat x0) phi) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi))))) (forall ((phi form) (BOUND_VARIABLE_560 nat)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (models (push_nat empty v0_nat BOUND_VARIABLE_560) phi)))) :rule equiv_pos2)
(anchor :step t186 :args ((phi form) (:= (phi form) phi)))
(step t186.t0 (cl (! (= (! (=> true (! (models @p_16 phi) :named @p_23)) :named @p_25) (! (models @p_16 phi) :named @p_23)) :named @p_28)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_28 1 5))
(step t186.t1 (cl (! (= (forall ((x0 nat)) (=> (models (push_nat empty v0_nat x0) phi) (models (push_nat empty v0_nat (s x0)) phi))) (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) :named @p_27)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_27 13 6))
(step t186.t2 (cl (= (! (and @p_25 (forall ((x0 nat)) (=> (models (push_nat empty v0_nat x0) phi) (models (push_nat empty v0_nat (s x0)) phi)))) :named @p_26) (! (and @p_23 (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) :named @p_24))) :rule cong :premises (t186.t0 t186.t1))
(step t186.t3 (cl (= (forall ((x nat)) (models (push_nat empty v0_nat x) phi)) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))) :rule refl)
(step t186.t4 (cl (= (=> @p_26 (forall ((x nat)) (models (push_nat empty v0_nat x) phi))) (=> @p_24 (forall ((x nat)) (models (push_nat empty v0_nat x) phi))))) :rule cong :premises (t186.t2 t186.t3))
(step t186 (cl (= (forall ((phi form)) (=> (and (=> true (models (push_nat empty v0_nat zero) phi)) (forall ((x0 nat)) (=> (models (push_nat empty v0_nat x0) phi) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))) (forall ((phi form)) (=> (and (models (push_nat empty v0_nat zero) phi) (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))))) :rule bind)
(step t187 (cl (! (= (forall ((phi form)) (=> (and (models (push_nat empty v0_nat zero) phi) (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))) (forall ((phi form)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi))))) :named @p_22)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_22 13 6))
(step t188 (cl (! (= (forall ((phi form)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))) (forall ((phi form) (BOUND_VARIABLE_560 nat)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (models (push_nat empty v0_nat BOUND_VARIABLE_560) phi)))) :named @p_21)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_21 13 6))
(step t189 (cl (= (forall ((phi form)) (=> (and (models (push_nat empty v0_nat zero) phi) (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (forall ((x nat)) (models (push_nat empty v0_nat x) phi)))) (forall ((phi form) (BOUND_VARIABLE_560 nat)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (models (push_nat empty v0_nat BOUND_VARIABLE_560) phi))))) :rule trans :premises (t187 t188))
(step t190 (cl @p_20) :rule trans :premises (t186 t189))
(step t191 (cl (forall ((phi form) (BOUND_VARIABLE_560 nat)) (or (not (models (push_nat empty v0_nat zero) phi)) (not (forall ((x0 nat)) (or (not (models (push_nat empty v0_nat x0) phi)) (models (push_nat empty v0_nat (s x0)) phi)))) (models (push_nat empty v0_nat BOUND_VARIABLE_560) phi)))) :rule resolution :premises (t185 t190 a17))
(step t192 (cl @p_19) :rule resolution :premises (t184 t191))
(step t193 (cl @p_12) :rule resolution :premises (t57 t77 t182 t192))
(step t194 (cl (or @p_14 @p_13)) :rule forall_inst :args (@p_8 @p_7 @p_7 @p_7))
(step t195 (cl @p_14 @p_13) :rule or :premises (t194))
(step t196 (cl @p_13) :rule resolution :premises (t195 a12))
(step t197 (cl @p_10) :rule resolution :premises (t55 t193 t196))
(step t198 (cl (not @p_6) (not @p_3) @p_5) :rule equiv_pos2)
(anchor :step t199 :args ((:= (x nat) @quantifiers_skolemize_1)))
(step t199.t0 (cl (= (equal x x x) @p_4)) :rule refl)
(step t199 (cl (= (forall ((x nat)) (equal x x x)) @p_4)) :rule sko_forall)
(step t200 (cl @p_6) :rule cong :premises (t199))
(step t201 (cl @p_5) :rule resolution :premises (t198 t200 a20))
(step t202 (cl) :rule resolution :premises (t31 t37 t53 t197 t201))
