unsat
(define-fun @quantifiers_skolemize_3 () alpha (choice ((x alpha)) (not (models (push_alpha empty v0_alpha x) (eq_alpha (inj_alpha v0_alpha) (inj_alpha v0_alpha))))))
(assume a0 (forall ((env env) (v var_alpha) (x alpha)) (= (evalV_alpha (push_alpha env v x) v) x)))
(assume a1 (forall ((env env) (v var_alpha) (w var_alpha) (x alpha)) (=> (not (= v w)) (= (evalV_alpha (push_alpha env w x) v) (evalV_alpha env v)))))
(assume a2 (forall ((env env) (v var_alpha)) (= (eval_alpha env (inj_alpha v)) (evalV_alpha env v))))
(assume a3 (forall ((env env)) (= (eval_alpha env aR) a)))
(assume a4 (forall ((env env)) (= (eval_alpha env bR) b)))
(assume a5 (forall ((env env)) (= (eval_alpha env cR) c)))
(assume a6 (forall ((env env) (x term_alpha) (y term_alpha)) (= (models env (eq_alpha x y)) (= (eval_alpha env x) (eval_alpha env y)))))
(assume a7 (forall ((env env) (t0 term_alpha)) (= (models env (pR t0)) (p (eval_alpha env t0)))))
(assume a8 (forall ((env env) (t0 term_alpha)) (= (models env (qR t0)) (q (eval_alpha env t0)))))
(assume a9 (forall ((env env) (t0 term_alpha)) (= (models env (rR t0)) (r (eval_alpha env t0)))))
(assume a10 (forall ((env env)) (= (models env falseR) false)))
(assume a11 (forall ((env env) (phi form)) (= (models env (notR phi)) (not (models env phi)))))
(assume a12 (forall ((env env) (phi form) (psi form)) (= (models env (orR phi psi)) (or (models env phi) (models env psi)))))
(assume a13 (forall ((env env) (phi form) (v var_alpha)) (= (models env (forallR_alpha v phi)) (forall ((x alpha)) (models (push_alpha env v x) phi)))))
(assume a14 (! (not (! (models empty (forallR_alpha v0_alpha (! (eq_alpha (! (inj_alpha v0_alpha) :named @p_1) @p_1) :named @p_2))) :named @p_3)) :named @p_4))
(step t0 (cl (not (! (= (! (=> (forall ((env env) (x term_alpha) (y term_alpha)) (= (models env (eq_alpha x y)) (= (eval_alpha env x) (eval_alpha env y)))) (! (= (! (models (! (push_alpha empty v0_alpha @quantifiers_skolemize_3) :named @p_5) @p_2) :named @p_6) (! (= (! (eval_alpha @p_5 @p_1) :named @p_15) @p_15) :named @p_16)) :named @p_17)) :named @p_18) (! (=> (forall ((env env) (x term_alpha) (y term_alpha)) (= (models env (eq_alpha x y)) (= (eval_alpha env x) (eval_alpha env y)))) @p_6) :named @p_14)) :named @p_19)) (not @p_18) @p_14) :rule equiv_pos2)
(step t1 (cl (= (forall ((env env) (x term_alpha) (y term_alpha)) (= (models env (eq_alpha x y)) (= (eval_alpha env x) (eval_alpha env y)))) (forall ((env env) (x term_alpha) (y term_alpha)) (= (models env (eq_alpha x y)) (= (eval_alpha env x) (eval_alpha env y)))))) :rule refl)
(step t2 (cl (= @p_6 @p_6)) :rule refl)
(step t3 (cl (! (= @p_16 true) :named @p_22)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_22 2 5))
(step t4 (cl (= @p_17 (! (= @p_6 true) :named @p_20))) :rule cong :premises (t2 t3))
(step t5 (cl (! (= @p_20 @p_6) :named @p_21)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_21 1 6))
(step t6 (cl (= @p_17 @p_6)) :rule trans :premises (t4 t5))
(step t7 (cl @p_19) :rule cong :premises (t1 t6))
(step t8 (cl @p_18 (forall ((env env) (x term_alpha) (y term_alpha)) (= (models env (eq_alpha x y)) (= (eval_alpha env x) (eval_alpha env y))))) :rule implies_neg1)
(anchor :step t9)
(assume t9.a0 (forall ((env env) (x term_alpha) (y term_alpha)) (= (models env (eq_alpha x y)) (= (eval_alpha env x) (eval_alpha env y)))))
(step t9.t0 (cl (or (! (not (forall ((env env) (x term_alpha) (y term_alpha)) (= (models env (eq_alpha x y)) (= (eval_alpha env x) (eval_alpha env y))))) :named @p_13) @p_17)) :rule forall_inst :args (@p_5 @p_1 @p_1))
(step t9.t1 (cl @p_13 @p_17) :rule or :premises (t9.t0))
(step t9.t2 (cl @p_17) :rule resolution :premises (t9.t1 t9.a0))
(step t9 (cl @p_13 @p_17) :rule subproof :discharge (t9.a0))
(step t10 (cl @p_18 @p_17) :rule resolution :premises (t8 t9))
(step t11 (cl @p_18 (not @p_17)) :rule implies_neg2)
(step t12 (cl @p_18 @p_18) :rule resolution :premises (t10 t11))
(step t13 (cl @p_18) :rule contraction :premises (t12))
(step t14 (cl @p_14) :rule resolution :premises (t0 t7 t13))
(step t15 (cl @p_13 @p_6) :rule implies :premises (t14))
(step t16 (cl (not (! (= (! (not (forall ((x alpha)) (models (push_alpha empty v0_alpha x) (eq_alpha (inj_alpha v0_alpha) (inj_alpha v0_alpha))))) :named @p_8) (! (not @p_6) :named @p_7)) :named @p_12)) (not @p_8) @p_7) :rule equiv_pos2)
(anchor :step t17 :args ((:= (x alpha) @quantifiers_skolemize_3)))
(step t17.t0 (cl (= (models (push_alpha empty v0_alpha x) @p_2) @p_6)) :rule refl)
(step t17 (cl (= (forall ((x alpha)) (models (push_alpha empty v0_alpha x) (eq_alpha (inj_alpha v0_alpha) (inj_alpha v0_alpha)))) @p_6)) :rule sko_forall)
(step t18 (cl @p_12) :rule cong :premises (t17))
(step t19 (cl (! (not (! (= @p_3 (forall ((x alpha)) (models (push_alpha empty v0_alpha x) (eq_alpha (inj_alpha v0_alpha) (inj_alpha v0_alpha))))) :named @p_9)) :named @p_11) @p_3 @p_8) :rule equiv_pos1)
(step t20 (cl @p_3 @p_8 @p_11) :rule reordering :premises (t19))
(step t21 (cl (or (! (not (forall ((env env) (phi form) (v var_alpha)) (= (models env (forallR_alpha v phi)) (forall ((x alpha)) (models (push_alpha env v x) phi))))) :named @p_10) @p_9)) :rule forall_inst :args (empty @p_2 v0_alpha))
(step t22 (cl @p_10 @p_9) :rule or :premises (t21))
(step t23 (cl @p_9) :rule resolution :premises (t22 a13))
(step t24 (cl @p_8) :rule resolution :premises (t20 a14 t23))
(step t25 (cl @p_7) :rule resolution :premises (t16 t18 t24))
(step t26 (cl) :rule resolution :premises (t15 t25 a6))
