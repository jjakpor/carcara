unsat
(assume a0 (forall ((env env) (v var_alpha) (x alpha)) (= (evalV_alpha (push_alpha env v x) v) x)))
(assume a1 (forall ((env env) (v var_alpha) (w var_alpha) (x alpha)) (=> (not (= v w)) (= (evalV_alpha (push_alpha env w x) v) (evalV_alpha env v)))))
(assume a2 (forall ((env env) (v var_alpha)) (= (eval_alpha env (inj_alpha v)) (evalV_alpha env v))))
(assume a3 (forall ((env env)) (= (eval_alpha env aR) a)))
(assume a4 (forall ((env env)) (= (eval_alpha env bR) b)))
(assume a5 (forall ((env env)) (= (eval_alpha env cR) c)))
(assume a6 (forall ((env env) (x term_alpha) (y term_alpha)) (= (models env (eq_alpha x y)) (= (eval_alpha env x) (eval_alpha env y)))))
(assume a7 (forall ((env env) (t0 term_alpha)) (= (models env (pR t0)) (p (eval_alpha env t0)))))
(assume a8 (forall ((env env) (t0 term_alpha)) (= (models env (qR t0)) (q (eval_alpha env t0)))))
(assume a9 (forall ((env env) (t0 term_alpha)) (= (models env (rR t0)) (r (eval_alpha env t0)))))
(assume a10 (forall ((env env)) (= (models env falseR) false)))
(assume a11 (forall ((env env) (phi form)) (= (models env (notR phi)) (not (models env phi)))))
(assume a12 (forall ((env env) (phi form) (psi form)) (= (models env (orR phi psi)) (or (models env phi) (models env psi)))))
(assume a13 (forall ((env env) (phi form) (v var_alpha)) (= (models env (forallR_alpha v phi)) (forall ((x alpha)) (models (push_alpha env v x) phi)))))
(assume a14 (! (not (! (models empty (orR (! (notR (! (forallR_alpha v0_alpha (! (pR (! (inj_alpha v0_alpha) :named @p_2)) :named @p_3)) :named @p_4)) :named @p_5) (! (pR aR) :named @p_1))) :named @p_6)) :named @p_7))
(step t0 (cl (not (! (= (! (or (! (not (! (not (! (p (! (eval_alpha empty aR) :named @p_8)) :named @p_9)) :named @p_10)) :named @p_62) (! (not (! (= (! (eval_alpha empty aR) :named @p_8) (! (evalV_alpha (! (push_alpha empty v0_alpha @p_8) :named @p_22) v0_alpha) :named @p_23)) :named @p_24)) :named @p_58) (! (not (! (= @p_23 (! (eval_alpha @p_22 @p_2) :named @p_31)) :named @p_32)) :named @p_59) (! (not (! (p @p_31) :named @p_38)) :named @p_60)) :named @p_63) (! (or @p_9 @p_58 @p_59 @p_60) :named @p_61)) :named @p_71)) (not @p_63) @p_61) :rule equiv_pos2)
(step t1 (cl (! (= @p_62 @p_9) :named @p_72)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_72 1 5))
(step t2 (cl (= @p_58 @p_58)) :rule refl)
(step t3 (cl (= @p_59 @p_59)) :rule refl)
(step t4 (cl (= @p_60 @p_60)) :rule refl)
(step t5 (cl @p_71) :rule cong :premises (t1 t2 t3 t4))
(step t6 (cl (! (and @p_10 @p_24 @p_32) :named @p_66) @p_62 @p_58 @p_59) :rule and_neg)
(step t7 (cl (! (=> @p_66 @p_60) :named @p_68) @p_66) :rule implies_neg1)
(anchor :step t8)
(assume t8.a0 @p_10)
(assume t8.a1 @p_24)
(assume t8.a2 @p_32)
(step t8.t0 (cl (= (! (= @p_38 false) :named @p_69) @p_60)) :rule equiv_simplify)
(step t8.t1 (cl (not @p_69) @p_60) :rule equiv1 :premises (t8.t0))
(step t8.t2 (cl (or (! (not (forall ((env env) (v var_alpha)) (= (evalV_alpha env v) (eval_alpha env (inj_alpha v))))) :named @p_37) @p_32)) :rule forall_inst :args (@p_22 v0_alpha))
(step t8.t3 (cl @p_37 @p_32) :rule or :premises (t8.t2))
(step t8.t4 (cl (not (! (= (forall ((env env) (v var_alpha)) (= (eval_alpha env (inj_alpha v)) (evalV_alpha env v))) (forall ((env env) (v var_alpha)) (= (evalV_alpha env v) (eval_alpha env (inj_alpha v))))) :named @p_33)) (not (forall ((env env) (v var_alpha)) (= (eval_alpha env (inj_alpha v)) (evalV_alpha env v)))) (forall ((env env) (v var_alpha)) (= (evalV_alpha env v) (eval_alpha env (inj_alpha v))))) :rule equiv_pos2)
(anchor :step t8.t5 :args ((env env) (v var_alpha) (:= (env env) env) (:= (v var_alpha) v)))
(step t8.t5.t0 (cl (! (= (= (! (eval_alpha env (inj_alpha v)) :named @p_34) (! (evalV_alpha env v) :named @p_35)) (= @p_35 @p_34)) :named @p_36)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_36 2 6))
(step t8.t5 (cl @p_33) :rule bind)
(step t8.t6 (cl (forall ((env env) (v var_alpha)) (= (evalV_alpha env v) (eval_alpha env (inj_alpha v))))) :rule resolution :premises (t8.t4 t8.t5 a2))
(step t8.t7 (cl @p_32) :rule resolution :premises (t8.t3 t8.t6))
(step t8.t8 (cl (= @p_31 @p_23)) :rule symm :premises (t8.t7))
(step t8.t9 (cl (or (! (not (forall ((env env) (v var_alpha) (x alpha)) (= x (evalV_alpha (push_alpha env v x) v)))) :named @p_30) @p_24)) :rule forall_inst :args (empty v0_alpha @p_8))
(step t8.t10 (cl @p_30 @p_24) :rule or :premises (t8.t9))
(step t8.t11 (cl (not (! (= (forall ((env env) (v var_alpha) (x alpha)) (= (evalV_alpha (push_alpha env v x) v) x)) (forall ((env env) (v var_alpha) (x alpha)) (= x (evalV_alpha (push_alpha env v x) v)))) :named @p_25)) (not (forall ((env env) (v var_alpha) (x alpha)) (= (evalV_alpha (push_alpha env v x) v) x))) (forall ((env env) (v var_alpha) (x alpha)) (= x (evalV_alpha (push_alpha env v x) v)))) :rule equiv_pos2)
(anchor :step t8.t12 :args ((env env) (v var_alpha) (x alpha) (:= (env env) env) (:= (v var_alpha) v) (:= (x alpha) x)))
(step t8.t12.t0 (cl (! (= (= (! (evalV_alpha (push_alpha env v x) v) :named @p_28) x) (= x @p_28)) :named @p_29)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_29 2 6))
(step t8.t12 (cl @p_25) :rule bind)
(step t8.t13 (cl (forall ((env env) (v var_alpha) (x alpha)) (= x (evalV_alpha (push_alpha env v x) v)))) :rule resolution :premises (t8.t11 t8.t12 a0))
(step t8.t14 (cl @p_24) :rule resolution :premises (t8.t10 t8.t13))
(step t8.t15 (cl (= @p_23 @p_8)) :rule symm :premises (t8.t14))
(step t8.t16 (cl (= @p_31 @p_8)) :rule trans :premises (t8.t8 t8.t15))
(step t8.t17 (cl (= @p_38 @p_9)) :rule cong :premises (t8.t16))
(step t8.t18 (cl (= (! (= @p_9 false) :named @p_70) @p_10)) :rule equiv_simplify)
(step t8.t19 (cl @p_70 @p_62) :rule equiv2 :premises (t8.t18))
(step t8.t20 (cl (! (not @p_62) :named @p_65) @p_9) :rule not_not)
(step t8.t21 (cl @p_70 @p_9) :rule resolution :premises (t8.t19 t8.t20))
(step t8.t22 (cl (! (not (! (= (! (models empty @p_1) :named @p_11) @p_9) :named @p_12)) :named @p_21) @p_11 @p_10) :rule equiv_pos1)
(step t8.t23 (cl @p_11 @p_10 @p_21) :rule reordering :premises (t8.t22))
(step t8.t24 (cl (! (or (! (models empty @p_5) :named @p_15) @p_11) :named @p_16) (! (not @p_11) :named @p_14)) :rule or_neg :args (1))
(step t8.t25 (cl (! (not (! (= @p_6 @p_16) :named @p_18)) :named @p_20) @p_6 (! (not @p_16) :named @p_17)) :rule equiv_pos1)
(step t8.t26 (cl @p_6 @p_17 @p_20) :rule reordering :premises (t8.t25))
(step t8.t27 (cl (or (! (not (forall ((env env) (phi form) (psi form)) (= (models env (orR phi psi)) (or (models env phi) (models env psi))))) :named @p_19) @p_18)) :rule forall_inst :args (empty @p_5 @p_1))
(step t8.t28 (cl @p_19 @p_18) :rule or :premises (t8.t27))
(step t8.t29 (cl @p_18) :rule resolution :premises (t8.t28 a12))
(step t8.t30 (cl @p_17) :rule resolution :premises (t8.t26 a14 t8.t29))
(step t8.t31 (cl @p_14) :rule resolution :premises (t8.t24 t8.t30))
(step t8.t32 (cl (or (! (not (forall ((env env) (t0 term_alpha)) (= (models env (pR t0)) (p (eval_alpha env t0))))) :named @p_13) @p_12)) :rule forall_inst :args (empty aR))
(step t8.t33 (cl @p_13 @p_12) :rule or :premises (t8.t32))
(step t8.t34 (cl @p_12) :rule resolution :premises (t8.t33 a7))
(step t8.t35 (cl @p_10) :rule resolution :premises (t8.t23 t8.t31 t8.t34))
(step t8.t36 (cl @p_70) :rule resolution :premises (t8.t21 t8.t35))
(step t8.t37 (cl @p_69) :rule trans :premises (t8.t17 t8.t36))
(step t8.t38 (cl @p_60) :rule resolution :premises (t8.t1 t8.t37))
(step t8 (cl @p_62 @p_58 @p_59 @p_60) :rule subproof :discharge (t8.a0 t8.a1 t8.a2))
(step t9 (cl (! (not @p_66) :named @p_67) @p_10) :rule and_pos :args (0))
(step t10 (cl @p_67 @p_24) :rule and_pos :args (1))
(step t11 (cl @p_67 @p_32) :rule and_pos :args (2))
(step t12 (cl @p_60 @p_67 @p_67 @p_67) :rule resolution :premises (t8 t9 t10 t11))
(step t13 (cl @p_67 @p_67 @p_67 @p_60) :rule reordering :premises (t12))
(step t14 (cl @p_67 @p_60) :rule contraction :premises (t13))
(step t15 (cl @p_68 @p_60) :rule resolution :premises (t7 t14))
(step t16 (cl @p_68 (! (not @p_60) :named @p_64)) :rule implies_neg2)
(step t17 (cl @p_68 @p_68) :rule resolution :premises (t15 t16))
(step t18 (cl @p_68) :rule contraction :premises (t17))
(step t19 (cl @p_67 @p_60) :rule implies :premises (t18))
(step t20 (cl @p_62 @p_58 @p_59 @p_60) :rule resolution :premises (t6 t19))
(step t21 (cl @p_63 @p_65) :rule or_neg :args (0))
(step t22 (cl @p_63 (not @p_58)) :rule or_neg :args (1))
(step t23 (cl @p_63 (not @p_59)) :rule or_neg :args (2))
(step t24 (cl @p_63 @p_64) :rule or_neg :args (3))
(step t25 (cl @p_63 @p_63 @p_63 @p_63) :rule resolution :premises (t20 t21 t22 t23 t24))
(step t26 (cl @p_63) :rule contraction :premises (t25))
(step t27 (cl @p_61) :rule resolution :premises (t0 t5 t26))
(step t28 (cl @p_9 @p_58 @p_59 @p_60) :rule or :premises (t27))
(step t29 (cl (! (not (! (= (! (models @p_22 @p_3) :named @p_39) @p_38) :named @p_40)) :named @p_57) (! (not @p_39) :named @p_56) @p_38) :rule equiv_pos2)
(step t30 (cl @p_56 @p_38 @p_57) :rule reordering :premises (t29))
(step t31 (cl (or (! (not (forall ((x alpha)) (models (push_alpha empty v0_alpha x) (pR (inj_alpha v0_alpha))))) :named @p_55) @p_39)) :rule forall_inst :args (@p_8))
(step t32 (cl @p_55 @p_39) :rule or :premises (t31))
(step t33 (cl (! (not (! (= (! (models empty @p_4) :named @p_41) (forall ((x alpha)) (models (push_alpha empty v0_alpha x) (pR (inj_alpha v0_alpha))))) :named @p_42)) :named @p_54) (! (not @p_41) :named @p_44) (forall ((x alpha)) (models (push_alpha empty v0_alpha x) (pR (inj_alpha v0_alpha))))) :rule equiv_pos2)
(step t34 (cl @p_44 (forall ((x alpha)) (models (push_alpha empty v0_alpha x) (pR (inj_alpha v0_alpha)))) @p_54) :rule reordering :premises (t33))
(step t35 (cl (not (! (= (! (or (! (not (! (= @p_15 @p_44) :named @p_45)) :named @p_48) @p_15 (! (not @p_44) :named @p_50)) :named @p_51) (! (or @p_48 @p_15 @p_41) :named @p_49)) :named @p_52)) (not @p_51) @p_49) :rule equiv_pos2)
(step t36 (cl (= @p_48 @p_48)) :rule refl)
(step t37 (cl (= @p_15 @p_15)) :rule refl)
(step t38 (cl (! (= @p_50 @p_41) :named @p_53)) :rule hole :args ("TRUST_THEORY_REWRITE" @p_53 1 5))
(step t39 (cl @p_52) :rule cong :premises (t36 t37 t38))
(step t40 (cl @p_48 @p_15 @p_50) :rule equiv_pos1)
(step t41 (cl @p_51 (not @p_48)) :rule or_neg :args (0))
(step t42 (cl @p_51 (! (not @p_15) :named @p_47)) :rule or_neg :args (1))
(step t43 (cl @p_51 (not @p_50)) :rule or_neg :args (2))
(step t44 (cl @p_51 @p_51 @p_51) :rule resolution :premises (t40 t41 t42 t43))
(step t45 (cl @p_51) :rule contraction :premises (t44))
(step t46 (cl @p_49) :rule resolution :premises (t35 t39 t45))
(step t47 (cl @p_48 @p_15 @p_41) :rule or :premises (t46))
(step t48 (cl @p_15 @p_41 @p_48) :rule reordering :premises (t47))
(step t49 (cl @p_16 @p_47) :rule or_neg :args (0))
(step t50 (cl @p_20 @p_6 @p_17) :rule equiv_pos1)
(step t51 (cl @p_6 @p_17 @p_20) :rule reordering :premises (t50))
(step t52 (cl (or @p_19 @p_18)) :rule forall_inst :args (empty @p_5 @p_1))
(step t53 (cl @p_19 @p_18) :rule or :premises (t52))
(step t54 (cl @p_18) :rule resolution :premises (t53 a12))
(step t55 (cl @p_17) :rule resolution :premises (t51 a14 t54))
(step t56 (cl @p_47) :rule resolution :premises (t49 t55))
(step t57 (cl (or (! (not (forall ((env env) (phi form)) (= (models env (notR phi)) (not (models env phi))))) :named @p_46) @p_45)) :rule forall_inst :args (empty @p_4))
(step t58 (cl @p_46 @p_45) :rule or :premises (t57))
(step t59 (cl @p_45) :rule resolution :premises (t58 a11))
(step t60 (cl @p_41) :rule resolution :premises (t48 t56 t59))
(step t61 (cl (or (! (not (forall ((env env) (phi form) (v var_alpha)) (= (models env (forallR_alpha v phi)) (forall ((x alpha)) (models (push_alpha env v x) phi))))) :named @p_43) @p_42)) :rule forall_inst :args (empty @p_3 v0_alpha))
(step t62 (cl @p_43 @p_42) :rule or :premises (t61))
(step t63 (cl @p_42) :rule resolution :premises (t62 a13))
(step t64 (cl (forall ((x alpha)) (models (push_alpha empty v0_alpha x) (pR (inj_alpha v0_alpha))))) :rule resolution :premises (t34 t60 t63))
(step t65 (cl @p_39) :rule resolution :premises (t32 t64))
(step t66 (cl (or @p_13 @p_40)) :rule forall_inst :args (@p_22 @p_2))
(step t67 (cl @p_13 @p_40) :rule or :premises (t66))
(step t68 (cl @p_40) :rule resolution :premises (t67 a7))
(step t69 (cl @p_38) :rule resolution :premises (t30 t65 t68))
(step t70 (cl (or @p_37 @p_32)) :rule forall_inst :args (@p_22 v0_alpha))
(step t71 (cl @p_37 @p_32) :rule or :premises (t70))
(step t72 (cl (not @p_33) (not (forall ((env env) (v var_alpha)) (= (eval_alpha env (inj_alpha v)) (evalV_alpha env v)))) (forall ((env env) (v var_alpha)) (= (evalV_alpha env v) (eval_alpha env (inj_alpha v))))) :rule equiv_pos2)
(anchor :step t73 :args ((env env) (v var_alpha) (:= (env env) env) (:= (v var_alpha) v)))
(step t73.t0 (cl @p_36) :rule hole :args ("TRUST_THEORY_REWRITE" @p_36 2 6))
(step t73 (cl @p_33) :rule bind)
(step t74 (cl (forall ((env env) (v var_alpha)) (= (evalV_alpha env v) (eval_alpha env (inj_alpha v))))) :rule resolution :premises (t72 t73 a2))
(step t75 (cl @p_32) :rule resolution :premises (t71 t74))
(step t76 (cl (or @p_30 @p_24)) :rule forall_inst :args (empty v0_alpha @p_8))
(step t77 (cl @p_30 @p_24) :rule or :premises (t76))
(step t78 (cl (not @p_25) (not (forall ((env env) (v var_alpha) (x alpha)) (= (evalV_alpha (push_alpha env v x) v) x))) (forall ((env env) (v var_alpha) (x alpha)) (= x (evalV_alpha (push_alpha env v x) v)))) :rule equiv_pos2)
(anchor :step t79 :args ((env env) (v var_alpha) (x alpha) (:= (env env) env) (:= (v var_alpha) v) (:= (x alpha) x)))
(step t79.t0 (cl @p_29) :rule hole :args ("TRUST_THEORY_REWRITE" @p_29 2 6))
(step t79 (cl @p_25) :rule bind)
(step t80 (cl (forall ((env env) (v var_alpha) (x alpha)) (= x (evalV_alpha (push_alpha env v x) v)))) :rule resolution :premises (t78 t79 a0))
(step t81 (cl @p_24) :rule resolution :premises (t77 t80))
(step t82 (cl @p_21 @p_11 @p_10) :rule equiv_pos1)
(step t83 (cl @p_11 @p_10 @p_21) :rule reordering :premises (t82))
(step t84 (cl @p_16 @p_14) :rule or_neg :args (1))
(step t85 (cl @p_14) :rule resolution :premises (t84 t55))
(step t86 (cl (or @p_13 @p_12)) :rule forall_inst :args (empty aR))
(step t87 (cl @p_13 @p_12) :rule or :premises (t86))
(step t88 (cl @p_12) :rule resolution :premises (t87 a7))
(step t89 (cl @p_10) :rule resolution :premises (t83 t85 t88))
(step t90 (cl) :rule resolution :premises (t28 t69 t75 t81 t89))
