(define-fun @quantifiers_skolemize_10 () A_list$ (choice ((?v3 A_list$)) (not (or (not (member$c ?v3 (collect$a top$b))) (not (= xs$ (fun_app$g llist_of$ ?v3)))))))
(assume nt1.0 (not (not (forall ((?v0 A_list$)) (not (= xs$ (fun_app$g llist_of$ ?v0)))))))
(assume nt1.1 (not (not (= xs$ (fun_app$g llist_of$ @quantifiers_skolemize_10)))))
(anchor :step t1)
(assume t1.a0 (forall ((?v0 A_list$)) (not (= xs$ (fun_app$g llist_of$ ?v0)))))
(step t1.t1 (cl (not (forall ((?v0 A_list$)) (not (= xs$ (fun_app$g llist_of$ ?v0))))) (not (= xs$ (fun_app$g llist_of$ @quantifiers_skolemize_10)))) :rule trust)
(step t1.t15 (cl (forall ((?v0 A_list$)) (not (= xs$ (fun_app$g llist_of$ ?v0))))) :rule trust)
(step st1.t16 (cl (not (= xs$ (fun_app$g llist_of$ @quantifiers_skolemize_10)))) :rule resolution :premises (t1.t1 t1.t15))
(step t1.t16 (cl (not (= xs$ (fun_app$g llist_of$ @quantifiers_skolemize_10)))) :rule trust)
(step t1 (cl (not (forall ((?v0 A_list$)) (not (= xs$ (fun_app$g llist_of$ ?v0))))) (not (= xs$ (fun_app$g llist_of$ @quantifiers_skolemize_10)))) :rule subproof :discharge (t1.a0))
(step t.end (cl) :rule resolution :premises (nt1.0 nt1.1 t1))
