(assume nt1.0 (not (not (forall ((?v0 A_llist$) (?v1 Enat$)) (or (not (fun_app$ (less_eq$ (llength$a ?v0)) ?v1)) (= ?v0 (ltake$ ?v1 ?v0)))))))
(assume nt1.1 (not (or (not (fun_app$ (less_eq$ (llength$a xs$)) (llength$ us$))) (= xs$ (ltake$ (llength$ us$) xs$)))))
(assume a23 (forall ((?v0 A_llist$) (?v1 Enat$)) (=> (fun_app$ (less_eq$ (llength$a ?v0)) ?v1) (= (ltake$ ?v1 ?v0) ?v0))))
(anchor :step t1)
(assume t1.a0 (forall ((?v0 A_llist$) (?v1 Enat$)) (or (not (fun_app$ (less_eq$ (llength$a ?v0)) ?v1)) (= ?v0 (ltake$ ?v1 ?v0)))))
(step t1.t2 (cl (not (= (forall ((?v0 A_llist$) (?v1 Enat$)) (=> (fun_app$ (less_eq$ (llength$a ?v0)) ?v1) (= (ltake$ ?v1 ?v0) ?v0))) (forall ((?v0 A_llist$) (?v1 Enat$)) (or (not (fun_app$ (less_eq$ (llength$a ?v0)) ?v1)) (= ?v0 (ltake$ ?v1 ?v0)))))) (not (forall ((?v0 A_llist$) (?v1 Enat$)) (=> (fun_app$ (less_eq$ (llength$a ?v0)) ?v1) (= (ltake$ ?v1 ?v0) ?v0)))) (forall ((?v0 A_llist$) (?v1 Enat$)) (or (not (fun_app$ (less_eq$ (llength$a ?v0)) ?v1)) (= ?v0 (ltake$ ?v1 ?v0))))) :rule trust)
(step t1.t5 (cl (= (forall ((?v0 A_llist$) (?v1 Enat$)) (=> (fun_app$ (less_eq$ (llength$a ?v0)) ?v1) (= (ltake$ ?v1 ?v0) ?v0))) (forall ((?v0 A_llist$) (?v1 Enat$)) (or (not (fun_app$ (less_eq$ (llength$a ?v0)) ?v1)) (= ?v0 (ltake$ ?v1 ?v0)))))) :rule trust)
(step st1.t6 (cl (forall ((?v0 A_llist$) (?v1 Enat$)) (or (not (fun_app$ (less_eq$ (llength$a ?v0)) ?v1)) (= ?v0 (ltake$ ?v1 ?v0))))) :rule resolution :premises (t1.t2 t1.t5 a23))
(step t1.t7 (cl (or (not (fun_app$ (less_eq$ (llength$a xs$)) (llength$ us$))) (= xs$ (ltake$ (llength$ us$) xs$)))) :rule trust)
(step t1 (cl (not (forall ((?v0 A_llist$) (?v1 Enat$)) (or (not (fun_app$ (less_eq$ (llength$a ?v0)) ?v1)) (= ?v0 (ltake$ ?v1 ?v0))))) (or (not (fun_app$ (less_eq$ (llength$a xs$)) (llength$ us$))) (= xs$ (ltake$ (llength$ us$) xs$)))) :rule subproof :discharge (t1.a0))
(step t.end (cl) :rule resolution :premises (nt1.0 nt1.1 t1))
