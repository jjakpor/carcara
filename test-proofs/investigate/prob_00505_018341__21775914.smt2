; --full-saturate-quant --inst-when=full-last-call --inst-no-entail --term-db-mode=relevant --multi-trigger-linear --no-stats --random-seed=1 --lang=smt2 --tlimit 300000
(set-option :produce-unsat-cores true)
(set-logic AUFLIA)
(declare-sort Type$ 0)
(declare-sort Label$ 0)
(declare-sort Sterm$ 0)
(declare-sort Char_list$ 0)
(declare-sort Label_set$ 0)
(declare-sort Sterm_option$ 0)
(declare-sort Char_list_set$ 0)
(declare-sort Label_bool_fun$ 0)
(declare-sort Type_type_prod$ 0)
(declare-sort Type_environment$ 0)
(declare-sort Char_list_bool_fun$ 0)
(declare-sort Type_type_prod_option$ 0)
(declare-sort Label_sterm_option_fun$ 0)
(declare-fun b$ () Sterm$)
(declare-fun e$ () Type_environment$)
(declare-fun f$ () Label_sterm_option_fun$)
(declare-fun l$ () Label$)
(declare-fun p$ () Bool)
(declare-fun t$ () Type$)
(declare-fun u$ () Type$)
(declare-fun do$ (Type$) Label_set$)
(declare-fun uu$ (Char_list_set$) Char_list_bool_fun$)
(declare-fun add$ (Type_environment$ Char_list$ Type$) Type_environment$)
(declare-fun dom$ (Label_sterm_option_fun$) Label_set$)
(declare-fun obj$ (Label_sterm_option_fun$ Type$) Sterm$)
(declare-fun the$ (Type_type_prod_option$) Type_type_prod$)
(declare-fun upd$ (Sterm$ Label$ Sterm$) Sterm$)
(declare-fun uua$ (Label_set$) Label_bool_fun$)
(declare-fun call$ (Sterm$ Label$ Sterm$) Sterm$)
(declare-fun fvar$ (Char_list$) Sterm$)
(declare-fun the$a (Sterm_option$) Sterm$)
(declare-fun openz$ (Sterm$ Sterm$ Sterm$) Sterm$)
(declare-fun param$ (Type_type_prod$) Type$)
(declare-fun finite$ (Char_list_set$) Bool)
(declare-fun member$ (Label$ Label_set$) Bool)
(declare-fun return$ (Type_type_prod$) Type$)
(declare-fun typing$ (Type_environment$ Sterm$ Type$) Bool)
(declare-fun collect$ (Char_list_bool_fun$) Char_list_set$)
(declare-fun fun_app$ (Label_bool_fun$ Label$) Bool)
(declare-fun member$a (Char_list$ Char_list_set$) Bool)
(declare-fun collect$a (Label_bool_fun$) Label_set$)
(declare-fun fun_app$a (Char_list_bool_fun$ Char_list$) Bool)
(declare-fun fun_app$b (Label_sterm_option_fun$ Label$) Sterm_option$)
(declare-fun type_get$ (Type$ Label$) Type_type_prod_option$)
(assert (! (forall ((?v0 Label_set$) (?v1 Label$)) (! (= (fun_app$ (uua$ ?v0) ?v1) (member$ ?v1 ?v0)) :pattern ((fun_app$ (uua$ ?v0) ?v1)))) :named a0))
(assert (! (forall ((?v0 Char_list_set$) (?v1 Char_list$)) (! (= (fun_app$a (uu$ ?v0) ?v1) (member$a ?v1 ?v0)) :pattern ((fun_app$a (uu$ ?v0) ?v1)))) :named a1))
(assert (! (not p$) :named a2))
(assert (! (=> (exists ((?v0 Char_list_set$)) (and (finite$ ?v0) (forall ((?v1 Char_list$) (?v2 Char_list$)) (=> (and (not (member$a ?v1 ?v0)) (and (not (member$a ?v2 ?v0)) (not (= ?v1 ?v2)))) (typing$ (add$ (add$ e$ ?v1 u$) ?v2 (param$ (the$ (type_get$ u$ l$)))) (openz$ (the$a (fun_app$b f$ l$)) (fvar$ ?v1) (fvar$ ?v2)) t$))))) p$) :named a3))
(assert (! (typing$ e$ (call$ (obj$ f$ u$) l$ b$) t$) :named a4))
(assert (! (forall ((?v0 Char_list$) (?v1 Char_list$)) (= (= (fvar$ ?v0) (fvar$ ?v1)) (= ?v0 ?v1))) :named a5))
(assert (! (forall ((?v0 Type_environment$) (?v1 Label_sterm_option_fun$) (?v2 Type$) (?v3 Type$)) (=> (typing$ ?v0 (obj$ ?v1 ?v2) ?v3) (= ?v3 ?v2))) :named a6))
(assert (! (forall ((?v0 Type_environment$) (?v1 Sterm$) (?v2 Label$) (?v3 Sterm$) (?v4 Type$)) (=> (and (typing$ ?v0 (upd$ ?v1 ?v2 ?v3) ?v4) (forall ((?v5 Char_list_set$)) (=> (and (finite$ ?v5) (and (forall ((?v6 Char_list$) (?v7 Char_list$)) (=> (and (not (member$a ?v6 ?v5)) (and (not (member$a ?v7 ?v5)) (not (= ?v6 ?v7)))) (typing$ (add$ (add$ ?v0 ?v6 ?v4) ?v7 (param$ (the$ (type_get$ ?v4 ?v2)))) (openz$ ?v3 (fvar$ ?v6) (fvar$ ?v7)) (return$ (the$ (type_get$ ?v4 ?v2)))))) (and (typing$ ?v0 ?v1 ?v4) (member$ ?v2 (do$ ?v4))))) false))) false)) :named a7))
(assert (! (forall ((?v0 Char_list_set$) (?v1 Type_environment$) (?v2 Type$) (?v3 Label$) (?v4 Sterm$) (?v5 Sterm$)) (=> (and (finite$ ?v0) (and (forall ((?v6 Char_list$) (?v7 Char_list$)) (=> (and (not (member$a ?v6 ?v0)) (and (not (member$a ?v7 ?v0)) (not (= ?v6 ?v7)))) (typing$ (add$ (add$ ?v1 ?v6 ?v2) ?v7 (param$ (the$ (type_get$ ?v2 ?v3)))) (openz$ ?v4 (fvar$ ?v6) (fvar$ ?v7)) (return$ (the$ (type_get$ ?v2 ?v3)))))) (and (typing$ ?v1 ?v5 ?v2) (member$ ?v3 (do$ ?v2))))) (typing$ ?v1 (upd$ ?v5 ?v3 ?v4) ?v2))) :named a8))
(assert (! (forall ((?v0 Type_environment$) (?v1 Label_sterm_option_fun$) (?v2 Type$)) (=> (typing$ ?v0 (obj$ ?v1 ?v2) ?v2) (and (= (dom$ ?v1) (do$ ?v2)) (exists ((?v3 Char_list_set$)) (and (finite$ ?v3) (forall ((?v4 Label$)) (=> (member$ ?v4 (do$ ?v2)) (forall ((?v5 Char_list$) (?v6 Char_list$)) (=> (and (not (member$a ?v5 ?v3)) (and (not (member$a ?v6 ?v3)) (not (= ?v5 ?v6)))) (typing$ (add$ (add$ ?v0 ?v5 ?v2) ?v6 (param$ (the$ (type_get$ ?v2 ?v4)))) (openz$ (the$a (fun_app$b ?v1 ?v4)) (fvar$ ?v5) (fvar$ ?v6)) (return$ (the$ (type_get$ ?v2 ?v4))))))))))))) :named a9))
(assert (! (forall ((?v0 Char_list_set$)) (=> (finite$ ?v0) (exists ((?v1 Char_list$) (?v2 Char_list$)) (and (not (member$a ?v1 ?v0)) (and (not (member$a ?v2 ?v0)) (not (= ?v1 ?v2))))))) :named a10))
(assert (! (forall ((?v0 Char_list$) (?v1 Char_list$) (?v2 Type_environment$) (?v3 Type$) (?v4 Type$)) (=> (not (= ?v0 ?v1)) (= (add$ (add$ ?v2 ?v0 ?v3) ?v1 ?v4) (add$ (add$ ?v2 ?v1 ?v4) ?v0 ?v3)))) :named a11))
(assert (! (forall ((?v0 Type_environment$) (?v1 Sterm$) (?v2 Label$) (?v3 Sterm$) (?v4 Type$)) (=> (and (typing$ ?v0 (call$ ?v1 ?v2 ?v3) ?v4) (forall ((?v5 Type$)) (=> (and (= ?v4 (return$ (the$ (type_get$ ?v5 ?v2)))) (and (typing$ ?v0 ?v1 ?v5) (and (typing$ ?v0 ?v3 (param$ (the$ (type_get$ ?v5 ?v2)))) (member$ ?v2 (do$ ?v5))))) false))) false)) :named a12))
(assert (! (forall ((?v0 Type_environment$) (?v1 Sterm$) (?v2 Type$) (?v3 Sterm$) (?v4 Label$)) (=> (and (typing$ ?v0 ?v1 ?v2) (and (typing$ ?v0 ?v3 (param$ (the$ (type_get$ ?v2 ?v4)))) (member$ ?v4 (do$ ?v2)))) (typing$ ?v0 (call$ ?v1 ?v4 ?v3) (return$ (the$ (type_get$ ?v2 ?v4)))))) :named a13))
(assert (! (forall ((?v0 Char_list$) (?v1 Char_list_bool_fun$)) (= (member$a ?v0 (collect$ ?v1)) (fun_app$a ?v1 ?v0))) :named a14))
(assert (! (forall ((?v0 Label$) (?v1 Label_bool_fun$)) (= (member$ ?v0 (collect$a ?v1)) (fun_app$ ?v1 ?v0))) :named a15))
(assert (! (forall ((?v0 Char_list_set$)) (= (collect$ (uu$ ?v0)) ?v0)) :named a16))
(assert (! (forall ((?v0 Label_set$)) (= (collect$a (uua$ ?v0)) ?v0)) :named a17))
(assert (! (forall ((?v0 Label_bool_fun$) (?v1 Label_bool_fun$)) (=> (forall ((?v2 Label$)) (= (fun_app$ ?v0 ?v2) (fun_app$ ?v1 ?v2))) (= (collect$a ?v0) (collect$a ?v1)))) :named a18))
(assert (! (forall ((?v0 Char_list_bool_fun$) (?v1 Char_list_bool_fun$)) (=> (forall ((?v2 Char_list$)) (= (fun_app$a ?v0 ?v2) (fun_app$a ?v1 ?v2))) (= (collect$ ?v0) (collect$ ?v1)))) :named a19))
(check-sat)
