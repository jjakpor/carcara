unsat
(assume a0 circuit)
(assume a1 rd2)
(assume a2 red_MR)
(assume a3 (or grn_SR org_SR))
(assume a4 (=> grn (and (not org) (not rd1) (not rd2))))
(assume a5 (=> org (and (not rd1) (not rd2))))
(assume a6 (=> rd1 (not rd2)))
(assume a7 (= org_MR org))
(assume a8 (= grn_SR rd1))
(assume a9 (= org_SR rd2))
(assume a10 (= red_SR (or grn org)))
(assume a11 (not (= rd1 (or org (and prt rd1)))))
(step t0 (cl rd1 (or org (and prt rd1))) :rule not_equiv1 :premises (a11))
(step t1 (cl (not rd1) (not rd2)) :rule implies :premises (a6))
(step t2 (cl (not rd1)) :rule resolution :premises (t1 a1))
(step t3 (cl (or org (and prt rd1))) :rule resolution :premises (t0 t2))
(step t4 (cl (not (or org (and prt rd1))) org (and prt rd1)) :rule or_pos)
(step t5 (cl (not org) (and (not rd1) (not rd2))) :rule implies :premises (a5))
(step t6 (cl (not (and (not rd1) (not rd2))) (not rd2)) :rule and_pos :args (1))
(step t7 (cl (not (and (not rd1) (not rd2)))) :rule resolution :premises (t6 a1))
(step t8 (cl (not org)) :rule resolution :premises (t5 t7))
(step t9 (cl (not (and prt rd1)) rd1) :rule and_pos :args (1))
(step t10 (cl (not (and prt rd1))) :rule resolution :premises (t9 t2))
(step t11 (cl (not (or org (and prt rd1)))) :rule resolution :premises (t4 t8 t10))
(step t12 (cl) :rule resolution :premises (t3 t11))
