unsat
(assume a0 (not circuit))
(assume a1 (or (= flash nf0) (= flash nf)))
(assume a2 (=> (not (= nf nf0)) (not (= flash nf))))
(assume a3 (=> (not (= nf nf0)) (= flash nf0)))
(assume a4 (= reg input))
(assume a5 (not (= nf0 flash)))
(step t0 (cl (not (= (not (= nf0 flash)) false)) (not (not (= nf0 flash))) false) :rule equiv_pos2)
(step t1 (cl (= (= nf0 flash) (= flash nf0))) :rule rare_rewrite :args ("eq-symm" nf0 flash))
(step t2 (cl (= (not (= nf0 flash)) (not (= flash nf0)))) :rule cong :premises (t1))
(step t3 (cl (= flash nf0) (= flash nf)) :rule or :premises (a1))
(step t4 (cl (not (= flash nf0))) :rule not_symm :premises (a5))
(step t5 (cl (= flash nf)) :rule resolution :premises (t3 t4))
(step t6 (cl (not (not (not (= nf nf0)))) (= nf nf0)) :rule not_not)
(step t7 (cl (not (not (= nf nf0))) (= flash nf0)) :rule implies :premises (a3))
(step t8 (cl (not (not (= nf nf0)))) :rule resolution :premises (t7 t4))
(step t9 (cl (= nf nf0)) :rule resolution :premises (t6 t8))
(step t10 (cl (= flash nf0)) :rule trans :premises (t5 t9))
(step t11 (cl (= nf0 nf0)) :rule refl)
(step t12 (cl (= (= flash nf0) (= nf0 nf0))) :rule cong :premises (t10 t11))
(step t13 (cl (= (not (= flash nf0)) (not (= nf0 nf0)))) :rule cong :premises (t12))
(step t14 (cl (= (= nf0 nf0) true)) :rule rare_rewrite :args ("eq-refl" nf0))
(step t15 (cl (= (not (= nf0 nf0)) (not true))) :rule cong :premises (t14))
(step t16 (cl (= (not true) false)) :rule rare_rewrite :args ("evaluate"))
(step t17 (cl (= (not (= nf0 nf0)) false)) :rule trans :premises (t15 t16))
(step t18 (cl (= (not (= flash nf0)) false)) :rule trans :premises (t13 t17))
(step t19 (cl (= (not (= nf0 flash)) false)) :rule trans :premises (t2 t18))
(step t20 (cl false) :rule resolution :premises (t0 t19 a5))
(step t21 (cl (not false)) :rule false)
(step t22 (cl) :rule resolution :premises (t20 t21))
