unsat
(assume a0 (not circuit))
(assume a1 (or (= flash nf0) (= flash nf)))
(assume a2 (= reg input))
(assume a3 (not (not (and (not (= nf0 flash)) (= nf0 nf)))))
(step t0 (cl (not (= (not (not (and (not (= nf0 flash)) (= nf0 nf)))) false)) (not (not (not (and (not (= nf0 flash)) (= nf0 nf))))) false) :rule equiv_pos2)
(step t1 (cl (= (not (not (and (not (= nf0 flash)) (= nf0 nf)))) (and (not (= nf0 flash)) (= nf0 nf)))) :rule rare_rewrite :args ("bool-double-not-elim" (and (not (= nf0 flash)) (= nf0 nf))))
(step t2 (cl (= (= nf0 flash) (= flash nf0))) :rule rare_rewrite :args ("eq-symm" nf0 flash))
(step t3 (cl (= (not (= nf0 flash)) (not (= flash nf0)))) :rule cong :premises (t2))
(step t4 (cl (= (= nf0 nf) (= nf nf0))) :rule rare_rewrite :args ("eq-symm" nf0 nf))
(step t5 (cl (= (and (not (= nf0 flash)) (= nf0 nf)) (and (not (= flash nf0)) (= nf nf0)))) :rule cong :premises (t3 t4))
(step t6 (cl (= (not (not (and (not (= nf0 flash)) (= nf0 nf)))) (and (not (= flash nf0)) (= nf nf0)))) :rule trans :premises (t1 t5))
(step t7 (cl (not (= (= flash nf) (= flash nf0))) (not (= flash nf)) (= flash nf0)) :rule equiv_pos2)
(step t8 (cl (= flash flash)) :rule refl)
(step t9 (cl (not (= (not (not (and (not (= nf0 flash)) (= nf0 nf)))) (and (not (= flash nf0)) (= nf nf0)))) (not (not (not (and (not (= nf0 flash)) (= nf0 nf))))) (and (not (= flash nf0)) (= nf nf0))) :rule equiv_pos2)
(step t10 (cl (and (not (= flash nf0)) (= nf nf0))) :rule resolution :premises (t9 t6 a3))
(step t11 (cl (= nf nf0)) :rule and :premises (t10) :args (1))
(step t12 (cl (= (= flash nf) (= flash nf0))) :rule cong :premises (t8 t11))
(step t13 (cl (= flash nf0) (= flash nf)) :rule or :premises (a1))
(step t14 (cl (not (= flash nf0))) :rule and :premises (t10) :args (0))
(step t15 (cl (= flash nf)) :rule resolution :premises (t13 t14))
(step t16 (cl (= flash nf0)) :rule resolution :premises (t7 t12 t15))
(step t17 (cl (= nf0 nf0)) :rule refl)
(step t18 (cl (= (= flash nf0) (= nf0 nf0))) :rule cong :premises (t16 t17))
(step t19 (cl (= (not (= flash nf0)) (not (= nf0 nf0)))) :rule cong :premises (t18))
(step t20 (cl (= (= nf nf0) (= nf0 nf0))) :rule cong :premises (t11 t17))
(step t21 (cl (= (and (not (= flash nf0)) (= nf nf0)) (and (not (= nf0 nf0)) (= nf0 nf0)))) :rule cong :premises (t19 t20))
(step t22 (cl (= (= nf0 nf0) true)) :rule rare_rewrite :args ("eq-refl" nf0))
(step t23 (cl (= (not (= nf0 nf0)) (not true))) :rule cong :premises (t22))
(step t24 (cl (= (not true) false)) :rule rare_rewrite :args ("evaluate"))
(step t25 (cl (= (not (= nf0 nf0)) false)) :rule trans :premises (t23 t24))
(step t26 (cl (= (and (not (= nf0 nf0)) (= nf0 nf0)) (and false true))) :rule cong :premises (t25 t22))
(step t27 (cl (= (and false true) false)) :rule rare_rewrite :args ("evaluate"))
(step t28 (cl (= (and (not (= nf0 nf0)) (= nf0 nf0)) false)) :rule trans :premises (t26 t27))
(step t29 (cl (= (and (not (= flash nf0)) (= nf nf0)) false)) :rule trans :premises (t21 t28))
(step t30 (cl (= (not (not (and (not (= nf0 flash)) (= nf0 nf)))) false)) :rule trans :premises (t6 t29))
(step t31 (cl false) :rule resolution :premises (t0 t30 a3))
(step t32 (cl (not false)) :rule false)
(step t33 (cl) :rule resolution :premises (t31 t32))
