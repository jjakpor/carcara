unsat
(assume a0 (= mode cir))
(assume a1 i1)
(assume a2 (not p2))
(assume a3 (= a1 b1))
(assume a4 (= a2 b2))
(assume a5 (= (not i2) (= r2 b2)))
(assume a6 (not (= r1 b1)))
(assume a7 (not (= i2 (not (= r2 b2)))))
(step t0 (cl (not (= (= (not i2) (= r2 b2)) false)) (not (= (not i2) (= r2 b2))) false) :rule equiv_pos2)
(step t1 (cl (= (not i2) (not i2))) :rule refl)
(step t2 (cl (= (= r2 b2) (= b2 r2))) :rule rare_rewrite :args ("eq-symm" r2 b2))
(step t3 (cl (= (= (not i2) (= r2 b2)) (= (not i2) (= b2 r2)))) :rule cong :premises (t1 t2))
(step t4 (cl (not (= (not (= i2 (not (= b2 r2)))) (= i2 (not (not (= b2 r2)))))) (not (not (= i2 (not (= b2 r2))))) (= i2 (not (not (= b2 r2))))) :rule equiv_pos2)
(step t5 (cl (= (= (= (not (= i2 (not (= b2 r2)))) (= i2 (not (not (= b2 r2))))) true) (= (not (= i2 (not (= b2 r2)))) (= i2 (not (not (= b2 r2))))))) :rule equiv_simplify)
(step t6 (cl (not (= (= (not (= i2 (not (= b2 r2)))) (= i2 (not (not (= b2 r2))))) true)) (= (not (= i2 (not (= b2 r2)))) (= i2 (not (not (= b2 r2)))))) :rule equiv1 :premises (t5))
(step t7 (cl (= (not (= i2 (not (= b2 r2)))) (not (= i2 (not (= b2 r2)))))) :rule refl)
(step t8 (cl (= i2 i2)) :rule refl)
(step t9 (cl (= (not (not (= b2 r2))) (= b2 r2))) :rule rare_rewrite :args ("bool-double-not-elim" (= b2 r2)))
(step t10 (cl (= (= i2 (not (not (= b2 r2)))) (= i2 (= b2 r2)))) :rule cong :premises (t8 t9))
(step t11 (cl (= (= (not (= i2 (not (= b2 r2)))) (= i2 (not (not (= b2 r2))))) (= (not (= i2 (not (= b2 r2)))) (= i2 (= b2 r2))))) :rule cong :premises (t7 t10))
(step t12 (cl (= (= (not (= i2 (not (= b2 r2)))) (= i2 (= b2 r2))) true)) :rule hole :args ("11" (= (= (not (= i2 (not (= b2 r2)))) (= i2 (= b2 r2))) true)))
(step t13 (cl (= (= (not (= i2 (not (= b2 r2)))) (= i2 (not (not (= b2 r2))))) true)) :rule trans :premises (t11 t12))
(step t14 (cl (= (not (= i2 (not (= b2 r2)))) (= i2 (not (not (= b2 r2)))))) :rule resolution :premises (t6 t13))
(step t15 (cl (not (= (not (= i2 (not (= r2 b2)))) (not (= i2 (not (= b2 r2)))))) (not (not (= i2 (not (= r2 b2))))) (not (= i2 (not (= b2 r2))))) :rule equiv_pos2)
(step t16 (cl (= (not (= r2 b2)) (not (= b2 r2)))) :rule cong :premises (t2))
(step t17 (cl (= (= i2 (not (= r2 b2))) (= i2 (not (= b2 r2))))) :rule cong :premises (t8 t16))
(step t18 (cl (= (not (= i2 (not (= r2 b2)))) (not (= i2 (not (= b2 r2)))))) :rule cong :premises (t17))
(step t19 (cl (not (= i2 (not (= b2 r2))))) :rule resolution :premises (t15 t18 a7))
(step t20 (cl (= i2 (not (not (= b2 r2))))) :rule resolution :premises (t4 t14 t19))
(step t21 (cl (= (not i2) (not (not (not (= b2 r2)))))) :rule cong :premises (t20))
(step t22 (cl (= (= b2 r2) (= b2 r2))) :rule refl)
(step t23 (cl (= (= (not i2) (= b2 r2)) (= (not (not (not (= b2 r2)))) (= b2 r2)))) :rule cong :premises (t21 t22))
(step t24 (cl (= (= (not (not (not (= b2 r2)))) (= b2 r2)) (= (= b2 r2) (not (not (not (= b2 r2))))))) :rule rare_rewrite :args ("eq-symm" (not (not (not (= b2 r2)))) (= b2 r2)))
(step t25 (cl (= (not (not (= b2 r2))) (= b2 r2))) :rule rare_rewrite :args ("bool-double-not-elim" (= b2 r2)))
(step t26 (cl (= (not (not (not (= b2 r2)))) (not (= b2 r2)))) :rule cong :premises (t25))
(step t27 (cl (= (= (= b2 r2) (not (not (not (= b2 r2))))) (= (= b2 r2) (not (= b2 r2))))) :rule cong :premises (t22 t26))
(step t28 (cl (= (= (= b2 r2) (not (= b2 r2))) false)) :rule rare_rewrite :args ("bool-eq-nrefl" (= b2 r2)))
(step t29 (cl (= (= (= b2 r2) (not (not (not (= b2 r2))))) false)) :rule trans :premises (t27 t28))
(step t30 (cl (= (= (not (not (not (= b2 r2)))) (= b2 r2)) false)) :rule trans :premises (t24 t29))
(step t31 (cl (= (= (not i2) (= b2 r2)) false)) :rule trans :premises (t23 t30))
(step t32 (cl (= (= (not i2) (= r2 b2)) false)) :rule trans :premises (t3 t31))
(step t33 (cl false) :rule resolution :premises (t0 t32 a5))
(step t34 (cl (not false)) :rule false)
(step t35 (cl) :rule resolution :premises (t33 t34))
