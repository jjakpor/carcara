(assume nt8.0 (not (not (not (p (eval_alpha empty aR))))))
(assume nt8.1 (not (not (= (eval_alpha empty aR) (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha)))))
(assume nt8.2 (not (not (= (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha) (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))))
(assume nt8.3 (not (not (p (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))))
(assume a7 (forall ((env env) (t0 term_alpha)) (= (models env (pR t0)) (p (eval_alpha env t0)))))
(anchor :step t8)
(assume t8.a0 (not (p (eval_alpha empty aR))))
(assume t8.a1 (= (eval_alpha empty aR) (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha)))
(assume t8.a2 (= (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha) (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))
(step t8.t33 (cl (not (forall ((env env) (t0 term_alpha)) (= (models env (pR t0)) (p (eval_alpha env t0))))) (= (models empty (pR aR)) (p (eval_alpha empty aR)))) :rule trust)
(step st8.t34 (cl (= (models empty (pR aR)) (p (eval_alpha empty aR)))) :rule resolution :premises (t8.t33 a7))
(step t8.t38 (cl (not (p (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))) :rule trust)
(step t8 (cl (not (not (p (eval_alpha empty aR)))) (not (= (eval_alpha empty aR) (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha))) (not (= (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha) (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha)))) (not (p (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))) :rule subproof :discharge (t8.a0 t8.a1 t8.a2))
(step t.end (cl) :rule resolution :premises (nt8.0 nt8.1 nt8.2 nt8.3 t8))
