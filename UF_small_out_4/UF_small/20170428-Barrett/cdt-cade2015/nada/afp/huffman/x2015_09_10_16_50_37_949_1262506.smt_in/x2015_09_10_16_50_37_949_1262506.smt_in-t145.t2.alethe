(assume nt145.0 (not (= (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2)))))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0)))) (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0)))))))
(anchor :step t145 :args ((?v0 A_tree$) (?v1 A$) (?v2 A$) (:= (?v0 A_tree$) ?v0) (:= (?v1 A$) ?v1) (:= (?v2 A$) ?v2)))
(step t145.t0 (cl (= (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2)))))) (and (consistent$ ?v0) (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2))))) :rule trust)
(step t145.t1 (cl (= (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0)) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0)))) :rule trust)
(step st145.t2 (cl (= (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2)))))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0))) (=> (and (consistent$ ?v0) (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0))))) :rule cong :premises (t145.t0 t145.t1))
(step t145.t2 (cl (= (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2)))))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0))) (=> (and (consistent$ ?v0) (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0))))) :rule trust)
(step t145 (cl (= (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (and (member$ ?v1 (alphabet$ ?v0)) (and (member$ ?v2 (alphabet$ ?v0)) (and (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2)))))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0)))) (forall ((?v0 A_tree$) (?v1 A$) (?v2 A$)) (=> (and (consistent$ ?v0) (member$ ?v1 (alphabet$ ?v0)) (member$ ?v2 (alphabet$ ?v0)) (fun_app$b (less_eq$ (fun_app$a (freq$ ?v0) ?v1)) (fun_app$a (freq$ ?v0) ?v2)) (fun_app$b (less_eq$ (depth$ ?v0 ?v1)) (depth$ ?v0 ?v2))) (fun_app$b (less_eq$ (cost$ (fun_app$f (swapSyms$ ?v0 ?v1) ?v2))) (cost$ ?v0)))))) :rule bind)
(step t.end (cl) :rule resolution :premises (nt145.0 t145))
