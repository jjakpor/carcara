(assume nt8.t5.0 (not (= (forall ((env env) (v var_alpha)) (= (eval_alpha env (inj_alpha v)) (evalV_alpha env v))) (forall ((env env) (v var_alpha)) (= (evalV_alpha env v) (eval_alpha env (inj_alpha v)))))))
(anchor :step t8.t5)
(assume t8.a0 (not (p (eval_alpha empty aR))))
(assume t8.a1 (= (eval_alpha empty aR) (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha)))
(assume t8.a2 (= (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha) (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))
(step t8.t38 (cl (not (p (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))) :rule trust)
(step t8 (cl (not (not (p (eval_alpha empty aR)))) (not (= (eval_alpha empty aR) (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha))) (not (= (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha) (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha)))) (not (p (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))) :rule subproof :discharge (t8.a0 t8.a1 t8.a2))
(anchor :step t8.t5 :args ((env env) (v var_alpha) (:= (env env) env) (:= (v var_alpha) v)))
(step st8.t5.t0 (cl (= (= (eval_alpha env (inj_alpha v)) (evalV_alpha env v)) (= (evalV_alpha env v) (eval_alpha env (inj_alpha v))))) :rule hole)
(step t8.t5.t0 (cl (= (= (eval_alpha env (inj_alpha v)) (evalV_alpha env v)) (= (evalV_alpha env v) (eval_alpha env (inj_alpha v))))) :rule trust)
(step t8.t5 (cl (= (forall ((env env) (v var_alpha)) (= (eval_alpha env (inj_alpha v)) (evalV_alpha env v))) (forall ((env env) (v var_alpha)) (= (evalV_alpha env v) (eval_alpha env (inj_alpha v)))))) :rule bind)
(step t.end (cl) :rule resolution :premises (nt8.t5.0 t8.t5))
