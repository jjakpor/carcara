(assume nt8.t12.0 (not (= (forall ((env env) (v var_alpha) (x alpha)) (= (evalV_alpha (push_alpha env v x) v) x)) (forall ((env env) (v var_alpha) (x alpha)) (= x (evalV_alpha (push_alpha env v x) v))))))
(anchor :step t8.t12)
(assume t8.a0 (not (p (eval_alpha empty aR))))
(assume t8.a1 (= (eval_alpha empty aR) (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha)))
(assume t8.a2 (= (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha) (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))
(step t8.t38 (cl (not (p (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))) :rule trust)
(step t8 (cl (not (not (p (eval_alpha empty aR)))) (not (= (eval_alpha empty aR) (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha))) (not (= (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha) (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha)))) (not (p (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))) :rule subproof :discharge (t8.a0 t8.a1 t8.a2))
(anchor :step t8.t12 :args ((env env) (v var_alpha) (x alpha) (:= (env env) env) (:= (v var_alpha) v) (:= (x alpha) x)))
(step st8.t12.t0 (cl (= (= (evalV_alpha (push_alpha env v x) v) x) (= x (evalV_alpha (push_alpha env v x) v)))) :rule hole)
(step t8.t12.t0 (cl (= (= (evalV_alpha (push_alpha env v x) v) x) (= x (evalV_alpha (push_alpha env v x) v)))) :rule trust)
(step t8.t12 (cl (= (forall ((env env) (v var_alpha) (x alpha)) (= (evalV_alpha (push_alpha env v x) v) x)) (forall ((env env) (v var_alpha) (x alpha)) (= x (evalV_alpha (push_alpha env v x) v))))) :rule bind)
(step t.end (cl) :rule resolution :premises (nt8.t12.0 t8.t12))
