(assume nt5.t1.0 (not (= (exists ((?v2 A_stream$) (?v3 A_treeFI$) (?v4 A_treeFI$)) (and (= ?v0 ?v2) (and (= ?v1 ?v3) (and (= (shd$ ?v2) (lab$ ?v3)) (and (member$ ?v4 (set$ (sub$ ?v3))) (fun_app$a (properPath$ (stl$ ?v2)) ?v4)))))) (exists ((?v2 A_stream$) (?v3 A_treeFI$) (?v4 A_treeFI$)) (and (= ?v0 ?v2) (= ?v1 ?v3) (= (shd$ ?v2) (lab$ ?v3)) (member$ ?v4 (set$ (sub$ ?v3))) (fun_app$a (properPath$ (stl$ ?v2)) ?v4))))))
(anchor :step t5.t1 :args ((?v2 A_stream$) (?v3 A_treeFI$) (?v4 A_treeFI$) (:= (?v2 A_stream$) ?v2) (:= (?v3 A_treeFI$) ?v3) (:= (?v4 A_treeFI$) ?v4)))
(step t5.t1.t0 (cl (= (and (= ?v0 ?v2) (and (= ?v1 ?v3) (and (= (shd$ ?v2) (lab$ ?v3)) (and (member$ ?v4 (set$ (sub$ ?v3))) (fun_app$a (properPath$ (stl$ ?v2)) ?v4))))) (and (= ?v0 ?v2) (= ?v1 ?v3) (= (shd$ ?v2) (lab$ ?v3)) (member$ ?v4 (set$ (sub$ ?v3))) (fun_app$a (properPath$ (stl$ ?v2)) ?v4)))) :rule trust)
(step t5.t1 (cl (= (exists ((?v2 A_stream$) (?v3 A_treeFI$) (?v4 A_treeFI$)) (and (= ?v0 ?v2) (and (= ?v1 ?v3) (and (= (shd$ ?v2) (lab$ ?v3)) (and (member$ ?v4 (set$ (sub$ ?v3))) (fun_app$a (properPath$ (stl$ ?v2)) ?v4)))))) (exists ((?v2 A_stream$) (?v3 A_treeFI$) (?v4 A_treeFI$)) (and (= ?v0 ?v2) (= ?v1 ?v3) (= (shd$ ?v2) (lab$ ?v3)) (member$ ?v4 (set$ (sub$ ?v3))) (fun_app$a (properPath$ (stl$ ?v2)) ?v4))))) :rule bind)
(step t.end (cl) :rule resolution :premises (nt5.t1.0 t5.t1))
