(assume nt12.t5.0 (not (= (forall ((?v0 A_llist$) (?v1 Nat_a_llist_fun$) (?v2 Nat$)) (= (fun_app$h (fun_app$o (case_nat$ ?v0) ?v1) (suc$ ?v2)) (fun_app$h ?v1 ?v2))) (forall ((?v0 A_llist$) (?v1 Nat_a_llist_fun$) (?v2 Nat$)) (= (fun_app$h ?v1 ?v2) (fun_app$h (fun_app$o (case_nat$ ?v0) ?v1) (suc$ ?v2)))))))
(anchor :step t12.t5)
(assume t12.a0 (= xs$ (lCons$ (lhd$ xs$) (ltl$ xs$))))
(assume t12.a1 (= (fun_app$c (ldropn$ (suc$ n$)) (lCons$ (lhd$ xs$) (ltl$ xs$))) (fun_app$h (fun_app$o (case_nat$ (lCons$ (lhd$ xs$) (ltl$ xs$))) (uvn$ (ltl$ xs$))) (suc$ n$))))
(assume t12.a2 (= (fun_app$h (fun_app$o (case_nat$ (lCons$ (lhd$ xs$) (ltl$ xs$))) (uvn$ (ltl$ xs$))) (suc$ n$)) (fun_app$h (uvn$ (ltl$ xs$)) n$)))
(assume t12.a3 (not (= (fun_app$c (ldropn$ (suc$ n$)) xs$) (fun_app$c (fun_app$bc (case_llist$ lNil$) uu$) xs$))))
(assume t12.a4 (= (fun_app$c (fun_app$bc (case_llist$ lNil$) uu$) xs$) (ite (fun_app$q lnull$d xs$) lNil$ (fun_app$c (fun_app$e uu$ (lhd$ xs$)) (ltl$ xs$)))))
(assume t12.a5 (= (fun_app$c (fun_app$e uu$ (lhd$ xs$)) (ltl$ xs$)) (ite (fun_app$q lnull$d xs$) lNil$ (fun_app$c (fun_app$e uu$ (lhd$ xs$)) (ltl$ xs$)))))
(assume t12.a6 (= (ldropn$ n$) (fun_app$e uu$ (lhd$ xs$))))
(step t12.t65 (cl (not (= (fun_app$h (uvn$ (ltl$ xs$)) n$) (fun_app$c (ldropn$ n$) (ltl$ xs$))))) :rule trust)
(step t12 (cl (not (= xs$ (lCons$ (lhd$ xs$) (ltl$ xs$)))) (not (= (fun_app$c (ldropn$ (suc$ n$)) (lCons$ (lhd$ xs$) (ltl$ xs$))) (fun_app$h (fun_app$o (case_nat$ (lCons$ (lhd$ xs$) (ltl$ xs$))) (uvn$ (ltl$ xs$))) (suc$ n$)))) (not (= (fun_app$h (fun_app$o (case_nat$ (lCons$ (lhd$ xs$) (ltl$ xs$))) (uvn$ (ltl$ xs$))) (suc$ n$)) (fun_app$h (uvn$ (ltl$ xs$)) n$))) (not (not (= (fun_app$c (ldropn$ (suc$ n$)) xs$) (fun_app$c (fun_app$bc (case_llist$ lNil$) uu$) xs$)))) (not (= (fun_app$c (fun_app$bc (case_llist$ lNil$) uu$) xs$) (ite (fun_app$q lnull$d xs$) lNil$ (fun_app$c (fun_app$e uu$ (lhd$ xs$)) (ltl$ xs$))))) (not (= (fun_app$c (fun_app$e uu$ (lhd$ xs$)) (ltl$ xs$)) (ite (fun_app$q lnull$d xs$) lNil$ (fun_app$c (fun_app$e uu$ (lhd$ xs$)) (ltl$ xs$))))) (not (= (ldropn$ n$) (fun_app$e uu$ (lhd$ xs$)))) (not (= (fun_app$h (uvn$ (ltl$ xs$)) n$) (fun_app$c (ldropn$ n$) (ltl$ xs$))))) :rule subproof :discharge (t12.a0 t12.a1 t12.a2 t12.a3 t12.a4 t12.a5 t12.a6))
(anchor :step t12.t5 :args ((?v0 A_llist$) (?v1 Nat_a_llist_fun$) (?v2 Nat$) (:= (?v0 A_llist$) ?v0) (:= (?v1 Nat_a_llist_fun$) ?v1) (:= (?v2 Nat$) ?v2)))
(step st12.t5.t0 (cl (= (= (fun_app$h (fun_app$o (case_nat$ ?v0) ?v1) (suc$ ?v2)) (fun_app$h ?v1 ?v2)) (= (fun_app$h ?v1 ?v2) (fun_app$h (fun_app$o (case_nat$ ?v0) ?v1) (suc$ ?v2))))) :rule hole)
(step t12.t5.t0 (cl (= (= (fun_app$h (fun_app$o (case_nat$ ?v0) ?v1) (suc$ ?v2)) (fun_app$h ?v1 ?v2)) (= (fun_app$h ?v1 ?v2) (fun_app$h (fun_app$o (case_nat$ ?v0) ?v1) (suc$ ?v2))))) :rule trust)
(step t12.t5 (cl (= (forall ((?v0 A_llist$) (?v1 Nat_a_llist_fun$) (?v2 Nat$)) (= (fun_app$h (fun_app$o (case_nat$ ?v0) ?v1) (suc$ ?v2)) (fun_app$h ?v1 ?v2))) (forall ((?v0 A_llist$) (?v1 Nat_a_llist_fun$) (?v2 Nat$)) (= (fun_app$h ?v1 ?v2) (fun_app$h (fun_app$o (case_nat$ ?v0) ?v1) (suc$ ?v2)))))) :rule bind)
(step t.end (cl) :rule resolution :premises (nt12.t5.0 t12.t5))
