(assume nt12.t21.0 (not (not (forall ((?v0 A$)) (= (fun_app$e uu$ ?v0) (ldropn$ n$))))))
(assume nt12.t21.1 (not (= (fun_app$e uu$ (lhd$ xs$)) (ldropn$ n$))))
(anchor :step t12.t21)
(assume t12.a0 (= xs$ (lCons$ (lhd$ xs$) (ltl$ xs$))))
(assume t12.a1 (= (fun_app$c (ldropn$ (suc$ n$)) (lCons$ (lhd$ xs$) (ltl$ xs$))) (fun_app$h (fun_app$o (case_nat$ (lCons$ (lhd$ xs$) (ltl$ xs$))) (uvn$ (ltl$ xs$))) (suc$ n$))))
(assume t12.a2 (= (fun_app$h (fun_app$o (case_nat$ (lCons$ (lhd$ xs$) (ltl$ xs$))) (uvn$ (ltl$ xs$))) (suc$ n$)) (fun_app$h (uvn$ (ltl$ xs$)) n$)))
(assume t12.a3 (not (= (fun_app$c (ldropn$ (suc$ n$)) xs$) (fun_app$c (fun_app$bc (case_llist$ lNil$) uu$) xs$))))
(assume t12.a4 (= (fun_app$c (fun_app$bc (case_llist$ lNil$) uu$) xs$) (ite (fun_app$q lnull$d xs$) lNil$ (fun_app$c (fun_app$e uu$ (lhd$ xs$)) (ltl$ xs$)))))
(assume t12.a5 (= (fun_app$c (fun_app$e uu$ (lhd$ xs$)) (ltl$ xs$)) (ite (fun_app$q lnull$d xs$) lNil$ (fun_app$c (fun_app$e uu$ (lhd$ xs$)) (ltl$ xs$)))))
(assume t12.a6 (= (ldropn$ n$) (fun_app$e uu$ (lhd$ xs$))))
(step t12.t65 (cl (not (= (fun_app$h (uvn$ (ltl$ xs$)) n$) (fun_app$c (ldropn$ n$) (ltl$ xs$))))) :rule trust)
(step t12 (cl (not (= xs$ (lCons$ (lhd$ xs$) (ltl$ xs$)))) (not (= (fun_app$c (ldropn$ (suc$ n$)) (lCons$ (lhd$ xs$) (ltl$ xs$))) (fun_app$h (fun_app$o (case_nat$ (lCons$ (lhd$ xs$) (ltl$ xs$))) (uvn$ (ltl$ xs$))) (suc$ n$)))) (not (= (fun_app$h (fun_app$o (case_nat$ (lCons$ (lhd$ xs$) (ltl$ xs$))) (uvn$ (ltl$ xs$))) (suc$ n$)) (fun_app$h (uvn$ (ltl$ xs$)) n$))) (not (not (= (fun_app$c (ldropn$ (suc$ n$)) xs$) (fun_app$c (fun_app$bc (case_llist$ lNil$) uu$) xs$)))) (not (= (fun_app$c (fun_app$bc (case_llist$ lNil$) uu$) xs$) (ite (fun_app$q lnull$d xs$) lNil$ (fun_app$c (fun_app$e uu$ (lhd$ xs$)) (ltl$ xs$))))) (not (= (fun_app$c (fun_app$e uu$ (lhd$ xs$)) (ltl$ xs$)) (ite (fun_app$q lnull$d xs$) lNil$ (fun_app$c (fun_app$e uu$ (lhd$ xs$)) (ltl$ xs$))))) (not (= (ldropn$ n$) (fun_app$e uu$ (lhd$ xs$)))) (not (= (fun_app$h (uvn$ (ltl$ xs$)) n$) (fun_app$c (ldropn$ n$) (ltl$ xs$))))) :rule subproof :discharge (t12.a0 t12.a1 t12.a2 t12.a3 t12.a4 t12.a5 t12.a6))
(anchor :step t12.t21)
(assume t12.t21.a0 (forall ((?v0 A$)) (= (fun_app$e uu$ ?v0) (ldropn$ n$))))
(step t12.t21.t1 (cl (not (forall ((?v0 A$)) (= (fun_app$e uu$ ?v0) (ldropn$ n$)))) (= (fun_app$e uu$ (lhd$ xs$)) (ldropn$ n$))) :rule trust)
(step st12.t21.t2 (cl (= (fun_app$e uu$ (lhd$ xs$)) (ldropn$ n$))) :rule resolution :premises (t12.t21.t1 t12.t21.a0))
(step t12.t21.t2 (cl (= (fun_app$e uu$ (lhd$ xs$)) (ldropn$ n$))) :rule trust)
(step t12.t21 (cl (not (forall ((?v0 A$)) (= (fun_app$e uu$ ?v0) (ldropn$ n$)))) (= (fun_app$e uu$ (lhd$ xs$)) (ldropn$ n$))) :rule subproof :discharge (t12.t21.a0))
(step t.end (cl) :rule resolution :premises (nt12.t21.0 nt12.t21.1 t12.t21))
