(assume nt8.0 (not (not (not (p (eval_alpha empty aR))))))
(assume nt8.1 (not (not (= (eval_alpha empty aR) (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha)))))
(assume nt8.2 (not (not (= (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha) (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))))
(assume nt8.3 (not (not (p (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))))
(anchor :step t8)
(assume t8.a0 (not (p (eval_alpha empty aR))))
(assume t8.a1 (= (eval_alpha empty aR) (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha)))
(assume t8.a2 (= (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha) (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))
(step t8.t23 (cl (models empty (pR aR)) (not (p (eval_alpha empty aR))) (not (= (models empty (pR aR)) (p (eval_alpha empty aR))))) :rule trust)
(step t8.t31 (cl (not (models empty (pR aR)))) :rule trust)
(step t8.t34 (cl (= (models empty (pR aR)) (p (eval_alpha empty aR)))) :rule trust)
(step st8.t35 (cl (not (p (eval_alpha empty aR)))) :rule resolution :premises (t8.t23 t8.t31 t8.t34))
(step t8.t38 (cl (not (p (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))) :rule trust)
(step t8 (cl (not (not (p (eval_alpha empty aR)))) (not (= (eval_alpha empty aR) (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha))) (not (= (evalV_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) v0_alpha) (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha)))) (not (p (eval_alpha (push_alpha empty v0_alpha (eval_alpha empty aR)) (inj_alpha v0_alpha))))) :rule subproof :discharge (t8.a0 t8.a1 t8.a2))
(step t.end (cl) :rule resolution :premises (nt8.0 nt8.1 nt8.2 nt8.3 t8))
