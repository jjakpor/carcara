(assume nt83.0 (not (= (forall ((?f FldLoc) (?x Loc) (?y Loc)) (or (not (= (read$0 ?f ?x) ?x)) (not (Btwn$0 ?f ?x ?y ?y)) (= ?x ?y))) (forall ((?f FldLoc) (?x Loc) (?y Loc)) (or (not (= ?x (read$0 ?f ?x))) (not (Btwn$0 ?f ?x ?y ?y)) (= ?x ?y))))))
(anchor :step t83 :args ((?f FldLoc) (?x Loc) (?y Loc) (:= (?f FldLoc) ?f) (:= (?x Loc) ?x) (:= (?y Loc) ?y)))
(step st83.t0 (cl (= (= (read$0 ?f ?x) ?x) (= ?x (read$0 ?f ?x)))) :rule hole)
(step t83.t4 (cl (= (or (not (= (read$0 ?f ?x) ?x)) (not (Btwn$0 ?f ?x ?y ?y)) (= ?x ?y)) (or (not (= ?x (read$0 ?f ?x))) (not (Btwn$0 ?f ?x ?y ?y)) (= ?x ?y)))) :rule trust)
(step t83 (cl (= (forall ((?f FldLoc) (?x Loc) (?y Loc)) (or (not (= (read$0 ?f ?x) ?x)) (not (Btwn$0 ?f ?x ?y ?y)) (= ?x ?y))) (forall ((?f FldLoc) (?x Loc) (?y Loc)) (or (not (= ?x (read$0 ?f ?x))) (not (Btwn$0 ?f ?x ?y ?y)) (= ?x ?y))))) :rule bind)
(step t.end (cl) :rule resolution :premises (nt83.0 t83))
